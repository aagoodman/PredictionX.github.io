// [AIV_SHORT]  Version: 1.1.3 - Wednesday, September 4th, 2019, 12:25:26 PM  
 /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/bootstrap/dist/css/bootstrap.min.css":
/*!***********************************************************!*\
  !*** ./node_modules/bootstrap/dist/css/bootstrap.min.css ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./node_modules/bootstrap/dist/css/bootstrap.min.css?");

/***/ }),

/***/ "./node_modules/bootstrap/js/dist/tooltip.js":
/*!***************************************************!*\
  !*** ./node_modules/bootstrap/js/dist/tooltip.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? module.exports = factory(__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! popper.js */ \"./node_modules/popper.js/dist/esm/popper.js\"), __webpack_require__(/*! ./util.js */ \"./node_modules/bootstrap/js/dist/util.js\")) :\n  undefined;\n}(this, (function ($,Popper,Util) { 'use strict';\n\n  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;\n  Popper = Popper && Popper.hasOwnProperty('default') ? Popper['default'] : Popper;\n  Util = Util && Util.hasOwnProperty('default') ? Util['default'] : Util;\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.1.3): tooltip.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  var Tooltip = function ($$$1) {\n    /**\n     * ------------------------------------------------------------------------\n     * Constants\n     * ------------------------------------------------------------------------\n     */\n    var NAME = 'tooltip';\n    var VERSION = '4.1.3';\n    var DATA_KEY = 'bs.tooltip';\n    var EVENT_KEY = \".\" + DATA_KEY;\n    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];\n    var CLASS_PREFIX = 'bs-tooltip';\n    var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX + \"\\\\S+\", 'g');\n    var DefaultType = {\n      animation: 'boolean',\n      template: 'string',\n      title: '(string|element|function)',\n      trigger: 'string',\n      delay: '(number|object)',\n      html: 'boolean',\n      selector: '(string|boolean)',\n      placement: '(string|function)',\n      offset: '(number|string)',\n      container: '(string|element|boolean)',\n      fallbackPlacement: '(string|array)',\n      boundary: '(string|element)'\n    };\n    var AttachmentMap = {\n      AUTO: 'auto',\n      TOP: 'top',\n      RIGHT: 'right',\n      BOTTOM: 'bottom',\n      LEFT: 'left'\n    };\n    var Default = {\n      animation: true,\n      template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<div class=\"tooltip-inner\"></div></div>',\n      trigger: 'hover focus',\n      title: '',\n      delay: 0,\n      html: false,\n      selector: false,\n      placement: 'top',\n      offset: 0,\n      container: false,\n      fallbackPlacement: 'flip',\n      boundary: 'scrollParent'\n    };\n    var HoverState = {\n      SHOW: 'show',\n      OUT: 'out'\n    };\n    var Event = {\n      HIDE: \"hide\" + EVENT_KEY,\n      HIDDEN: \"hidden\" + EVENT_KEY,\n      SHOW: \"show\" + EVENT_KEY,\n      SHOWN: \"shown\" + EVENT_KEY,\n      INSERTED: \"inserted\" + EVENT_KEY,\n      CLICK: \"click\" + EVENT_KEY,\n      FOCUSIN: \"focusin\" + EVENT_KEY,\n      FOCUSOUT: \"focusout\" + EVENT_KEY,\n      MOUSEENTER: \"mouseenter\" + EVENT_KEY,\n      MOUSELEAVE: \"mouseleave\" + EVENT_KEY\n    };\n    var ClassName = {\n      FADE: 'fade',\n      SHOW: 'show'\n    };\n    var Selector = {\n      TOOLTIP: '.tooltip',\n      TOOLTIP_INNER: '.tooltip-inner',\n      ARROW: '.arrow'\n    };\n    var Trigger = {\n      HOVER: 'hover',\n      FOCUS: 'focus',\n      CLICK: 'click',\n      MANUAL: 'manual'\n      /**\n       * ------------------------------------------------------------------------\n       * Class Definition\n       * ------------------------------------------------------------------------\n       */\n\n    };\n\n    var Tooltip =\n    /*#__PURE__*/\n    function () {\n      function Tooltip(element, config) {\n        /**\n         * Check for Popper dependency\n         * Popper - https://popper.js.org\n         */\n        if (typeof Popper === 'undefined') {\n          throw new TypeError('Bootstrap tooltips require Popper.js (https://popper.js.org)');\n        } // private\n\n\n        this._isEnabled = true;\n        this._timeout = 0;\n        this._hoverState = '';\n        this._activeTrigger = {};\n        this._popper = null; // Protected\n\n        this.element = element;\n        this.config = this._getConfig(config);\n        this.tip = null;\n\n        this._setListeners();\n      } // Getters\n\n\n      var _proto = Tooltip.prototype;\n\n      // Public\n      _proto.enable = function enable() {\n        this._isEnabled = true;\n      };\n\n      _proto.disable = function disable() {\n        this._isEnabled = false;\n      };\n\n      _proto.toggleEnabled = function toggleEnabled() {\n        this._isEnabled = !this._isEnabled;\n      };\n\n      _proto.toggle = function toggle(event) {\n        if (!this._isEnabled) {\n          return;\n        }\n\n        if (event) {\n          var dataKey = this.constructor.DATA_KEY;\n          var context = $$$1(event.currentTarget).data(dataKey);\n\n          if (!context) {\n            context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n            $$$1(event.currentTarget).data(dataKey, context);\n          }\n\n          context._activeTrigger.click = !context._activeTrigger.click;\n\n          if (context._isWithActiveTrigger()) {\n            context._enter(null, context);\n          } else {\n            context._leave(null, context);\n          }\n        } else {\n          if ($$$1(this.getTipElement()).hasClass(ClassName.SHOW)) {\n            this._leave(null, this);\n\n            return;\n          }\n\n          this._enter(null, this);\n        }\n      };\n\n      _proto.dispose = function dispose() {\n        clearTimeout(this._timeout);\n        $$$1.removeData(this.element, this.constructor.DATA_KEY);\n        $$$1(this.element).off(this.constructor.EVENT_KEY);\n        $$$1(this.element).closest('.modal').off('hide.bs.modal');\n\n        if (this.tip) {\n          $$$1(this.tip).remove();\n        }\n\n        this._isEnabled = null;\n        this._timeout = null;\n        this._hoverState = null;\n        this._activeTrigger = null;\n\n        if (this._popper !== null) {\n          this._popper.destroy();\n        }\n\n        this._popper = null;\n        this.element = null;\n        this.config = null;\n        this.tip = null;\n      };\n\n      _proto.show = function show() {\n        var _this = this;\n\n        if ($$$1(this.element).css('display') === 'none') {\n          throw new Error('Please use show on visible elements');\n        }\n\n        var showEvent = $$$1.Event(this.constructor.Event.SHOW);\n\n        if (this.isWithContent() && this._isEnabled) {\n          $$$1(this.element).trigger(showEvent);\n          var isInTheDom = $$$1.contains(this.element.ownerDocument.documentElement, this.element);\n\n          if (showEvent.isDefaultPrevented() || !isInTheDom) {\n            return;\n          }\n\n          var tip = this.getTipElement();\n          var tipId = Util.getUID(this.constructor.NAME);\n          tip.setAttribute('id', tipId);\n          this.element.setAttribute('aria-describedby', tipId);\n          this.setContent();\n\n          if (this.config.animation) {\n            $$$1(tip).addClass(ClassName.FADE);\n          }\n\n          var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n\n          var attachment = this._getAttachment(placement);\n\n          this.addAttachmentClass(attachment);\n          var container = this.config.container === false ? document.body : $$$1(document).find(this.config.container);\n          $$$1(tip).data(this.constructor.DATA_KEY, this);\n\n          if (!$$$1.contains(this.element.ownerDocument.documentElement, this.tip)) {\n            $$$1(tip).appendTo(container);\n          }\n\n          $$$1(this.element).trigger(this.constructor.Event.INSERTED);\n          this._popper = new Popper(this.element, tip, {\n            placement: attachment,\n            modifiers: {\n              offset: {\n                offset: this.config.offset\n              },\n              flip: {\n                behavior: this.config.fallbackPlacement\n              },\n              arrow: {\n                element: Selector.ARROW\n              },\n              preventOverflow: {\n                boundariesElement: this.config.boundary\n              }\n            },\n            onCreate: function onCreate(data) {\n              if (data.originalPlacement !== data.placement) {\n                _this._handlePopperPlacementChange(data);\n              }\n            },\n            onUpdate: function onUpdate(data) {\n              _this._handlePopperPlacementChange(data);\n            }\n          });\n          $$$1(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra\n          // empty mouseover listeners to the body's immediate children;\n          // only needed because of broken event delegation on iOS\n          // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n          if ('ontouchstart' in document.documentElement) {\n            $$$1(document.body).children().on('mouseover', null, $$$1.noop);\n          }\n\n          var complete = function complete() {\n            if (_this.config.animation) {\n              _this._fixTransition();\n            }\n\n            var prevHoverState = _this._hoverState;\n            _this._hoverState = null;\n            $$$1(_this.element).trigger(_this.constructor.Event.SHOWN);\n\n            if (prevHoverState === HoverState.OUT) {\n              _this._leave(null, _this);\n            }\n          };\n\n          if ($$$1(this.tip).hasClass(ClassName.FADE)) {\n            var transitionDuration = Util.getTransitionDurationFromElement(this.tip);\n            $$$1(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n          } else {\n            complete();\n          }\n        }\n      };\n\n      _proto.hide = function hide(callback) {\n        var _this2 = this;\n\n        var tip = this.getTipElement();\n        var hideEvent = $$$1.Event(this.constructor.Event.HIDE);\n\n        var complete = function complete() {\n          if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {\n            tip.parentNode.removeChild(tip);\n          }\n\n          _this2._cleanTipClass();\n\n          _this2.element.removeAttribute('aria-describedby');\n\n          $$$1(_this2.element).trigger(_this2.constructor.Event.HIDDEN);\n\n          if (_this2._popper !== null) {\n            _this2._popper.destroy();\n          }\n\n          if (callback) {\n            callback();\n          }\n        };\n\n        $$$1(this.element).trigger(hideEvent);\n\n        if (hideEvent.isDefaultPrevented()) {\n          return;\n        }\n\n        $$$1(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n        if ('ontouchstart' in document.documentElement) {\n          $$$1(document.body).children().off('mouseover', null, $$$1.noop);\n        }\n\n        this._activeTrigger[Trigger.CLICK] = false;\n        this._activeTrigger[Trigger.FOCUS] = false;\n        this._activeTrigger[Trigger.HOVER] = false;\n\n        if ($$$1(this.tip).hasClass(ClassName.FADE)) {\n          var transitionDuration = Util.getTransitionDurationFromElement(tip);\n          $$$1(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n        } else {\n          complete();\n        }\n\n        this._hoverState = '';\n      };\n\n      _proto.update = function update() {\n        if (this._popper !== null) {\n          this._popper.scheduleUpdate();\n        }\n      }; // Protected\n\n\n      _proto.isWithContent = function isWithContent() {\n        return Boolean(this.getTitle());\n      };\n\n      _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n        $$$1(this.getTipElement()).addClass(CLASS_PREFIX + \"-\" + attachment);\n      };\n\n      _proto.getTipElement = function getTipElement() {\n        this.tip = this.tip || $$$1(this.config.template)[0];\n        return this.tip;\n      };\n\n      _proto.setContent = function setContent() {\n        var tip = this.getTipElement();\n        this.setElementContent($$$1(tip.querySelectorAll(Selector.TOOLTIP_INNER)), this.getTitle());\n        $$$1(tip).removeClass(ClassName.FADE + \" \" + ClassName.SHOW);\n      };\n\n      _proto.setElementContent = function setElementContent($element, content) {\n        var html = this.config.html;\n\n        if (typeof content === 'object' && (content.nodeType || content.jquery)) {\n          // Content is a DOM node or a jQuery\n          if (html) {\n            if (!$$$1(content).parent().is($element)) {\n              $element.empty().append(content);\n            }\n          } else {\n            $element.text($$$1(content).text());\n          }\n        } else {\n          $element[html ? 'html' : 'text'](content);\n        }\n      };\n\n      _proto.getTitle = function getTitle() {\n        var title = this.element.getAttribute('data-original-title');\n\n        if (!title) {\n          title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n        }\n\n        return title;\n      }; // Private\n\n\n      _proto._getAttachment = function _getAttachment(placement) {\n        return AttachmentMap[placement.toUpperCase()];\n      };\n\n      _proto._setListeners = function _setListeners() {\n        var _this3 = this;\n\n        var triggers = this.config.trigger.split(' ');\n        triggers.forEach(function (trigger) {\n          if (trigger === 'click') {\n            $$$1(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {\n              return _this3.toggle(event);\n            });\n          } else if (trigger !== Trigger.MANUAL) {\n            var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;\n            var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;\n            $$$1(_this3.element).on(eventIn, _this3.config.selector, function (event) {\n              return _this3._enter(event);\n            }).on(eventOut, _this3.config.selector, function (event) {\n              return _this3._leave(event);\n            });\n          }\n\n          $$$1(_this3.element).closest('.modal').on('hide.bs.modal', function () {\n            return _this3.hide();\n          });\n        });\n\n        if (this.config.selector) {\n          this.config = _objectSpread({}, this.config, {\n            trigger: 'manual',\n            selector: ''\n          });\n        } else {\n          this._fixTitle();\n        }\n      };\n\n      _proto._fixTitle = function _fixTitle() {\n        var titleType = typeof this.element.getAttribute('data-original-title');\n\n        if (this.element.getAttribute('title') || titleType !== 'string') {\n          this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n          this.element.setAttribute('title', '');\n        }\n      };\n\n      _proto._enter = function _enter(event, context) {\n        var dataKey = this.constructor.DATA_KEY;\n        context = context || $$$1(event.currentTarget).data(dataKey);\n\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $$$1(event.currentTarget).data(dataKey, context);\n        }\n\n        if (event) {\n          context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;\n        }\n\n        if ($$$1(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {\n          context._hoverState = HoverState.SHOW;\n          return;\n        }\n\n        clearTimeout(context._timeout);\n        context._hoverState = HoverState.SHOW;\n\n        if (!context.config.delay || !context.config.delay.show) {\n          context.show();\n          return;\n        }\n\n        context._timeout = setTimeout(function () {\n          if (context._hoverState === HoverState.SHOW) {\n            context.show();\n          }\n        }, context.config.delay.show);\n      };\n\n      _proto._leave = function _leave(event, context) {\n        var dataKey = this.constructor.DATA_KEY;\n        context = context || $$$1(event.currentTarget).data(dataKey);\n\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $$$1(event.currentTarget).data(dataKey, context);\n        }\n\n        if (event) {\n          context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;\n        }\n\n        if (context._isWithActiveTrigger()) {\n          return;\n        }\n\n        clearTimeout(context._timeout);\n        context._hoverState = HoverState.OUT;\n\n        if (!context.config.delay || !context.config.delay.hide) {\n          context.hide();\n          return;\n        }\n\n        context._timeout = setTimeout(function () {\n          if (context._hoverState === HoverState.OUT) {\n            context.hide();\n          }\n        }, context.config.delay.hide);\n      };\n\n      _proto._isWithActiveTrigger = function _isWithActiveTrigger() {\n        for (var trigger in this._activeTrigger) {\n          if (this._activeTrigger[trigger]) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      _proto._getConfig = function _getConfig(config) {\n        config = _objectSpread({}, this.constructor.Default, $$$1(this.element).data(), typeof config === 'object' && config ? config : {});\n\n        if (typeof config.delay === 'number') {\n          config.delay = {\n            show: config.delay,\n            hide: config.delay\n          };\n        }\n\n        if (typeof config.title === 'number') {\n          config.title = config.title.toString();\n        }\n\n        if (typeof config.content === 'number') {\n          config.content = config.content.toString();\n        }\n\n        Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n        return config;\n      };\n\n      _proto._getDelegateConfig = function _getDelegateConfig() {\n        var config = {};\n\n        if (this.config) {\n          for (var key in this.config) {\n            if (this.constructor.Default[key] !== this.config[key]) {\n              config[key] = this.config[key];\n            }\n          }\n        }\n\n        return config;\n      };\n\n      _proto._cleanTipClass = function _cleanTipClass() {\n        var $tip = $$$1(this.getTipElement());\n        var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n\n        if (tabClass !== null && tabClass.length) {\n          $tip.removeClass(tabClass.join(''));\n        }\n      };\n\n      _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {\n        var popperInstance = popperData.instance;\n        this.tip = popperInstance.popper;\n\n        this._cleanTipClass();\n\n        this.addAttachmentClass(this._getAttachment(popperData.placement));\n      };\n\n      _proto._fixTransition = function _fixTransition() {\n        var tip = this.getTipElement();\n        var initConfigAnimation = this.config.animation;\n\n        if (tip.getAttribute('x-placement') !== null) {\n          return;\n        }\n\n        $$$1(tip).removeClass(ClassName.FADE);\n        this.config.animation = false;\n        this.hide();\n        this.show();\n        this.config.animation = initConfigAnimation;\n      }; // Static\n\n\n      Tooltip._jQueryInterface = function _jQueryInterface(config) {\n        return this.each(function () {\n          var data = $$$1(this).data(DATA_KEY);\n\n          var _config = typeof config === 'object' && config;\n\n          if (!data && /dispose|hide/.test(config)) {\n            return;\n          }\n\n          if (!data) {\n            data = new Tooltip(this, _config);\n            $$$1(this).data(DATA_KEY, data);\n          }\n\n          if (typeof config === 'string') {\n            if (typeof data[config] === 'undefined') {\n              throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n            }\n\n            data[config]();\n          }\n        });\n      };\n\n      _createClass(Tooltip, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return VERSION;\n        }\n      }, {\n        key: \"Default\",\n        get: function get() {\n          return Default;\n        }\n      }, {\n        key: \"NAME\",\n        get: function get() {\n          return NAME;\n        }\n      }, {\n        key: \"DATA_KEY\",\n        get: function get() {\n          return DATA_KEY;\n        }\n      }, {\n        key: \"Event\",\n        get: function get() {\n          return Event;\n        }\n      }, {\n        key: \"EVENT_KEY\",\n        get: function get() {\n          return EVENT_KEY;\n        }\n      }, {\n        key: \"DefaultType\",\n        get: function get() {\n          return DefaultType;\n        }\n      }]);\n\n      return Tooltip;\n    }();\n    /**\n     * ------------------------------------------------------------------------\n     * jQuery\n     * ------------------------------------------------------------------------\n     */\n\n\n    $$$1.fn[NAME] = Tooltip._jQueryInterface;\n    $$$1.fn[NAME].Constructor = Tooltip;\n\n    $$$1.fn[NAME].noConflict = function () {\n      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;\n      return Tooltip._jQueryInterface;\n    };\n\n    return Tooltip;\n  }($, Popper);\n\n  return Tooltip;\n\n})));\n//# sourceMappingURL=tooltip.js.map\n\n\n//# sourceURL=webpack:///./node_modules/bootstrap/js/dist/tooltip.js?");

/***/ }),

/***/ "./node_modules/bootstrap/js/dist/util.js":
/*!************************************************!*\
  !*** ./node_modules/bootstrap/js/dist/util.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? module.exports = factory(__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")) :\n  undefined;\n}(this, (function ($) { 'use strict';\n\n  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.1.3): util.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  var Util = function ($$$1) {\n    /**\n     * ------------------------------------------------------------------------\n     * Private TransitionEnd Helpers\n     * ------------------------------------------------------------------------\n     */\n    var TRANSITION_END = 'transitionend';\n    var MAX_UID = 1000000;\n    var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n    function toType(obj) {\n      return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n    }\n\n    function getSpecialTransitionEndEvent() {\n      return {\n        bindType: TRANSITION_END,\n        delegateType: TRANSITION_END,\n        handle: function handle(event) {\n          if ($$$1(event.target).is(this)) {\n            return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n          }\n\n          return undefined; // eslint-disable-line no-undefined\n        }\n      };\n    }\n\n    function transitionEndEmulator(duration) {\n      var _this = this;\n\n      var called = false;\n      $$$1(this).one(Util.TRANSITION_END, function () {\n        called = true;\n      });\n      setTimeout(function () {\n        if (!called) {\n          Util.triggerTransitionEnd(_this);\n        }\n      }, duration);\n      return this;\n    }\n\n    function setTransitionEndSupport() {\n      $$$1.fn.emulateTransitionEnd = transitionEndEmulator;\n      $$$1.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n    }\n    /**\n     * --------------------------------------------------------------------------\n     * Public Util Api\n     * --------------------------------------------------------------------------\n     */\n\n\n    var Util = {\n      TRANSITION_END: 'bsTransitionEnd',\n      getUID: function getUID(prefix) {\n        do {\n          // eslint-disable-next-line no-bitwise\n          prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n        } while (document.getElementById(prefix));\n\n        return prefix;\n      },\n      getSelectorFromElement: function getSelectorFromElement(element) {\n        var selector = element.getAttribute('data-target');\n\n        if (!selector || selector === '#') {\n          selector = element.getAttribute('href') || '';\n        }\n\n        try {\n          return document.querySelector(selector) ? selector : null;\n        } catch (err) {\n          return null;\n        }\n      },\n      getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n        if (!element) {\n          return 0;\n        } // Get transition-duration of the element\n\n\n        var transitionDuration = $$$1(element).css('transition-duration');\n        var floatTransitionDuration = parseFloat(transitionDuration); // Return 0 if element or transition duration is not found\n\n        if (!floatTransitionDuration) {\n          return 0;\n        } // If multiple durations are defined, take the first\n\n\n        transitionDuration = transitionDuration.split(',')[0];\n        return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;\n      },\n      reflow: function reflow(element) {\n        return element.offsetHeight;\n      },\n      triggerTransitionEnd: function triggerTransitionEnd(element) {\n        $$$1(element).trigger(TRANSITION_END);\n      },\n      // TODO: Remove in v5\n      supportsTransitionEnd: function supportsTransitionEnd() {\n        return Boolean(TRANSITION_END);\n      },\n      isElement: function isElement(obj) {\n        return (obj[0] || obj).nodeType;\n      },\n      typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n        for (var property in configTypes) {\n          if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n            var expectedTypes = configTypes[property];\n            var value = config[property];\n            var valueType = value && Util.isElement(value) ? 'element' : toType(value);\n\n            if (!new RegExp(expectedTypes).test(valueType)) {\n              throw new Error(componentName.toUpperCase() + \": \" + (\"Option \\\"\" + property + \"\\\" provided type \\\"\" + valueType + \"\\\" \") + (\"but expected type \\\"\" + expectedTypes + \"\\\".\"));\n            }\n          }\n        }\n      }\n    };\n    setTransitionEndSupport();\n    return Util;\n  }($);\n\n  return Util;\n\n})));\n//# sourceMappingURL=util.js.map\n\n\n//# sourceURL=webpack:///./node_modules/bootstrap/js/dist/util.js?");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.3.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2018-01-20T17:24Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif (  true && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n      // We don't want to classify *any* DOM node as a function.\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, doc, node ) {\n\t\tdoc = doc || document;\n\n\t\tvar i,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\t\t\t\tif ( node[ i ] ) {\n\t\t\t\t\tscript[ i ] = node[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.3.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n        if ( nodeName( elem, \"iframe\" ) ) {\n            return elem.contentDocument;\n        }\n\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n        // Treat the template element as a regular one in browsers that\n        // don't support it.\n        if ( nodeName( elem, \"template\" ) ) {\n            elem = elem.content || elem;\n        }\n\n        return jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc, node );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = div.offsetWidth === 36 || \"absolute\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a property mapped along what jQuery.cssProps suggests or to\n// a vendor prefixed property.\nfunction finalPropName( name ) {\n\tvar ret = jQuery.cssProps[ name ];\n\tif ( !ret ) {\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\n\t}\n\treturn ret;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\t\t) );\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\t\tval = curCSS( elem, dimension, styles ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox;\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\t// Check for style in case a browser which returns unreliable values\n\t// for getComputedStyle silently falls back to the reliable elem.style\n\tvalueIsBorderBox = valueIsBorderBox &&\n\t\t( support.boxSizingReliable() || val === elem.style[ dimension ] );\n\n\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\t// Support: Android <=4.1 - 4.3 only\n\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\tif ( val === \"auto\" ||\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) {\n\n\t\tval = elem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];\n\n\t\t// offsetWidth/offsetHeight provide border-box values\n\t\tvalueIsBorderBox = true;\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\t\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra && boxModelAdjustment(\n\t\t\t\t\telem,\n\t\t\t\t\tdimension,\n\t\t\t\t\textra,\n\t\t\t\t\tisBorderBox,\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && support.scrollboxSize() === styles.position ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = Date.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n\n\n//# sourceURL=webpack:///./node_modules/jquery/dist/jquery.js?");

/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.14.6\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nvar longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nvar timeoutDuration = 0;\nfor (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop, 10);\n    var marginLeft = parseFloat(styles.marginLeft, 10);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicity asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthOddness = reference.width % 2 === popper.width % 2;\n  var bothOddWidth = reference.width % 2 === 1 && popper.width % 2 === 1;\n  var noRound = function noRound(v) {\n    return v;\n  };\n\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthOddness ? Math.round : Math.floor;\n  var verticalToInteger = !shouldRound ? noRound : Math.round;\n\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\n\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport'\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Popper);\n//# sourceMappingURL=popper.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/popper.js/dist/esm/popper.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/common.css":
/*!************************!*\
  !*** ./src/common.css ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/common.css?");

/***/ }),

/***/ "./src/common.js":
/*!***********************!*\
  !*** ./src/common.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("if (typeof(jQuery) === \"undefined\") {\n    jQuery = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n}\njQuery(document).ready(function() {\n    // Add warning to studio about the issues it has\n    if (window.location.host.indexOf('studio') !== -1) {\n        setTimeout(function() {\n\n            jQuery('.hxat-lite-area').parent().before('<div><strong>Reminder:</strong> Have you filled out the <a href=\"https://goo.gl/forms/tMREEJHMRuuznacf2\">Google Form</a> to include this instance?</div></div><div class=\"hx-warning hx-alert\">Warning: Due to issues in studio, the tool below may not be displayed correctly. Please view in \"Preview\" or \"Live\" to make sure things are okay.</div>')\n            jQuery('.hxat-lite-area').hide();\n        }, 2000);\n    }\n\n    // This will change the sizes of the sidebar and Mirador instances depending on whether the sidebar is present.\n    jQuery('.sidebar').click(function() {\n        if (jQuery(this).hasClass('open')) {\n            jQuery(this).removeClass('open');\n            jQuery('#viewer').css('width', '100%');\n            jQuery('.sidebar').html(\"Show Annotation List\");\n            jQuery('.vjs-waveform').css('width', '100%')\n            jQuery('.annotationSection').hide();\n        } else {\n            jQuery(this).addClass('open');\n            jQuery('#viewer').css('width', 'calc(100% - 310px)');\n            jQuery('.sidebar').html(\"Hide Annotation List\");\n            jQuery('.annotationSection').show();\n            jQuery('.vjs-waveform').css('width', '100%');\n            jQuery('.annotationSection').css('height', jQuery('#viewer').outerHeight() + 'px');\n        }\n\n        // needed to handle events in both IE and literally everything else.\n        // this calls the \"resize\" event forcing Mirador to redraw everything to the new sizes\n        var evt;\n        try {\n            evt = new Event('resize');\n        } catch(e) {\n            evt = window.document.createEvent('UIEvents');\n            evt.initUIEvent('resize', true, false, window, 0);\n        }\n        window.dispatchEvent(evt);\n    });\n});\n\n\n//# sourceURL=webpack:///./src/common.js?");

/***/ }),

/***/ "./src/edited/summernote_for_hxatlite.js":
/*!***********************************************!*\
  !*** ./src/edited/summernote_for_hxatlite.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Super simple wysiwyg editor on Bootstrap v0.6.7\n * http://summernote.org/\n *\n * summernote.js\n * Copyright 2013-2015 Alan Hong. and other contributors\n * summernote may be freely distributed under the MIT license./\n *\n * Date: 2015-05-17T06:58Z\n */\n(function (factory) {\n  // Browser globals: jQuery\n  factory(window.jQuery);\n}(function ($) {\n  \n\n\n  if (!Array.prototype.reduce) {\n    /**\n     * Array.prototype.reduce polyfill\n     *\n     * @param {Function} callback\n     * @param {Value} [initialValue]\n     * @return {Value}\n     *\n     * @see http://goo.gl/WNriQD\n     */\n    Array.prototype.reduce = function (callback) {\n      var t = Object(this), len = t.length >>> 0, k = 0, value;\n      if (arguments.length === 2) {\n        value = arguments[1];\n      } else {\n        while (k < len && !(k in t)) {\n          k++;\n        }\n        if (k >= len) {\n          throw new TypeError('Reduce of empty array with no initial value');\n        }\n        value = t[k++];\n      }\n      for (; k < len; k++) {\n        if (k in t) {\n          value = callback(value, t[k], k, t);\n        }\n      }\n      return value;\n    };\n  }\n\n  if ('function' !== typeof Array.prototype.filter) {\n    /**\n     * Array.prototype.filter polyfill\n     *\n     * @param {Function} func\n     * @return {Array}\n     *\n     * @see http://goo.gl/T1KFnq\n     */\n    Array.prototype.filter = function (func) {\n      var t = Object(this), len = t.length >>> 0;\n\n      var res = [];\n      var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n      for (var i = 0; i < len; i++) {\n        if (i in t) {\n          var val = t[i];\n          if (func.call(thisArg, val, i, t)) {\n            res.push(val);\n          }\n        }\n      }\n  \n      return res;\n    };\n  }\n\n  var isSupportAmd =  true && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\");\n\n  /**\n   * returns whether font is installed or not.\n   *\n   * @param {String} fontName\n   * @return {Boolean}\n   */\n  var isFontInstalled = function (fontName) {\n    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n    var $tester = $('<div>').css({\n      position: 'absolute',\n      left: '-9999px',\n      top: '-9999px',\n      fontSize: '200px'\n    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\n    var originalWidth = $tester.css('fontFamily', testFontName).width();\n    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\n    $tester.remove();\n\n    return originalWidth !== width;\n  };\n\n  var userAgent = navigator.userAgent;\n\n  /**\n   * @class core.agent\n   *\n   * Object which check platform and agent\n   *\n   * @singleton\n   * @alternateClassName agent\n   */\n  var agent = {\n    /** @property {Boolean} [isMac=false] true if this agent is Mac  */\n    isMac: navigator.appVersion.indexOf('Mac') > -1,\n    /** @property {Boolean} [isMSIE=false] true if this agent is a Internet Explorer  */\n    isMSIE: /MSIE|Trident/i.test(userAgent),\n    /** @property {Boolean} [isFF=false] true if this agent is a Firefox  */\n    isFF: /firefox/i.test(userAgent),\n    isWebkit: /webkit/i.test(userAgent),\n    /** @property {Boolean} [isSafari=false] true if this agent is a Safari  */\n    isSafari: /safari/i.test(userAgent),\n    /** @property {String} jqueryVersion current jQuery version string  */\n    jqueryVersion: parseFloat($.fn.jquery),\n    isSupportAmd: isSupportAmd,\n    hasCodeMirror: false,\n    isFontInstalled: isFontInstalled,\n    isW3CRangeSupport: !!document.createRange\n  };\n\n  /**\n   * @class core.func\n   *\n   * func utils (for high-order func's arg)\n   *\n   * @singleton\n   * @alternateClassName func\n   */\n  var func = (function () {\n    var eq = function (itemA) {\n      return function (itemB) {\n        return itemA === itemB;\n      };\n    };\n\n    var eq2 = function (itemA, itemB) {\n      return itemA === itemB;\n    };\n\n    var peq2 = function (propName) {\n      return function (itemA, itemB) {\n        return itemA[propName] === itemB[propName];\n      };\n    };\n\n    var ok = function () {\n      return true;\n    };\n\n    var fail = function () {\n      return false;\n    };\n\n    var not = function (f) {\n      return function () {\n        return !f.apply(f, arguments);\n      };\n    };\n\n    var and = function (fA, fB) {\n      return function (item) {\n        return fA(item) && fB(item);\n      };\n    };\n\n    var self = function (a) {\n      return a;\n    };\n\n    var idCounter = 0;\n\n    /**\n     * generate a globally-unique id\n     *\n     * @param {String} [prefix]\n     */\n    var uniqueId = function (prefix) {\n      var id = ++idCounter + '';\n      return prefix ? prefix + id : id;\n    };\n\n    /**\n     * returns bnd (bounds) from rect\n     *\n     * - IE Compatability Issue: http://goo.gl/sRLOAo\n     * - Scroll Issue: http://goo.gl/sNjUc\n     *\n     * @param {Rect} rect\n     * @return {Object} bounds\n     * @return {Number} bounds.top\n     * @return {Number} bounds.left\n     * @return {Number} bounds.width\n     * @return {Number} bounds.height\n     */\n    var rect2bnd = function (rect) {\n      var $document = $(document);\n      return {\n        top: rect.top + $document.scrollTop(),\n        left: rect.left + $document.scrollLeft(),\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    };\n\n    /**\n     * returns a copy of the object where the keys have become the values and the values the keys.\n     * @param {Object} obj\n     * @return {Object}\n     */\n    var invertObject = function (obj) {\n      var inverted = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          inverted[obj[key]] = key;\n        }\n      }\n      return inverted;\n    };\n\n    /**\n     * @param {String} namespace\n     * @param {String} [prefix]\n     * @return {String}\n     */\n    var namespaceToCamel = function (namespace, prefix) {\n      prefix = prefix || '';\n      return prefix + namespace.split('.').map(function (name) {\n        return name.substring(0, 1).toUpperCase() + name.substring(1);\n      }).join('');\n    };\n\n    return {\n      eq: eq,\n      eq2: eq2,\n      peq2: peq2,\n      ok: ok,\n      fail: fail,\n      self: self,\n      not: not,\n      and: and,\n      uniqueId: uniqueId,\n      rect2bnd: rect2bnd,\n      invertObject: invertObject,\n      namespaceToCamel: namespaceToCamel\n    };\n  })();\n\n  /**\n   * @class core.list\n   *\n   * list utils\n   *\n   * @singleton\n   * @alternateClassName list\n   */\n  var list = (function () {\n    /**\n     * returns the first item of an array.\n     *\n     * @param {Array} array\n     */\n    var head = function (array) {\n      return array[0];\n    };\n\n    /**\n     * returns the last item of an array.\n     *\n     * @param {Array} array\n     */\n    var last = function (array) {\n      return array[array.length - 1];\n    };\n\n    /**\n     * returns everything but the last entry of the array.\n     *\n     * @param {Array} array\n     */\n    var initial = function (array) {\n      return array.slice(0, array.length - 1);\n    };\n\n    /**\n     * returns the rest of the items in an array.\n     *\n     * @param {Array} array\n     */\n    var tail = function (array) {\n      return array.slice(1);\n    };\n\n    /**\n     * returns item of array\n     */\n    var find = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        var item = array[idx];\n        if (pred(item)) {\n          return item;\n        }\n      }\n    };\n\n    /**\n     * returns true if all of the values in the array pass the predicate truth test.\n     */\n    var all = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!pred(array[idx])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /**\n     * returns true if the value is present in the list.\n     */\n    var contains = function (array, item) {\n      return $.inArray(item, array) !== -1;\n    };\n\n    /**\n     * get sum from a list\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - iterator\n     */\n    var sum = function (array, fn) {\n      fn = fn || func.self;\n      return array.reduce(function (memo, v) {\n        return memo + fn(v);\n      }, 0);\n    };\n  \n    /**\n     * returns a copy of the collection with array type.\n     * @param {Collection} collection - collection eg) node.childNodes, ...\n     */\n    var from = function (collection) {\n      var result = [], idx = -1, length = collection.length;\n      while (++idx < length) {\n        result[idx] = collection[idx];\n      }\n      return result;\n    };\n  \n    /**\n     * cluster elements by predicate function.\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     * @param {Array[]}\n     */\n    var clusterBy = function (array, fn) {\n      if (!array.length) { return []; }\n      var aTail = tail(array);\n      return aTail.reduce(function (memo, v) {\n        var aLast = last(memo);\n        if (fn(last(aLast), v)) {\n          aLast[aLast.length] = v;\n        } else {\n          memo[memo.length] = [v];\n        }\n        return memo;\n      }, [[head(array)]]);\n    };\n  \n    /**\n     * returns a copy of the array with all falsy values removed\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     */\n    var compact = function (array) {\n      var aResult = [];\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (array[idx]) { aResult.push(array[idx]); }\n      }\n      return aResult;\n    };\n\n    /**\n     * produces a duplicate-free version of the array\n     *\n     * @param {Array} array\n     */\n    var unique = function (array) {\n      var results = [];\n\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!contains(results, array[idx])) {\n          results.push(array[idx]);\n        }\n      }\n\n      return results;\n    };\n\n    /**\n     * returns next item.\n     * @param {Array} array\n     */\n    var next = function (array, item) {\n      var idx = array.indexOf(item);\n      if (idx === -1) { return null; }\n\n      return array[idx + 1];\n    };\n\n    /**\n     * returns prev item.\n     * @param {Array} array\n     */\n    var prev = function (array, item) {\n      var idx = array.indexOf(item);\n      if (idx === -1) { return null; }\n\n      return array[idx - 1];\n    };\n\n  \n    return { head: head, last: last, initial: initial, tail: tail,\n             prev: prev, next: next, find: find, contains: contains,\n             all: all, sum: sum, from: from,\n             clusterBy: clusterBy, compact: compact, unique: unique };\n  })();\n\n\n  var NBSP_CHAR = String.fromCharCode(160);\n  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\n  /**\n   * @class core.dom\n   *\n   * Dom functions\n   *\n   * @singleton\n   * @alternateClassName dom\n   */\n  var dom = (function () {\n    /**\n     * @method isEditable\n     *\n     * returns whether node is `note-editable` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEditable = function (node) {\n      return node && $(node).hasClass('note-editable');\n    };\n\n    /**\n     * @method isControlSizing\n     *\n     * returns whether node is `note-control-sizing` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isControlSizing = function (node) {\n      return node && $(node).hasClass('note-control-sizing');\n    };\n\n    /**\n     * @method  buildLayoutInfo\n     *\n     * build layoutInfo from $editor(.note-editor)\n     *\n     * @param {jQuery} $editor\n     * @return {Object}\n     * @return {Function} return.editor\n     * @return {Node} return.dropzone\n     * @return {Node} return.toolbar\n     * @return {Node} return.editable\n     * @return {Node} return.codable\n     * @return {Node} return.popover\n     * @return {Node} return.handle\n     * @return {Node} return.dialog\n     */\n    var buildLayoutInfo = function ($editor) {\n      var makeFinder;\n\n      // air mode\n      if ($editor.hasClass('note-air-editor')) {\n        var id = list.last($editor.attr('id').split('-'));\n        makeFinder = function (sIdPrefix) {\n          return function () { return $(sIdPrefix + id); };\n        };\n\n        return {\n          editor: function () { return $editor; },\n          holder : function () { return $editor.data('holder'); },\n          editable: function () { return $editor; },\n          popover: makeFinder('#note-popover-'),\n          handle: makeFinder('#note-handle-'),\n          dialog: makeFinder('#note-dialog-')\n        };\n\n        // frame mode\n      } else {\n        makeFinder = function (sClassName) {\n          return function () { return $editor.find(sClassName); };\n        };\n        return {\n          editor: function () { return $editor; },\n          holder : function () { return $editor.data('holder'); },\n          dropzone: makeFinder('.note-dropzone'),\n          toolbar: makeFinder('.note-toolbar'),\n          editable: makeFinder('.note-editable'),\n          codable: makeFinder('.note-codable'),\n          statusbar: makeFinder('.note-statusbar'),\n          popover: makeFinder('.note-popover'),\n          handle: makeFinder('.note-handle'),\n          dialog: makeFinder('.note-dialog')\n        };\n      }\n    };\n\n    /**\n     * returns makeLayoutInfo from editor's descendant node.\n     *\n     * @private\n     * @param {Node} descendant\n     * @return {Object}\n     */\n    var makeLayoutInfo = function (descendant) {\n      var $target = $(descendant).closest('.note-editor, .note-air-editor, .note-air-layout');\n\n      if (!$target.length) {\n        return null;\n      }\n\n      var $editor;\n      if ($target.is('.note-editor, .note-air-editor')) {\n        $editor = $target;\n      } else {\n        $editor = $('#note-editor-' + list.last($target.attr('id').split('-')));\n      }\n\n      return buildLayoutInfo($editor);\n    };\n\n    /**\n     * @method makePredByNodeName\n     *\n     * returns predicate which judge whether nodeName is same\n     *\n     * @param {String} nodeName\n     * @return {Function}\n     */\n    var makePredByNodeName = function (nodeName) {\n      nodeName = nodeName.toUpperCase();\n      return function (node) {\n        return node && node.nodeName.toUpperCase() === nodeName;\n      };\n    };\n\n    /**\n     * @method isText\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is text(3)\n     */\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n\n    /**\n     * ex) br, col, embed, hr, img, input, ...\n     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var isVoid = function (node) {\n      return node && /^BR|^IMG|^HR/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPara = function (node) {\n      if (isEditable(node)) {\n        return false;\n      }\n\n      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isLi = makePredByNodeName('LI');\n\n    var isPurePara = function (node) {\n      return isPara(node) && !isLi(node);\n    };\n\n    var isTable = makePredByNodeName('TABLE');\n\n    var isInline = function (node) {\n      return !isBodyContainer(node) &&\n             !isList(node) &&\n             !isPara(node) &&\n             !isTable(node) &&\n             !isBlockquote(node);\n    };\n\n    var isList = function (node) {\n      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n    };\n\n    var isCell = function (node) {\n      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n    };\n\n    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\n    var isBodyContainer = function (node) {\n      return isCell(node) || isBlockquote(node) || isEditable(node);\n    };\n\n    var isAnchor = makePredByNodeName('A');\n\n    var isParaInline = function (node) {\n      return isInline(node) && !!ancestor(node, isPara);\n    };\n\n    var isBodyInline = function (node) {\n      return isInline(node) && !ancestor(node, isPara);\n    };\n\n    var isBody = makePredByNodeName('BODY');\n\n    /**\n     * returns whether nodeB is closest sibling of nodeA\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     * @return {Boolean}\n     */\n    var isClosestSibling = function (nodeA, nodeB) {\n      return nodeA.nextSibling === nodeB ||\n             nodeA.previousSibling === nodeB;\n    };\n\n    /**\n     * returns array of closest siblings with node\n     *\n     * @param {Node} node\n     * @param {function} [pred] - predicate function\n     * @return {Node[]}\n     */\n    var withClosestSiblings = function (node, pred) {\n      pred = pred || func.ok;\n\n      var siblings = [];\n      if (node.previousSibling && pred(node.previousSibling)) {\n        siblings.push(node.previousSibling);\n      }\n      siblings.push(node);\n      if (node.nextSibling && pred(node.nextSibling)) {\n        siblings.push(node.nextSibling);\n      }\n      return siblings;\n    };\n\n    /**\n     * blank HTML for cursor position\n     * - [workaround] for MSIE IE doesn't works with bogus br\n     */\n    var blankHTML = agent.isMSIE ? '&nbsp;' : '<br>';\n\n    /**\n     * @method nodeLength\n     *\n     * returns #text's text size or element's childNodes size\n     *\n     * @param {Node} node\n     */\n    var nodeLength = function (node) {\n      if (isText(node)) {\n        return node.nodeValue.length;\n      }\n\n      return node.childNodes.length;\n    };\n\n    /**\n     * returns whether node is empty or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEmpty = function (node) {\n      var len = nodeLength(node);\n\n      if (len === 0) {\n        return true;\n      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n        // ex) <p><br></p>, <span><br></span>\n        return true;\n      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n        // ex) <p></p>, <span></span>\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * padding blankHTML if node is empty (for cursor position)\n     */\n    var paddingBlankHTML = function (node) {\n      if (!isVoid(node) && !nodeLength(node)) {\n        node.innerHTML = blankHTML;\n      }\n    };\n\n    /**\n     * find nearest ancestor predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var ancestor = function (node, pred) {\n      while (node) {\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * find nearest ancestor only single child blood line and predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var singleChildAncestor = function (node, pred) {\n      node = node.parentNode;\n\n      while (node) {\n        if (nodeLength(node) !== 1) { break; }\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * returns new array of ancestor nodes (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listAncestor = function (node, pred) {\n      pred = pred || func.fail;\n\n      var ancestors = [];\n      ancestor(node, function (el) {\n        if (!isEditable(el)) {\n          ancestors.push(el);\n        }\n\n        return pred(el);\n      });\n      return ancestors;\n    };\n\n    /**\n     * find farthest ancestor predicate hit\n     */\n    var lastAncestor = function (node, pred) {\n      var ancestors = listAncestor(node);\n      return list.last(ancestors.filter(pred));\n    };\n\n    /**\n     * returns common ancestor node between two nodes.\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n    var commonAncestor = function (nodeA, nodeB) {\n      var ancestors = listAncestor(nodeA);\n      for (var n = nodeB; n; n = n.parentNode) {\n        if ($.inArray(n, ancestors) > -1) { return n; }\n      }\n      return null; // difference document area\n    };\n\n    /**\n     * listing all previous siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listPrev = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.previousSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing next siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listNext = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.nextSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing descendant nodes\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listDescendant = function (node, pred) {\n      var descendents = [];\n      pred = pred || func.ok;\n\n      // start DFS(depth first search) with node\n      (function fnWalk(current) {\n        if (node !== current && pred(current)) {\n          descendents.push(current);\n        }\n        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n          fnWalk(current.childNodes[idx]);\n        }\n      })(node);\n\n      return descendents;\n    };\n\n    /**\n     * wrap node with new tag.\n     *\n     * @param {Node} node\n     * @param {Node} tagName of wrapper\n     * @return {Node} - wrapper\n     */\n    var wrap = function (node, wrapperName) {\n      var parent = node.parentNode;\n      var wrapper = $('<' + wrapperName + '>')[0];\n\n      parent.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n\n      return wrapper;\n    };\n\n    /**\n     * insert node after preceding\n     *\n     * @param {Node} node\n     * @param {Node} preceding - predicate function\n     */\n    var insertAfter = function (node, preceding) {\n      var next = preceding.nextSibling, parent = preceding.parentNode;\n      if (next) {\n        parent.insertBefore(node, next);\n      } else {\n        parent.appendChild(node);\n      }\n      return node;\n    };\n\n    /**\n     * append elements.\n     *\n     * @param {Node} node\n     * @param {Collection} aChild\n     */\n    var appendChildNodes = function (node, aChild) {\n      $.each(aChild, function (idx, child) {\n        node.appendChild(child);\n      });\n      return node;\n    };\n\n    /**\n     * returns whether boundaryPoint is left edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isLeftEdgePoint = function (point) {\n      return point.offset === 0;\n    };\n\n    /**\n     * returns whether boundaryPoint is right edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isRightEdgePoint = function (point) {\n      return point.offset === nodeLength(point.node);\n    };\n\n    /**\n     * returns whether boundaryPoint is edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isEdgePoint = function (point) {\n      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n    };\n\n    /**\n     * returns wheter node is left edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== 0) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether node is right edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== nodeLength(node.parentNode) - 1) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns offset from parent.\n     *\n     * @param {Node} node\n     */\n    var position = function (node) {\n      var offset = 0;\n      while ((node = node.previousSibling)) {\n        offset += 1;\n      }\n      return offset;\n    };\n\n    var hasChildren = function (node) {\n      return !!(node && node.childNodes && node.childNodes.length);\n    };\n\n    /**\n     * returns previous boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var prevPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (point.offset === 0) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node);\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset - 1];\n        offset = nodeLength(node);\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns next boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var nextPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (nodeLength(point.node) === point.offset) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node) + 1;\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset];\n        offset = 0;\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns whether pointA and pointB is same or not.\n     *\n     * @param {BoundaryPoint} pointA\n     * @param {BoundaryPoint} pointB\n     * @return {Boolean}\n     */\n    var isSamePoint = function (pointA, pointB) {\n      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n    };\n\n    /**\n     * returns whether point is visible (can set cursor) or not.\n     * \n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isVisiblePoint = function (point) {\n      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n        return true;\n      }\n\n      var leftNode = point.node.childNodes[point.offset - 1];\n      var rightNode = point.node.childNodes[point.offset];\n      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @method prevPointUtil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var prevPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = prevPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * @method nextPointUntil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var nextPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = nextPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * returns whether point has character or not.\n     *\n     * @param {Point} point\n     * @return {Boolean}\n     */\n    var isCharPoint = function (point) {\n      if (!isText(point.node)) {\n        return false;\n      }\n\n      var ch = point.node.nodeValue.charAt(point.offset - 1);\n      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n    };\n\n    /**\n     * @method walkPoint\n     *\n     * @param {BoundaryPoint} startPoint\n     * @param {BoundaryPoint} endPoint\n     * @param {Function} handler\n     * @param {Boolean} isSkipInnerOffset\n     */\n    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n      var point = startPoint;\n\n      while (point) {\n        handler(point);\n\n        if (isSamePoint(point, endPoint)) {\n          break;\n        }\n\n        var isSkipOffset = isSkipInnerOffset &&\n                           startPoint.node !== point.node &&\n                           endPoint.node !== point.node;\n        point = nextPoint(point, isSkipOffset);\n      }\n    };\n\n    /**\n     * @method makeOffsetPath\n     *\n     * return offsetPath(array of offset) from ancestor\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {Node} node\n     */\n    var makeOffsetPath = function (ancestor, node) {\n      var ancestors = listAncestor(node, func.eq(ancestor));\n      return $.map(ancestors, position).reverse();\n    };\n\n    /**\n     * @method fromOffsetPath\n     *\n     * return element from offsetPath(array of offset)\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {array} offsets - offsetPath\n     */\n    var fromOffsetPath = function (ancestor, offsets) {\n      var current = ancestor;\n      for (var i = 0, len = offsets.length; i < len; i++) {\n        if (current.childNodes.length <= offsets[i]) {\n          current = current.childNodes[current.childNodes.length - 1];\n        } else {\n          current = current.childNodes[offsets[i]];\n        }\n      }\n      return current;\n    };\n\n    /**\n     * @method splitNode\n     *\n     * split element or #text\n     *\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitNode = function (point, options) {\n      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\n      // edge case\n      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n        if (isLeftEdgePoint(point)) {\n          return point.node;\n        } else if (isRightEdgePoint(point)) {\n          return point.node.nextSibling;\n        }\n      }\n\n      // split #text\n      if (isText(point.node)) {\n        return point.node.splitText(point.offset);\n      } else {\n        var childNode = point.node.childNodes[point.offset];\n        var clone = insertAfter(point.node.cloneNode(false), point.node);\n        appendChildNodes(clone, listNext(childNode));\n\n        if (!isSkipPaddingBlankHTML) {\n          paddingBlankHTML(point.node);\n          paddingBlankHTML(clone);\n        }\n\n        return clone;\n      }\n    };\n\n    /**\n     * @method splitTree\n     *\n     * split tree by point\n     *\n     * @param {Node} root - split root\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitTree = function (root, point, options) {\n      // ex) [#text, <span>, <p>]\n      var ancestors = listAncestor(point.node, func.eq(root));\n\n      if (!ancestors.length) {\n        return null;\n      } else if (ancestors.length === 1) {\n        return splitNode(point, options);\n      }\n\n      return ancestors.reduce(function (node, parent) {\n        if (node === point.node) {\n          node = splitNode(point, options);\n        }\n\n        return splitNode({\n          node: parent,\n          offset: node ? dom.position(node) : nodeLength(parent)\n        }, options);\n      });\n    };\n\n    /**\n     * split point\n     *\n     * @param {Point} point\n     * @param {Boolean} isInline\n     * @return {Object}\n     */\n    var splitPoint = function (point, isInline) {\n      // find splitRoot, container\n      //  - inline: splitRoot is a child of paragraph\n      //  - block: splitRoot is a child of bodyContainer\n      var pred = isInline ? isPara : isBodyContainer;\n      var ancestors = listAncestor(point.node, pred);\n      var topAncestor = list.last(ancestors) || point.node;\n\n      var splitRoot, container;\n      if (pred(topAncestor)) {\n        splitRoot = ancestors[ancestors.length - 2];\n        container = topAncestor;\n      } else {\n        splitRoot = topAncestor;\n        container = splitRoot.parentNode;\n      }\n\n      // if splitRoot is exists, split with splitTree\n      var pivot = splitRoot && splitTree(splitRoot, point, {\n        isSkipPaddingBlankHTML: isInline,\n        isNotSplitEdgePoint: isInline\n      });\n\n      // if container is point.node, find pivot with point.offset\n      if (!pivot && container === point.node) {\n        pivot = point.node.childNodes[point.offset];\n      }\n\n      return {\n        rightNode: pivot,\n        container: container\n      };\n    };\n\n    var create = function (nodeName) {\n      return document.createElement(nodeName);\n    };\n\n    var createText = function (text) {\n      return document.createTextNode(text);\n    };\n\n    /**\n     * @method remove\n     *\n     * remove node, (isRemoveChild: remove child or not)\n     *\n     * @param {Node} node\n     * @param {Boolean} isRemoveChild\n     */\n    var remove = function (node, isRemoveChild) {\n      if (!node || !node.parentNode) { return; }\n      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\n      var parent = node.parentNode;\n      if (!isRemoveChild) {\n        var nodes = [];\n        var i, len;\n        for (i = 0, len = node.childNodes.length; i < len; i++) {\n          nodes.push(node.childNodes[i]);\n        }\n\n        for (i = 0, len = nodes.length; i < len; i++) {\n          parent.insertBefore(nodes[i], node);\n        }\n      }\n\n      parent.removeChild(node);\n    };\n\n    /**\n     * @method removeWhile\n     *\n     * @param {Node} node\n     * @param {Function} pred\n     */\n    var removeWhile = function (node, pred) {\n      while (node) {\n        if (isEditable(node) || !pred(node)) {\n          break;\n        }\n\n        var parent = node.parentNode;\n        remove(node);\n        node = parent;\n      }\n    };\n\n    /**\n     * @method replace\n     *\n     * replace node with provided nodeName\n     *\n     * @param {Node} node\n     * @param {String} nodeName\n     * @return {Node} - new node\n     */\n    var replace = function (node, nodeName) {\n      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n        return node;\n      }\n\n      var newNode = create(nodeName);\n\n      if (node.style.cssText) {\n        newNode.style.cssText = node.style.cssText;\n      }\n\n      appendChildNodes(newNode, list.from(node.childNodes));\n      insertAfter(newNode, node);\n      remove(node);\n\n      return newNode;\n    };\n\n    var isTextarea = makePredByNodeName('TEXTAREA');\n\n    /**\n     * @param {jQuery} $node\n     * @param {Boolean} [stripLinebreaks] - default: false\n     */\n    var value = function ($node, stripLinebreaks) {\n      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n      if (stripLinebreaks) {\n        return val.replace(/[\\n\\r]/g, '');\n      }\n      return val;\n    };\n\n    /**\n     * @method html\n     *\n     * get the HTML contents of node\n     *\n     * @param {jQuery} $node\n     * @param {Boolean} [isNewlineOnBlock]\n     */\n    var html = function ($node, isNewlineOnBlock) {\n      var markup = value($node);\n\n      if (isNewlineOnBlock) {\n        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n        markup = markup.replace(regexTag, function (match, endSlash, name) {\n          name = name.toUpperCase();\n          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n                                       !!endSlash;\n          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\n          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n        });\n        markup = $.trim(markup);\n      }\n\n      return markup;\n    };\n\n    return {\n      /** @property {String} NBSP_CHAR */\n      NBSP_CHAR: NBSP_CHAR,\n      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n      /** @property {String} blank */\n      blank: blankHTML,\n      /** @property {String} emptyPara */\n      emptyPara: '<p>' + blankHTML + '</p>',\n      makePredByNodeName: makePredByNodeName,\n      isEditable: isEditable,\n      isControlSizing: isControlSizing,\n      buildLayoutInfo: buildLayoutInfo,\n      makeLayoutInfo: makeLayoutInfo,\n      isText: isText,\n      isVoid: isVoid,\n      isPara: isPara,\n      isPurePara: isPurePara,\n      isInline: isInline,\n      isBlock: func.not(isInline),\n      isBodyInline: isBodyInline,\n      isBody: isBody,\n      isParaInline: isParaInline,\n      isList: isList,\n      isTable: isTable,\n      isCell: isCell,\n      isBlockquote: isBlockquote,\n      isBodyContainer: isBodyContainer,\n      isAnchor: isAnchor,\n      isDiv: makePredByNodeName('DIV'),\n      isLi: isLi,\n      isBR: makePredByNodeName('BR'),\n      isSpan: makePredByNodeName('SPAN'),\n      isB: makePredByNodeName('B'),\n      isU: makePredByNodeName('U'),\n      isS: makePredByNodeName('S'),\n      isI: makePredByNodeName('I'),\n      isImg: makePredByNodeName('IMG'),\n      isTextarea: isTextarea,\n      isEmpty: isEmpty,\n      isEmptyAnchor: func.and(isAnchor, isEmpty),\n      isClosestSibling: isClosestSibling,\n      withClosestSiblings: withClosestSiblings,\n      nodeLength: nodeLength,\n      isLeftEdgePoint: isLeftEdgePoint,\n      isRightEdgePoint: isRightEdgePoint,\n      isEdgePoint: isEdgePoint,\n      isLeftEdgeOf: isLeftEdgeOf,\n      isRightEdgeOf: isRightEdgeOf,\n      prevPoint: prevPoint,\n      nextPoint: nextPoint,\n      isSamePoint: isSamePoint,\n      isVisiblePoint: isVisiblePoint,\n      prevPointUntil: prevPointUntil,\n      nextPointUntil: nextPointUntil,\n      isCharPoint: isCharPoint,\n      walkPoint: walkPoint,\n      ancestor: ancestor,\n      singleChildAncestor: singleChildAncestor,\n      listAncestor: listAncestor,\n      lastAncestor: lastAncestor,\n      listNext: listNext,\n      listPrev: listPrev,\n      listDescendant: listDescendant,\n      commonAncestor: commonAncestor,\n      wrap: wrap,\n      insertAfter: insertAfter,\n      appendChildNodes: appendChildNodes,\n      position: position,\n      hasChildren: hasChildren,\n      makeOffsetPath: makeOffsetPath,\n      fromOffsetPath: fromOffsetPath,\n      splitTree: splitTree,\n      splitPoint: splitPoint,\n      create: create,\n      createText: createText,\n      remove: remove,\n      removeWhile: removeWhile,\n      replace: replace,\n      html: html,\n      value: value\n    };\n  })();\n\n\n  var range = (function () {\n\n    /**\n     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n     *\n     * @param {TextRange} textRange\n     * @param {Boolean} isStart\n     * @return {BoundaryPoint}\n     *\n     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n     */\n    var textRangeToPoint = function (textRange, isStart) {\n      var container = textRange.parentElement(), offset;\n  \n      var tester = document.body.createTextRange(), prevContainer;\n      var childNodes = list.from(container.childNodes);\n      for (offset = 0; offset < childNodes.length; offset++) {\n        if (dom.isText(childNodes[offset])) {\n          continue;\n        }\n        tester.moveToElementText(childNodes[offset]);\n        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n          break;\n        }\n        prevContainer = childNodes[offset];\n      }\n  \n      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n        textRangeStart.moveToElementText(prevContainer || container);\n        textRangeStart.collapse(!prevContainer);\n        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n  \n        var pointTester = textRange.duplicate();\n        pointTester.setEndPoint('StartToStart', textRangeStart);\n        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n  \n        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        /* jshint ignore:start */\n        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n        /* jshint ignore:end */\n  \n        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n            textCount === curTextNode.nodeValue.length) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        container = curTextNode;\n        offset = textCount;\n      }\n  \n      return {\n        cont: container,\n        offset: offset\n      };\n    };\n    \n    /**\n     * return TextRange from boundary point (inspired by google closure-library)\n     * @param {BoundaryPoint} point\n     * @return {TextRange}\n     */\n    var pointToTextRange = function (point) {\n      var textRangeInfo = function (container, offset) {\n        var node, isCollapseToStart;\n  \n        if (dom.isText(container)) {\n          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n          var prevContainer = list.last(prevTextNodes).previousSibling;\n          node =  prevContainer || container.parentNode;\n          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n          isCollapseToStart = !prevContainer;\n        } else {\n          node = container.childNodes[offset] || container;\n          if (dom.isText(node)) {\n            return textRangeInfo(node, 0);\n          }\n  \n          offset = 0;\n          isCollapseToStart = false;\n        }\n  \n        return {\n          node: node,\n          collapseToStart: isCollapseToStart,\n          offset: offset\n        };\n      };\n  \n      var textRange = document.body.createTextRange();\n      var info = textRangeInfo(point.node, point.offset);\n  \n      textRange.moveToElementText(info.node);\n      textRange.collapse(info.collapseToStart);\n      textRange.moveStart('character', info.offset);\n      return textRange;\n    };\n    \n    /**\n     * Wrapped Range\n     *\n     * @constructor\n     * @param {Node} sc - start container\n     * @param {Number} so - start offset\n     * @param {Node} ec - end container\n     * @param {Number} eo - end offset\n     */\n    var WrappedRange = function (sc, so, ec, eo) {\n      this.sc = sc;\n      this.so = so;\n      this.ec = ec;\n      this.eo = eo;\n  \n      // nativeRange: get nativeRange from sc, so, ec, eo\n      var nativeRange = function () {\n        if (agent.isW3CRangeSupport) {\n          var w3cRange = document.createRange();\n          w3cRange.setStart(sc, so);\n          w3cRange.setEnd(ec, eo);\n\n          return w3cRange;\n        } else {\n          var textRange = pointToTextRange({\n            node: sc,\n            offset: so\n          });\n\n          textRange.setEndPoint('EndToEnd', pointToTextRange({\n            node: ec,\n            offset: eo\n          }));\n\n          return textRange;\n        }\n      };\n\n      this.getPoints = function () {\n        return {\n          sc: sc,\n          so: so,\n          ec: ec,\n          eo: eo\n        };\n      };\n\n      this.getStartPoint = function () {\n        return {\n          node: sc,\n          offset: so\n        };\n      };\n\n      this.getEndPoint = function () {\n        return {\n          node: ec,\n          offset: eo\n        };\n      };\n\n      /**\n       * select update visible range\n       */\n      this.select = function () {\n        var nativeRng = nativeRange();\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (selection.rangeCount > 0) {\n            selection.removeAllRanges();\n          }\n          selection.addRange(nativeRng);\n        } else {\n          nativeRng.select();\n        }\n        \n        return this;\n      };\n\n      /**\n       * @return {WrappedRange}\n       */\n      this.normalize = function () {\n\n        /**\n         * @param {BoundaryPoint} point\n         * @return {BoundaryPoint}\n         */\n        var getVisiblePoint = function (point) {\n          if (!dom.isVisiblePoint(point)) {\n            if (dom.isLeftEdgePoint(point)) {\n              point = dom.nextPointUntil(point, dom.isVisiblePoint);\n            } else {\n              point = dom.prevPointUntil(point, dom.isVisiblePoint);\n            }\n          }\n          return point;\n        };\n\n        var startPoint = getVisiblePoint(this.getStartPoint());\n        var endPoint = getVisiblePoint(this.getEndPoint());\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n\n      /**\n       * returns matched nodes on range\n       *\n       * @param {Function} [pred] - predicate function\n       * @param {Object} [options]\n       * @param {Boolean} [options.includeAncestor]\n       * @param {Boolean} [options.fullyContains]\n       * @return {Node[]}\n       */\n      this.nodes = function (pred, options) {\n        pred = pred || func.ok;\n\n        var includeAncestor = options && options.includeAncestor;\n        var fullyContains = options && options.fullyContains;\n\n        // TODO compare points and sort\n        var startPoint = this.getStartPoint();\n        var endPoint = this.getEndPoint();\n\n        var nodes = [];\n        var leftEdgeNodes = [];\n\n        dom.walkPoint(startPoint, endPoint, function (point) {\n          if (dom.isEditable(point.node)) {\n            return;\n          }\n\n          var node;\n          if (fullyContains) {\n            if (dom.isLeftEdgePoint(point)) {\n              leftEdgeNodes.push(point.node);\n            }\n            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n              node = point.node;\n            }\n          } else if (includeAncestor) {\n            node = dom.ancestor(point.node, pred);\n          } else {\n            node = point.node;\n          }\n\n          if (node && pred(node)) {\n            nodes.push(node);\n          }\n        }, true);\n\n        return list.unique(nodes);\n      };\n\n      /**\n       * returns commonAncestor of range\n       * @return {Element} - commonAncestor\n       */\n      this.commonAncestor = function () {\n        return dom.commonAncestor(sc, ec);\n      };\n\n      /**\n       * returns expanded range by pred\n       *\n       * @param {Function} pred - predicate function\n       * @return {WrappedRange}\n       */\n      this.expand = function (pred) {\n        var startAncestor = dom.ancestor(sc, pred);\n        var endAncestor = dom.ancestor(ec, pred);\n\n        if (!startAncestor && !endAncestor) {\n          return new WrappedRange(sc, so, ec, eo);\n        }\n\n        var boundaryPoints = this.getPoints();\n\n        if (startAncestor) {\n          boundaryPoints.sc = startAncestor;\n          boundaryPoints.so = 0;\n        }\n\n        if (endAncestor) {\n          boundaryPoints.ec = endAncestor;\n          boundaryPoints.eo = dom.nodeLength(endAncestor);\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * @param {Boolean} isCollapseToStart\n       * @return {WrappedRange}\n       */\n      this.collapse = function (isCollapseToStart) {\n        if (isCollapseToStart) {\n          return new WrappedRange(sc, so, sc, so);\n        } else {\n          return new WrappedRange(ec, eo, ec, eo);\n        }\n      };\n\n      /**\n       * splitText on range\n       */\n      this.splitText = function () {\n        var isSameContainer = sc === ec;\n        var boundaryPoints = this.getPoints();\n\n        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n          ec.splitText(eo);\n        }\n\n        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n          boundaryPoints.sc = sc.splitText(so);\n          boundaryPoints.so = 0;\n\n          if (isSameContainer) {\n            boundaryPoints.ec = boundaryPoints.sc;\n            boundaryPoints.eo = eo - so;\n          }\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * delete contents on range\n       * @return {WrappedRange}\n       */\n      this.deleteContents = function () {\n        if (this.isCollapsed()) {\n          return this;\n        }\n\n        var rng = this.splitText();\n        var nodes = rng.nodes(null, {\n          fullyContains: true\n        });\n\n        // find new cursor point\n        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n          return !list.contains(nodes, point.node);\n        });\n\n        var emptyParents = [];\n        $.each(nodes, function (idx, node) {\n          // find empty parents\n          var parent = node.parentNode;\n          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n            emptyParents.push(parent);\n          }\n          dom.remove(node, false);\n        });\n\n        // remove empty parents\n        $.each(emptyParents, function (idx, node) {\n          dom.remove(node, false);\n        });\n\n        return new WrappedRange(\n          point.node,\n          point.offset,\n          point.node,\n          point.offset\n        ).normalize();\n      };\n      \n      /**\n       * makeIsOn: return isOn(pred) function\n       */\n      var makeIsOn = function (pred) {\n        return function () {\n          var ancestor = dom.ancestor(sc, pred);\n          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n        };\n      };\n  \n      // isOnEditable: judge whether range is on editable or not\n      this.isOnEditable = makeIsOn(dom.isEditable);\n      // isOnList: judge whether range is on list node or not\n      this.isOnList = makeIsOn(dom.isList);\n      // isOnAnchor: judge whether range is on anchor node or not\n      this.isOnAnchor = makeIsOn(dom.isAnchor);\n      // isOnAnchor: judge whether range is on cell node or not\n      this.isOnCell = makeIsOn(dom.isCell);\n\n      /**\n       * @param {Function} pred\n       * @return {Boolean}\n       */\n      this.isLeftEdgeOf = function (pred) {\n        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n          return false;\n        }\n\n        var node = dom.ancestor(this.sc, pred);\n        return node && dom.isLeftEdgeOf(this.sc, node);\n      };\n\n      /**\n       * returns whether range was collapsed or not\n       */\n      this.isCollapsed = function () {\n        return sc === ec && so === eo;\n      };\n\n      /**\n       * wrap inline nodes which children of body with paragraph\n       *\n       * @return {WrappedRange}\n       */\n      this.wrapBodyInlineWithPara = function () {\n        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n          sc.innerHTML = dom.emptyPara;\n          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n        }\n\n        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n          return this.normalize();\n        }\n\n        // find inline top ancestor\n        var topAncestor;\n        if (dom.isInline(sc)) {\n          var ancestors = dom.listAncestor(sc, func.not(dom.isInline));\n          topAncestor = list.last(ancestors);\n          if (!dom.isInline(topAncestor)) {\n            topAncestor = ancestors[ancestors.length - 2] || sc.childNodes[so];\n          }\n        } else {\n          topAncestor = sc.childNodes[so > 0 ? so - 1 : 0];\n        }\n\n        // siblings not in paragraph\n        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\n        // wrap with paragraph\n        if (inlineSiblings.length) {\n          var para = dom.wrap(list.head(inlineSiblings), 'p');\n          dom.appendChildNodes(para, list.tail(inlineSiblings));\n        }\n\n        return this.normalize();\n      };\n\n      /**\n       * insert node at current cursor\n       *\n       * @param {Node} node\n       * @return {Node}\n       */\n      this.insertNode = function (node) {\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\n        if (info.rightNode) {\n          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n        } else {\n          info.container.appendChild(node);\n        }\n\n        return node;\n      };\n\n      /**\n       * insert html at current cursor\n       */\n      this.pasteHTML = function (markup) {\n        var self = this;\n        var contentsContainer = $('<div></div>').html(markup)[0];\n        var childNodes = list.from(contentsContainer.childNodes);\n\n        this.wrapBodyInlineWithPara().deleteContents();\n\n        return $.map(childNodes.reverse(), function (childNode) {\n          return self.insertNode(childNode);\n        }).reverse();\n      };\n  \n      /**\n       * returns text in range\n       *\n       * @return {String}\n       */\n      this.toString = function () {\n        var nativeRng = nativeRange();\n        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n      };\n\n      /**\n       * returns range for word before cursor\n       *\n       * @param {Boolean} [findAfter] - find after cursor, default: false\n       * @return {WrappedRange}\n       */\n      this.getWordRange = function (findAfter) {\n        var endPoint = this.getEndPoint();\n\n        if (!dom.isCharPoint(endPoint)) {\n          return this;\n        }\n\n        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n          return !dom.isCharPoint(point);\n        });\n\n        if (findAfter) {\n          endPoint = dom.nextPointUntil(endPoint, function (point) {\n            return !dom.isCharPoint(point);\n          });\n        }\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n  \n      /**\n       * create offsetPath bookmark\n       *\n       * @param {Node} editable\n       */\n      this.bookmark = function (editable) {\n        return {\n          s: {\n            path: dom.makeOffsetPath(editable, sc),\n            offset: so\n          },\n          e: {\n            path: dom.makeOffsetPath(editable, ec),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * create offsetPath bookmark base on paragraph\n       *\n       * @param {Node[]} paras\n       */\n      this.paraBookmark = function (paras) {\n        return {\n          s: {\n            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n            offset: so\n          },\n          e: {\n            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * getClientRects\n       * @return {Rect[]}\n       */\n      this.getClientRects = function () {\n        var nativeRng = nativeRange();\n        return nativeRng.getClientRects();\n      };\n    };\n\n  /**\n   * @class core.range\n   *\n   * Data structure\n   *  * BoundaryPoint: a point of dom tree\n   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n   *\n   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n   *\n   * @singleton\n   * @alternateClassName range\n   */\n    return {\n      /**\n       * @method\n       * \n       * create Range Object From arguments or Browser Selection\n       *\n       * @param {Node} sc - start container\n       * @param {Number} so - start offset\n       * @param {Node} ec - end container\n       * @param {Number} eo - end offset\n       * @return {WrappedRange}\n       */\n      create : function (sc, so, ec, eo) {\n        if (!arguments.length) { // from Browser Selection\n          if (agent.isW3CRangeSupport) {\n            var selection = document.getSelection();\n            if (!selection || selection.rangeCount === 0) {\n              return null;\n            } else if (dom.isBody(selection.anchorNode)) {\n              // Firefox: returns entire body as range on initialization. We won't never need it.\n              return null;\n            }\n  \n            var nativeRng = selection.getRangeAt(0);\n            sc = nativeRng.startContainer;\n            so = nativeRng.startOffset;\n            ec = nativeRng.endContainer;\n            eo = nativeRng.endOffset;\n          } else { // IE8: TextRange\n            var textRange = document.selection.createRange();\n            var textRangeEnd = textRange.duplicate();\n            textRangeEnd.collapse(false);\n            var textRangeStart = textRange;\n            textRangeStart.collapse(true);\n  \n            var startPoint = textRangeToPoint(textRangeStart, true),\n            endPoint = textRangeToPoint(textRangeEnd, false);\n\n            // same visible point case: range was collapsed.\n            if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n                dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n                endPoint.node.nextSibling === startPoint.node) {\n              startPoint = endPoint;\n            }\n\n            sc = startPoint.cont;\n            so = startPoint.offset;\n            ec = endPoint.cont;\n            eo = endPoint.offset;\n          }\n        } else if (arguments.length === 2) { //collapsed\n          ec = sc;\n          eo = so;\n        }\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from node\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNode: function (node) {\n        var sc = node;\n        var so = 0;\n        var ec = node;\n        var eo = dom.nodeLength(ec);\n\n        // browsers can't target a picture or void node\n        if (dom.isVoid(sc)) {\n          so = dom.listPrev(sc).length - 1;\n          sc = sc.parentNode;\n        }\n        if (dom.isBR(ec)) {\n          eo = dom.listPrev(ec).length - 1;\n          ec = ec.parentNode;\n        } else if (dom.isVoid(ec)) {\n          eo = dom.listPrev(ec).length;\n          ec = ec.parentNode;\n        }\n\n        return this.create(sc, so, ec, eo);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeBefore: function (node) {\n        return this.createFromNode(node).collapse(true);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeAfter: function (node) {\n        return this.createFromNode(node).collapse();\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from bookmark\n       *\n       * @param {Node} editable\n       * @param {Object} bookmark\n       * @return {WrappedRange}\n       */\n      createFromBookmark : function (editable, bookmark) {\n        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n        var so = bookmark.s.offset;\n        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n        var eo = bookmark.e.offset;\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       *\n       * create WrappedRange from paraBookmark\n       *\n       * @param {Object} bookmark\n       * @param {Node[]} paras\n       * @return {WrappedRange}\n       */\n      createFromParaBookmark: function (bookmark, paras) {\n        var so = bookmark.s.offset;\n        var eo = bookmark.e.offset;\n        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\n        return new WrappedRange(sc, so, ec, eo);\n      }\n    };\n  })();\n\n  /**\n   * @class defaults \n   * \n   * @singleton\n   */\n  var defaults = {\n    /** @property */\n    version: '0.6.7',\n\n    /**\n     * \n     * for event options, reference to EventHandler.attach\n     * \n     * @property {Object} options \n     * @property {String/Number} [options.width=null] set editor width \n     * @property {String/Number} [options.height=null] set editor height, ex) 300\n     * @property {String/Number} options.minHeight set minimum height of editor\n     * @property {String/Number} options.maxHeight\n     * @property {String/Number} options.focus \n     * @property {Number} options.tabsize \n     * @property {Boolean} options.styleWithSpan\n     * @property {Object} options.codemirror\n     * @property {Object} [options.codemirror.mode='text/html']\n     * @property {Object} [options.codemirror.htmlMode=true]\n     * @property {Object} [options.codemirror.lineNumbers=true]\n     * @property {String} [options.lang=en-US] language 'en-US', 'ko-KR', ...\n     * @property {String} [options.direction=null] text direction, ex) 'rtl'\n     * @property {Array} [options.toolbar]\n     * @property {Boolean} [options.airMode=false]\n     * @property {Array} [options.airPopover]\n     * @property {Fucntion} [options.onInit] initialize\n     * @property {Fucntion} [options.onsubmit]\n     */\n    options: {\n      width: null,                  // set editor width\n      height: null,                 // set editor height, ex) 300\n\n      minHeight: null,              // set minimum height of editor\n      maxHeight: null,              // set maximum height of editor\n\n      focus: false,                 // set focus to editable area after initializing summernote\n\n      tabsize: 4,                   // size of tab ex) 2 or 4\n      styleWithSpan: true,          // style with span (Chrome and FF only)\n\n      disableLinkTarget: false,     // hide link Target Checkbox\n      disableDragAndDrop: false,    // disable drag and drop event\n      disableResizeEditor: false,   // disable resizing editor\n\n      shortcuts: true,              // enable keyboard shortcuts\n\n      placeholder: false,           // enable placeholder text\n      prettifyHtml: true,           // enable prettifying html while toggling codeview\n\n      iconPrefix: 'fa fa-',         // prefix for css icon classes\n\n      codemirror: {                 // codemirror options\n        mode: 'text/html',\n        htmlMode: true,\n        lineNumbers: true\n      },\n\n      // language\n      lang: 'en-US',                // language 'en-US', 'ko-KR', ...\n      direction: null,              // text direction, ex) 'rtl'\n\n      // toolbar\n      toolbar: [\n        ['style', ['style']],\n        ['font', ['bold', 'italic', 'underline', 'clear']],\n        // ['font', ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript', 'clear']],\n        ['fontname', ['fontname']],\n        ['fontsize', ['fontsize']],\n        ['color', ['color']],\n        ['para', ['ul', 'ol', 'paragraph']],\n        ['height', ['height']],\n        ['table', ['table']],\n        ['insert', ['link', 'hr']],\n        ['view', ['fullscreen', 'codeview']],\n        ['help', ['help']]\n      ],\n\n      plugin : { },\n\n      // air mode: inline editor\n      airMode: false,\n      // airPopover: [\n      //   ['style', ['style']],\n      //   ['font', ['bold', 'italic', 'underline', 'clear']],\n      //   ['fontname', ['fontname']],\n      //   ['color', ['color']],\n      //   ['para', ['ul', 'ol', 'paragraph']],\n      //   ['height', ['height']],\n      //   ['table', ['table']],\n      //   ['insert', ['link', 'picture']],\n      //   ['help', ['help']]\n      // ],\n      airPopover: [\n        ['color', ['color']],\n        ['font', ['bold', 'underline', 'clear']],\n        ['para', ['ul', 'paragraph']],\n        ['table', ['table']],\n        ['insert', ['link', 'picture']]\n      ],\n\n      // style tag\n      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n      // default fontName\n      defaultFontName: 'Open Sans',\n\n      // fontName\n      fontNames: [\n        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n        'Tahoma', 'Times New Roman', 'Verdana', 'Open Sans'\n      ],\n      fontNamesIgnoreCheck: [],\n\n      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\n      // pallete colors(n x n)\n      colors: [\n        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n      ],\n\n      // lineHeight\n      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\n      // insertTable max size\n      insertTableMaxSize: {\n        col: 10,\n        row: 10\n      },\n\n      // image\n      maximumImageFileSize: null, // size in bytes, null = no limit\n\n      // callbacks\n      oninit: null,             // initialize\n      onfocus: null,            // editable has focus\n      onblur: null,             // editable out of focus\n      onenter: null,            // enter key pressed\n      onkeyup: null,            // keyup\n      onkeydown: null,          // keydown\n      onImageUpload: null,      // imageUpload\n      onImageUploadError: null, // imageUploadError\n      onMediaDelete: null,      // media delete\n      onToolbarClick: null,\n      onsubmit: null,\n\n      /**\n       * manipulate link address when user create link\n       * @param {String} sLinkUrl\n       * @return {String}\n       */\n      onCreateLink: function (sLinkUrl) {\n        if (sLinkUrl.indexOf('@') !== -1 && sLinkUrl.indexOf(':') === -1) {\n          sLinkUrl =  'mailto:' + sLinkUrl;\n        } else if (sLinkUrl.indexOf('://') === -1) {\n          sLinkUrl = 'http://' + sLinkUrl;\n        }\n\n        return sLinkUrl;\n      },\n\n      keyMap: {\n        pc: {\n          'ENTER': 'insertParagraph',\n          'CTRL+Z': 'undo',\n          'CTRL+Y': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CTRL+B': 'bold',\n          'CTRL+I': 'italic',\n          'CTRL+U': 'underline',\n          'CTRL+SHIFT+S': 'strikethrough',\n          'CTRL+BACKSLASH': 'removeFormat',\n          'CTRL+SHIFT+L': 'justifyLeft',\n          'CTRL+SHIFT+E': 'justifyCenter',\n          'CTRL+SHIFT+R': 'justifyRight',\n          'CTRL+SHIFT+J': 'justifyFull',\n          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n          'CTRL+LEFTBRACKET': 'outdent',\n          'CTRL+RIGHTBRACKET': 'indent',\n          'CTRL+NUM0': 'formatPara',\n          'CTRL+NUM1': 'formatH1',\n          'CTRL+NUM2': 'formatH2',\n          'CTRL+NUM3': 'formatH3',\n          'CTRL+NUM4': 'formatH4',\n          'CTRL+NUM5': 'formatH5',\n          'CTRL+NUM6': 'formatH6',\n          'CTRL+ENTER': 'insertHorizontalRule',\n          'CTRL+K': 'showLinkDialog'\n        },\n\n        mac: {\n          'ENTER': 'insertParagraph',\n          'CMD+Z': 'undo',\n          'CMD+SHIFT+Z': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CMD+B': 'bold',\n          'CMD+I': 'italic',\n          'CMD+U': 'underline',\n          'CMD+SHIFT+S': 'strikethrough',\n          'CMD+BACKSLASH': 'removeFormat',\n          'CMD+SHIFT+L': 'justifyLeft',\n          'CMD+SHIFT+E': 'justifyCenter',\n          'CMD+SHIFT+R': 'justifyRight',\n          'CMD+SHIFT+J': 'justifyFull',\n          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n          'CMD+SHIFT+NUM8': 'insertOrderedList',\n          'CMD+LEFTBRACKET': 'outdent',\n          'CMD+RIGHTBRACKET': 'indent',\n          'CMD+NUM0': 'formatPara',\n          'CMD+NUM1': 'formatH1',\n          'CMD+NUM2': 'formatH2',\n          'CMD+NUM3': 'formatH3',\n          'CMD+NUM4': 'formatH4',\n          'CMD+NUM5': 'formatH5',\n          'CMD+NUM6': 'formatH6',\n          'CMD+ENTER': 'insertHorizontalRule',\n          'CMD+K': 'showLinkDialog'\n        }\n      }\n    },\n\n    // default language: en-US\n    lang: {\n      'en-US': {\n        font: {\n          bold: 'Bold',\n          italic: 'Italic',\n          underline: 'Underline',\n          clear: 'Remove Font Style',\n          height: 'Line Height',\n          name: 'Font Family',\n          strikethrough: 'Strikethrough',\n          subscript: 'Subscript',\n          superscript: 'Superscript',\n          size: 'Font Size'\n        },\n        image: {\n          image: 'Picture',\n          insert: 'Insert Image',\n          resizeFull: 'Resize Full',\n          resizeHalf: 'Resize Half',\n          resizeQuarter: 'Resize Quarter',\n          floatLeft: 'Float Left',\n          floatRight: 'Float Right',\n          floatNone: 'Float None',\n          shapeRounded: 'Shape: Rounded',\n          shapeCircle: 'Shape: Circle',\n          shapeThumbnail: 'Shape: Thumbnail',\n          shapeNone: 'Shape: None',\n          dragImageHere: 'Drag image or text here',\n          dropImage: 'Drop image or Text',\n          selectFromFiles: 'Select from files',\n          maximumFileSize: 'Maximum file size',\n          maximumFileSizeError: 'Maximum file size exceeded.',\n          url: 'Image URL',\n          remove: 'Remove Image'\n        },\n        link: {\n          link: 'Link',\n          insert: 'Insert Link',\n          unlink: 'Unlink',\n          edit: 'Edit',\n          textToDisplay: 'Text to display',\n          url: 'To what URL should this link go?',\n          openInNewWindow: 'Open in new window'\n        },\n        table: {\n          table: 'Table'\n        },\n        hr: {\n          insert: 'Insert Horizontal Rule'\n        },\n        style: {\n          style: 'Style',\n          normal: 'Normal',\n          blockquote: 'Quote',\n          pre: 'Code',\n          h1: 'Header 1',\n          h2: 'Header 2',\n          h3: 'Header 3',\n          h4: 'Header 4',\n          h5: 'Header 5',\n          h6: 'Header 6'\n        },\n        lists: {\n          unordered: 'Unordered list',\n          ordered: 'Ordered list'\n        },\n        options: {\n          help: 'Help',\n          fullscreen: 'Sidebar',\n          codeview: 'Code View'\n        },\n        paragraph: {\n          paragraph: 'Paragraph',\n          outdent: 'Outdent',\n          indent: 'Indent',\n          left: 'Align left',\n          center: 'Align center',\n          right: 'Align right',\n          justify: 'Justify full'\n        },\n        color: {\n          recent: 'Recent Color',\n          more: 'More Color',\n          background: 'Background Color',\n          foreground: 'Foreground Color',\n          transparent: 'Transparent',\n          setTransparent: 'Set transparent',\n          reset: 'Reset',\n          resetToDefault: 'Reset to default'\n        },\n        shortcut: {\n          shortcuts: 'Keyboard shortcuts',\n          close: 'Close',\n          textFormatting: 'Text formatting',\n          action: 'Action',\n          paragraphFormatting: 'Paragraph formatting',\n          documentStyle: 'Document Style',\n          extraKeys: 'Extra keys'\n        },\n        history: {\n          undo: 'Undo',\n          redo: 'Redo'\n        }\n      }\n    }\n  };\n\n  /**\n   * @class core.async\n   *\n   * Async functions which returns `Promise`\n   *\n   * @singleton\n   * @alternateClassName async\n   */\n  var async = (function () {\n    /**\n     * @method readFileAsDataURL\n     *\n     * read contents of file as representing URL\n     *\n     * @param {File} file\n     * @return {Promise} - then: sDataUrl\n     */\n    var readFileAsDataURL = function (file) {\n      return $.Deferred(function (deferred) {\n        $.extend(new FileReader(), {\n          onload: function (e) {\n            var sDataURL = e.target.result;\n            deferred.resolve(sDataURL);\n          },\n          onerror: function () {\n            deferred.reject(this);\n          }\n        }).readAsDataURL(file);\n      }).promise();\n    };\n  \n    /**\n     * @method createImage\n     *\n     * create `<image>` from url string\n     *\n     * @param {String} sUrl\n     * @param {String} filename\n     * @return {Promise} - then: $image\n     */\n    var createImage = function (sUrl, filename) {\n      return $.Deferred(function (deferred) {\n        var $img = $('<img>');\n\n        $img.one('load', function () {\n          $img.off('error abort');\n          deferred.resolve($img);\n        }).one('error abort', function () {\n          $img.off('load').detach();\n          deferred.reject($img);\n        }).css({\n          display: 'none'\n        }).appendTo(document.body).attr({\n          'src': sUrl,\n          'data-filename': filename\n        });\n      }).promise();\n    };\n\n    return {\n      readFileAsDataURL: readFileAsDataURL,\n      createImage: createImage\n    };\n  })();\n\n  /**\n   * @class core.key\n   *\n   * Object for keycodes.\n   *\n   * @singleton\n   * @alternateClassName key\n   */\n  var key = (function () {\n    var keyMap = {\n      'BACKSPACE': 8,\n      'TAB': 9,\n      'ENTER': 13,\n      'SPACE': 32,\n\n      // Number: 0-9\n      'NUM0': 48,\n      'NUM1': 49,\n      'NUM2': 50,\n      'NUM3': 51,\n      'NUM4': 52,\n      'NUM5': 53,\n      'NUM6': 54,\n      'NUM7': 55,\n      'NUM8': 56,\n\n      // Alphabet: a-z\n      'B': 66,\n      'E': 69,\n      'I': 73,\n      'J': 74,\n      'K': 75,\n      'L': 76,\n      'R': 82,\n      'S': 83,\n      'U': 85,\n      'Y': 89,\n      'Z': 90,\n\n      'SLASH': 191,\n      'LEFTBRACKET': 219,\n      'BACKSLASH': 220,\n      'RIGHTBRACKET': 221\n    };\n\n    return {\n      /**\n       * @method isEdit\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isEdit: function (keyCode) {\n        return list.contains([8, 9, 13, 32], keyCode);\n      },\n      /**\n       * @method isMove\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isMove: function (keyCode) {\n        return list.contains([37, 38, 39, 40], keyCode);\n      },\n      /**\n       * @property {Object} nameFromCode\n       * @property {String} nameFromCode.8 \"BACKSPACE\"\n       */\n      nameFromCode: func.invertObject(keyMap),\n      code: keyMap\n    };\n  })();\n\n  /**\n   * @class editing.History\n   *\n   * Editor History\n   *\n   */\n  var History = function ($editable) {\n    var stack = [], stackOffset = -1;\n    var editable = $editable[0];\n\n    var makeSnapshot = function () {\n      var rng = range.create();\n      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\n      return {\n        contents: $editable.html(),\n        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n      };\n    };\n\n    var applySnapshot = function (snapshot) {\n      if (snapshot.contents !== null) {\n        $editable.html(snapshot.contents);\n      }\n      if (snapshot.bookmark !== null) {\n        range.createFromBookmark(editable, snapshot.bookmark).select();\n      }\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      if (0 < stackOffset) {\n        stackOffset--;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      if (stack.length - 1 > stackOffset) {\n        stackOffset++;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * recorded undo\n     */\n    this.recordUndo = function () {\n      stackOffset++;\n\n      // Wash out stack after stackOffset\n      if (stack.length > stackOffset) {\n        stack = stack.slice(0, stackOffset);\n      }\n\n      // Create new snapshot and push it to the end\n      stack.push(makeSnapshot());\n    };\n\n    // Create first undo stack\n    this.recordUndo();\n  };\n\n  /**\n   * @class editing.Style\n   *\n   * Style\n   *\n   */\n  var Style = function () {\n    /**\n     * @method jQueryCSS\n     *\n     * [workaround] for old jQuery\n     * passing an array of style properties to .css()\n     * will result in an object of property-value pairs.\n     * (compability with version < 1.9)\n     *\n     * @private\n     * @param  {jQuery} $obj\n     * @param  {Array} propertyNames - An array of one or more CSS properties.\n     * @return {Object}\n     */\n    var jQueryCSS = function ($obj, propertyNames) {\n      if (agent.jqueryVersion < 1.9) {\n        var result = {};\n        $.each(propertyNames, function (idx, propertyName) {\n          result[propertyName] = $obj.css(propertyName);\n        });\n        return result;\n      }\n      return $obj.css.call($obj, propertyNames);\n    };\n\n    /**\n     * paragraph level style\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} styleInfo\n     */\n    this.stylePara = function (rng, styleInfo) {\n      $.each(rng.nodes(dom.isPara, {\n        includeAncestor: true\n      }), function (idx, para) {\n        $(para).css(styleInfo);\n      });\n    };\n\n    /**\n     * insert and returns styleNodes on range.\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} [options] - options for styleNodes\n     * @param {String} [options.nodeName] - default: `SPAN`\n     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n     * @return {Node[]}\n     */\n    this.styleNodes = function (rng, options) {\n      rng = rng.splitText();\n\n      var nodeName = options && options.nodeName || 'SPAN';\n      var expandClosestSibling = !!(options && options.expandClosestSibling);\n      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\n      if (rng.isCollapsed()) {\n        return [rng.insertNode(dom.create(nodeName))];\n      }\n\n      var pred = dom.makePredByNodeName(nodeName);\n      var nodes = $.map(rng.nodes(dom.isText, {\n        fullyContains: true\n      }), function (text) {\n        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n      });\n\n      if (expandClosestSibling) {\n        if (onlyPartialContains) {\n          var nodesInRange = rng.nodes();\n          // compose with partial contains predication\n          pred = func.and(pred, function (node) {\n            return list.contains(nodesInRange, node);\n          });\n        }\n\n        return $.map(nodes, function (node) {\n          var siblings = dom.withClosestSiblings(node, pred);\n          var head = list.head(siblings);\n          var tails = list.tail(siblings);\n          $.each(tails, function (idx, elem) {\n            dom.appendChildNodes(head, elem.childNodes);\n            dom.remove(elem);\n          });\n          return list.head(siblings);\n        });\n      } else {\n        return nodes;\n      }\n    };\n\n    /**\n     * get current style on cursor\n     *\n     * @param {WrappedRange} rng\n     * @param {Node} target - target element on event\n     * @return {Object} - object contains style properties.\n     */\n    this.current = function (rng, target) {\n      var $cont = $(dom.isText(rng.sc) ? rng.sc.parentNode : rng.sc);\n      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n      var styleInfo = jQueryCSS($cont, properties) || {};\n\n      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n\n      // document.queryCommandState for toggle state\n      styleInfo['font-bold'] = document.queryCommandState('bold') ? 'bold' : 'normal';\n      styleInfo['font-italic'] = document.queryCommandState('italic') ? 'italic' : 'normal';\n      styleInfo['font-underline'] = document.queryCommandState('underline') ? 'underline' : 'normal';\n      styleInfo['font-strikethrough'] = document.queryCommandState('strikeThrough') ? 'strikethrough' : 'normal';\n      styleInfo['font-superscript'] = document.queryCommandState('superscript') ? 'superscript' : 'normal';\n      styleInfo['font-subscript'] = document.queryCommandState('subscript') ? 'subscript' : 'normal';\n\n      // list-style-type to list-style(unordered, ordered)\n      if (!rng.isOnList()) {\n        styleInfo['list-style'] = 'none';\n      } else {\n        var aOrderedType = ['circle', 'disc', 'disc-leading-zero', 'square'];\n        var isUnordered = $.inArray(styleInfo['list-style-type'], aOrderedType) > -1;\n        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n      }\n\n      var para = dom.ancestor(rng.sc, dom.isPara);\n      if (para && para.style['line-height']) {\n        styleInfo['line-height'] = para.style.lineHeight;\n      } else {\n        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n        styleInfo['line-height'] = lineHeight.toFixed(1);\n      }\n\n      styleInfo.image = dom.isImg(target) && target;\n      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n      styleInfo.range = rng;\n\n      return styleInfo;\n    };\n  };\n\n\n  /**\n   * @class editing.Bullet\n   *\n   * @alternateClassName Bullet\n   */\n  var Bullet = function () {\n    /**\n     * @method insertOrderedList\n     *\n     * toggle ordered list\n     *\n     * @type command\n     */\n    this.insertOrderedList = function () {\n      this.toggleList('OL');\n    };\n\n    /**\n     * @method insertUnorderedList\n     *\n     * toggle unordered list\n     *\n     * @type command\n     */\n    this.insertUnorderedList = function () {\n      this.toggleList('UL');\n    };\n\n    /**\n     * @method indent\n     *\n     * indent\n     *\n     * @type command\n     */\n    this.indent = function () {\n      var self = this;\n      var rng = range.create().wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.wrapList(paras, head.parentNode.nodeName);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              return (parseInt(val, 10) || 0) + 25;\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * @method outdent\n     *\n     * outdent\n     *\n     * @type command\n     */\n    this.outdent = function () {\n      var self = this;\n      var rng = range.create().wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.releaseList([paras]);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              val = (parseInt(val, 10) || 0);\n              return val > 25 ? val - 25 : '';\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * @method toggleList\n     *\n     * toggle list\n     *\n     * @param {String} listName - OL or UL\n     */\n    this.toggleList = function (listName) {\n      var self = this;\n      var rng = range.create().wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var bookmark = rng.paraBookmark(paras);\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      // paragraph to list\n      if (list.find(paras, dom.isPurePara)) {\n        var wrappedParas = [];\n        $.each(clustereds, function (idx, paras) {\n          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n        });\n        paras = wrappedParas;\n      // list to paragraph or change list style\n      } else {\n        var diffLists = rng.nodes(dom.isList, {\n          includeAncestor: true\n        }).filter(function (listNode) {\n          return !$.nodeName(listNode, listName);\n        });\n\n        if (diffLists.length) {\n          $.each(diffLists, function (idx, listNode) {\n            dom.replace(listNode, listName);\n          });\n        } else {\n          paras = this.releaseList(clustereds, true);\n        }\n      }\n\n      range.createFromParaBookmark(bookmark, paras).select();\n    };\n\n    /**\n     * @method wrapList\n     *\n     * @param {Node[]} paras\n     * @param {String} listName\n     * @return {Node[]}\n     */\n    this.wrapList = function (paras, listName) {\n      var head = list.head(paras);\n      var last = list.last(paras);\n\n      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\n      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\n      // P to LI\n      paras = $.map(paras, function (para) {\n        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n      });\n\n      // append to list(<ul>, <ol>)\n      dom.appendChildNodes(listNode, paras);\n\n      if (nextList) {\n        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n        dom.remove(nextList);\n      }\n\n      return paras;\n    };\n\n    /**\n     * @method releaseList\n     *\n     * @param {Array[]} clustereds\n     * @param {Boolean} isEscapseToBody\n     * @return {Node[]}\n     */\n    this.releaseList = function (clustereds, isEscapseToBody) {\n      var releasedParas = [];\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        var last = list.last(paras);\n\n        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n                                         head.parentNode;\n        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n          node: last.parentNode,\n          offset: dom.position(last) + 1\n        }, {\n          isSkipPaddingBlankHTML: true\n        }) : null;\n\n        var middleList = dom.splitTree(headList, {\n          node: head.parentNode,\n          offset: dom.position(head)\n        }, {\n          isSkipPaddingBlankHTML: true\n        });\n\n        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n                                  list.from(middleList.childNodes).filter(dom.isLi);\n\n        // LI to P\n        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n          paras = $.map(paras, function (para) {\n            return dom.replace(para, 'P');\n          });\n        }\n\n        $.each(list.from(paras).reverse(), function (idx, para) {\n          dom.insertAfter(para, headList);\n        });\n\n        // remove empty lists\n        var rootLists = list.compact([headList, middleList, lastList]);\n        $.each(rootLists, function (idx, rootList) {\n          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n          $.each(listNodes.reverse(), function (idx, listNode) {\n            if (!dom.nodeLength(listNode)) {\n              dom.remove(listNode, true);\n            }\n          });\n        });\n\n        releasedParas = releasedParas.concat(paras);\n      });\n\n      return releasedParas;\n    };\n  };\n\n\n  /**\n   * @class editing.Typing\n   *\n   * Typing\n   *\n   */\n  var Typing = function () {\n\n    // a Bullet instance to toggle lists off\n    var bullet = new Bullet();\n\n    /**\n     * insert tab\n     *\n     * @param {jQuery} $editable\n     * @param {WrappedRange} rng\n     * @param {Number} tabsize\n     */\n    this.insertTab = function ($editable, rng, tabsize) {\n      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n      rng = rng.deleteContents();\n      rng.insertNode(tab, true);\n\n      rng = range.create(tab, tabsize);\n      rng.select();\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = function () {\n      var rng = range.create();\n\n      // deleteContents on range.\n      rng = rng.deleteContents();\n\n      // Wrap range if it needs to be wrapped by paragraph\n      rng = rng.wrapBodyInlineWithPara();\n\n      // finding paragraph\n      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\n      var nextPara;\n      // on paragraph: split paragraph\n      if (splitRoot) {\n        // if it is an empty line with li\n        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n          // disable UL/OL and escape!\n          bullet.toggleList(splitRoot.parentNode.nodeName);\n          return;\n        // if new line has content (not a line break)\n        } else {\n          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\n          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\n          $.each(emptyAnchors, function (idx, anchor) {\n            dom.remove(anchor);\n          });\n        }\n      // no paragraph: insert empty paragraph\n      } else {\n        var next = rng.sc.childNodes[rng.so];\n        nextPara = $(dom.emptyPara)[0];\n        if (next) {\n          rng.sc.insertBefore(nextPara, next);\n        } else {\n          rng.sc.appendChild(nextPara);\n        }\n      }\n\n      range.create(nextPara, 0).normalize().select();\n\n    };\n\n  };\n\n  /**\n   * @class editing.Table\n   *\n   * Table\n   *\n   */\n  var Table = function () {\n    /**\n     * handle tab key\n     *\n     * @param {WrappedRange} rng\n     * @param {Boolean} isShift\n     */\n    this.tab = function (rng, isShift) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var table = dom.ancestor(cell, dom.isTable);\n      var cells = dom.listDescendant(table, dom.isCell);\n\n      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n      if (nextCell) {\n        range.create(nextCell, 0).select();\n      }\n    };\n\n    /**\n     * create empty table element\n     *\n     * @param {Number} rowCount\n     * @param {Number} colCount\n     * @return {Node}\n     */\n    this.createTable = function (colCount, rowCount) {\n      var tds = [], tdHTML;\n      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n        tds.push('<td>' + dom.blank + '</td>');\n      }\n      tdHTML = tds.join('');\n\n      var trs = [], trHTML;\n      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n        trs.push('<tr>' + tdHTML + '</tr>');\n      }\n      trHTML = trs.join('');\n      return $('<table class=\"table table-bordered\">' + trHTML + '</table>')[0];\n    };\n  };\n\n\n  var KEY_BOGUS = 'bogus';\n\n  /**\n   * @class editing.Editor\n   *\n   * Editor\n   *\n   */\n  var Editor = function (handler) {\n\n    var style = new Style();\n    var table = new Table();\n    var typing = new Typing();\n    var bullet = new Bullet();\n\n    /**\n     * @method createRange\n     *\n     * create range\n     *\n     * @param {jQuery} $editable\n     * @return {WrappedRange}\n     */\n    this.createRange = function ($editable) {\n      this.focus($editable);\n      return range.create();\n    };\n\n    /**\n     * @method saveRange\n     *\n     * save current range\n     *\n     * @param {jQuery} $editable\n     * @param {Boolean} [thenCollapse=false]\n     */\n    this.saveRange = function ($editable, thenCollapse) {\n      this.focus($editable);\n      $editable.data('range', range.create());\n      if (thenCollapse) {\n        range.create().collapse().select();\n      }\n    };\n\n    /**\n     * @method saveRange\n     *\n     * save current node list to $editable.data('childNodes')\n     *\n     * @param {jQuery} $editable\n     */\n    this.saveNode = function ($editable) {\n      // copy child node reference\n      var copy = [];\n      for (var key  = 0, len = $editable[0].childNodes.length; key < len; key++) {\n        copy.push($editable[0].childNodes[key]);\n      }\n      $editable.data('childNodes', copy);\n    };\n\n    /**\n     * @method restoreRange\n     *\n     * restore lately range\n     *\n     * @param {jQuery} $editable\n     */\n    this.restoreRange = function ($editable) {\n      var rng = $editable.data('range');\n      if (rng) {\n        rng.select();\n        this.focus($editable);\n      }\n    };\n\n    /**\n     * @method restoreNode\n     *\n     * restore lately node list\n     *\n     * @param {jQuery} $editable\n     */\n    this.restoreNode = function ($editable) {\n      $editable.html('');\n      var child = $editable.data('childNodes');\n      for (var index = 0, len = child.length; index < len; index++) {\n        $editable[0].appendChild(child[index]);\n      }\n    };\n    /**\n     * @method currentStyle\n     *\n     * current style\n     *\n     * @param {Node} target\n     * @return {Boolean} false if range is no\n     */\n    this.currentStyle = function (target) {\n      var rng = range.create();\n      return rng ? rng.isOnEditable() && style.current(rng, target) : false;\n    };\n\n    var triggerOnBeforeChange = function ($editable) {\n      var $holder = dom.makeLayoutInfo($editable).holder();\n      handler.bindCustomEvent(\n        $holder, $editable.data('callbacks'), 'before.command'\n      )($editable.html(), $editable);\n    };\n\n    var triggerOnChange = function ($editable) {\n      var $holder = dom.makeLayoutInfo($editable).holder();\n      handler.bindCustomEvent(\n        $holder, $editable.data('callbacks'), 'change'\n      )($editable.html(), $editable);\n    };\n\n    /**\n     * @method undo\n     * undo\n     * @param {jQuery} $editable\n     */\n    this.undo = function ($editable) {\n      triggerOnBeforeChange($editable);\n      $editable.data('NoteHistory').undo();\n      triggerOnChange($editable);\n    };\n\n    /**\n     * @method redo\n     * redo\n     * @param {jQuery} $editable\n     */\n    this.redo = function ($editable) {\n      triggerOnBeforeChange($editable);\n      $editable.data('NoteHistory').redo();\n      triggerOnChange($editable);\n    };\n\n    var self = this;\n    /**\n     * @method beforeCommand\n     * before command\n     * @param {jQuery} $editable\n     */\n    var beforeCommand = this.beforeCommand = function ($editable) {\n      triggerOnBeforeChange($editable);\n      // keep focus on editable before command execution\n      self.focus($editable);\n    };\n\n    /**\n     * @method afterCommand\n     * after command\n     * @param {jQuery} $editable\n     * @param {Boolean} isPreventTrigger\n     */\n    var afterCommand = this.afterCommand = function ($editable, isPreventTrigger) {\n      $editable.data('NoteHistory').recordUndo();\n      if (!isPreventTrigger) {\n        triggerOnChange($editable);\n      }\n    };\n\n    /**\n     * @method bold\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method italic\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method underline\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method strikethrough\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method formatBlock\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method superscript\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method subscript\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method justifyLeft\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method justifyCenter\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method justifyRight\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method justifyFull\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method formatBlock\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method removeFormat\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method backColor\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method foreColor\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method insertHorizontalRule\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /**\n     * @method fontName\n     *\n     * change font name\n     *\n     * @param {jQuery} $editable\n     * @param {Mixed} value\n     */\n\n    /* jshint ignore:start */\n    // native commands(with execCommand), generate function for execCommand\n    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n                    'formatBlock', 'removeFormat',\n                    'backColor', 'foreColor', 'insertHorizontalRule', 'fontName'];\n\n    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n      this[commands[idx]] = (function (sCmd) {\n        return function ($editable, value) {\n          beforeCommand($editable);\n\n          document.execCommand(sCmd, false, value);\n\n          afterCommand($editable, true);\n        };\n      })(commands[idx]);\n    }\n    /* jshint ignore:end */\n\n    /**\n     * @method tab\n     *\n     * handle tab key\n     *\n     * @param {jQuery} $editable\n     * @param {Object} options\n     */\n    this.tab = function ($editable, options) {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng);\n      } else {\n        beforeCommand($editable);\n        typing.insertTab($editable, rng, options.tabsize);\n        afterCommand($editable);\n      }\n    };\n\n    /**\n     * @method untab\n     *\n     * handle shift+tab key\n     *\n     */\n    this.untab = function ($editable) {\n      var rng = this.createRange($editable);\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng, true);\n      }\n    };\n\n    /**\n     * @method insertParagraph\n     *\n     * insert paragraph\n     *\n     * @param {Node} $editable\n     */\n    this.insertParagraph = function ($editable) {\n      beforeCommand($editable);\n      typing.insertParagraph($editable);\n      afterCommand($editable);\n    };\n\n    /**\n     * @method insertOrderedList\n     *\n     * @param {jQuery} $editable\n     */\n    this.insertOrderedList = function ($editable) {\n      beforeCommand($editable);\n      bullet.insertOrderedList($editable);\n      afterCommand($editable);\n    };\n\n    /**\n     * @param {jQuery} $editable\n     */\n    this.insertUnorderedList = function ($editable) {\n      beforeCommand($editable);\n      bullet.insertUnorderedList($editable);\n      afterCommand($editable);\n    };\n\n    /**\n     * @param {jQuery} $editable\n     */\n    this.indent = function ($editable) {\n      beforeCommand($editable);\n      bullet.indent($editable);\n      afterCommand($editable);\n    };\n\n    /**\n     * @param {jQuery} $editable\n     */\n    this.outdent = function ($editable) {\n      beforeCommand($editable);\n      bullet.outdent($editable);\n      afterCommand($editable);\n    };\n\n    /**\n     * insert image\n     *\n     * @param {jQuery} $editable\n     * @param {String} sUrl\n     */\n    this.insertImage = function ($editable, sUrl, filename) {\n      async.createImage(sUrl, filename).then(function ($image) {\n        beforeCommand($editable);\n        $image.css({\n          display: '',\n          width: Math.min($editable.width(), $image.width())\n        });\n        range.create().insertNode($image[0]);\n        range.createFromNodeAfter($image[0]).select();\n        afterCommand($editable);\n      }).fail(function () {\n        var $holder = dom.makeLayoutInfo($editable).holder();\n        handler.bindCustomEvent(\n          $holder, $editable.data('callbacks'), 'image.upload.error'\n        )();\n      });\n    };\n\n    /**\n     * @method insertNode\n     * insert node\n     * @param {Node} $editable\n     * @param {Node} node\n     */\n    this.insertNode = function ($editable, node) {\n      beforeCommand($editable);\n      range.create().insertNode(node);\n      range.createFromNodeAfter(node).select();\n      afterCommand($editable);\n    };\n\n    /**\n     * insert text\n     * @param {Node} $editable\n     * @param {String} text\n     */\n    this.insertText = function ($editable, text) {\n      beforeCommand($editable);\n      var textNode = range.create().insertNode(dom.createText(text));\n      range.create(textNode, dom.nodeLength(textNode)).select();\n      afterCommand($editable);\n    };\n\n    /**\n     * paste HTML\n     * @param {Node} $editable\n     * @param {String} markup\n     */\n    this.pasteHTML = function ($editable, markup) {\n      beforeCommand($editable);\n      var contents = range.create().pasteHTML(markup);\n      range.createFromNodeAfter(list.last(contents)).select();\n      afterCommand($editable);\n    };\n\n    /**\n     * formatBlock\n     *\n     * @param {jQuery} $editable\n     * @param {String} tagName\n     */\n    this.formatBlock = function ($editable, tagName) {\n      beforeCommand($editable);\n      // [workaround] for MSIE, IE need `<`\n      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n      document.execCommand('FormatBlock', false, tagName);\n      afterCommand($editable);\n    };\n\n    this.formatPara = function ($editable) {\n      beforeCommand($editable);\n      this.formatBlock($editable, 'P');\n      afterCommand($editable);\n    };\n\n    /* jshint ignore:start */\n    for (var idx = 1; idx <= 6; idx ++) {\n      this['formatH' + idx] = function (idx) {\n        return function ($editable) {\n          this.formatBlock($editable, 'H' + idx);\n        };\n      }(idx);\n    };\n    /* jshint ignore:end */\n\n    /**\n     * fontSize\n     *\n     * @param {jQuery} $editable\n     * @param {String} value - px\n     */\n    this.fontSize = function ($editable, value) {\n      var rng = range.create();\n      var isCollapsed = rng.isCollapsed();\n\n      if (isCollapsed) {\n        var spans = style.styleNodes(rng);\n        var firstSpan = list.head(spans);\n\n        $(spans).css({\n          'font-size': value + 'px'\n        });\n\n        // [workaround] added styled bogus span for style\n        //  - also bogus character needed for cursor position\n        if (firstSpan && !dom.nodeLength(firstSpan)) {\n          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n          range.createFromNodeAfter(firstSpan.firstChild).select();\n          $editable.data(KEY_BOGUS, firstSpan);\n        }\n      } else {\n        beforeCommand($editable);\n        $(style.styleNodes(rng)).css({\n          'font-size': value + 'px'\n        });\n        afterCommand($editable);\n      }\n    };\n\n    /**\n     * remove bogus node and character\n     */\n    this.removeBogus = function ($editable) {\n      var bogusNode = $editable.data(KEY_BOGUS);\n      if (!bogusNode) {\n        return;\n      }\n\n      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\n      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n      if (bogusCharIdx !== -1) {\n        textNode.deleteData(bogusCharIdx, 1);\n      }\n\n      if (dom.isEmpty(bogusNode)) {\n        dom.remove(bogusNode);\n      }\n\n      $editable.removeData(KEY_BOGUS);\n    };\n\n    /**\n     * lineHeight\n     * @param {jQuery} $editable\n     * @param {String} value\n     */\n    this.lineHeight = function ($editable, value) {\n      beforeCommand($editable);\n      style.stylePara(range.create(), {\n        lineHeight: value\n      });\n      afterCommand($editable);\n    };\n\n    /**\n     * unlink\n     *\n     * @type command\n     *\n     * @param {jQuery} $editable\n     */\n    this.unlink = function ($editable) {\n      var rng = this.createRange();\n      if (rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        rng = range.createFromNode(anchor);\n        rng.select();\n\n        beforeCommand($editable);\n        document.execCommand('unlink');\n        afterCommand($editable);\n      }\n    };\n\n    /**\n     * create link (command)\n     *\n     * @param {jQuery} $editable\n     * @param {Object} linkInfo\n     * @param {Object} options\n     */\n    this.createLink = function ($editable, linkInfo, options) {\n      var linkUrl = linkInfo.url;\n      var linkText = linkInfo.text;\n      var isNewWindow = linkInfo.newWindow;\n      var rng = linkInfo.range;\n      var isTextChanged = rng.toString() !== linkText;\n\n      beforeCommand($editable);\n\n      if (options.onCreateLink) {\n        linkUrl = options.onCreateLink(linkUrl);\n      }\n\n      var anchors = [];\n      if (isTextChanged) {\n        // Create a new link when text changed.\n        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n        anchors.push(anchor);\n      } else {\n        anchors = style.styleNodes(rng, {\n          nodeName: 'A',\n          expandClosestSibling: true,\n          onlyPartialContains: true\n        });\n      }\n\n      $.each(anchors, function (idx, anchor) {\n        $(anchor).attr('href', linkUrl);\n        if (isNewWindow) {\n          $(anchor).attr('target', '_blank');\n        } else {\n          $(anchor).removeAttr('target');\n        }\n      });\n\n      var startRange = range.createFromNodeBefore(list.head(anchors));\n      var startPoint = startRange.getStartPoint();\n      var endRange = range.createFromNodeAfter(list.last(anchors));\n      var endPoint = endRange.getEndPoint();\n\n      range.create(\n        startPoint.node,\n        startPoint.offset,\n        endPoint.node,\n        endPoint.offset\n      ).select();\n\n      afterCommand($editable);\n    };\n\n    /**\n     * returns link info\n     *\n     * @return {Object}\n     * @return {WrappedRange} return.range\n     * @return {String} return.text\n     * @return {Boolean} [return.isNewWindow=true]\n     * @return {String} [return.url=\"\"]\n     */\n    this.getLinkInfo = function ($editable) {\n      this.focus($editable);\n\n      var rng = range.create().expand(dom.isAnchor);\n\n      // Get the first anchor on range(for edit).\n      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n\n      return {\n        range: rng,\n        text: rng.toString(),\n        isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,\n        url: $anchor.length ? $anchor.attr('href') : ''\n      };\n    };\n\n    /**\n     * setting color\n     *\n     * @param {Node} $editable\n     * @param {Object} sObjColor  color code\n     * @param {String} sObjColor.foreColor foreground color\n     * @param {String} sObjColor.backColor background color\n     */\n    this.color = function ($editable, sObjColor) {\n      var oColor = JSON.parse(sObjColor);\n      var foreColor = oColor.foreColor, backColor = oColor.backColor;\n\n      beforeCommand($editable);\n\n      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n      if (backColor) { document.execCommand('backColor', false, backColor); }\n\n      afterCommand($editable);\n    };\n\n    /**\n     * insert Table\n     *\n     * @param {Node} $editable\n     * @param {String} sDim dimension of table (ex : \"5x5\")\n     */\n    this.insertTable = function ($editable, sDim) {\n      var dimension = sDim.split('x');\n      beforeCommand($editable);\n\n      var rng = range.create().deleteContents();\n      rng.insertNode(table.createTable(dimension[0], dimension[1]));\n      afterCommand($editable);\n    };\n\n    /**\n     * float me\n     *\n     * @param {jQuery} $editable\n     * @param {String} value\n     * @param {jQuery} $target\n     */\n    this.floatMe = function ($editable, value, $target) {\n      beforeCommand($editable);\n      $target.css('float', value);\n      afterCommand($editable);\n    };\n\n    /**\n     * change image shape\n     *\n     * @param {jQuery} $editable\n     * @param {String} value css class\n     * @param {Node} $target\n     */\n    this.imageShape = function ($editable, value, $target) {\n      beforeCommand($editable);\n\n      $target.removeClass('img-rounded img-circle img-thumbnail');\n\n      if (value) {\n        $target.addClass(value);\n      }\n\n      afterCommand($editable);\n    };\n\n    /**\n     * resize overlay element\n     * @param {jQuery} $editable\n     * @param {String} value\n     * @param {jQuery} $target - target element\n     */\n    this.resize = function ($editable, value, $target) {\n      beforeCommand($editable);\n\n      $target.css({\n        width: value * 100 + '%',\n        height: ''\n      });\n\n      afterCommand($editable);\n    };\n\n    /**\n     * @param {Position} pos\n     * @param {jQuery} $target - target element\n     * @param {Boolean} [bKeepRatio] - keep ratio\n     */\n    this.resizeTo = function (pos, $target, bKeepRatio) {\n      var imageSize;\n      if (bKeepRatio) {\n        var newRatio = pos.y / pos.x;\n        var ratio = $target.data('ratio');\n        imageSize = {\n          width: ratio > newRatio ? pos.x : pos.y / ratio,\n          height: ratio > newRatio ? pos.x * ratio : pos.y\n        };\n      } else {\n        imageSize = {\n          width: pos.x,\n          height: pos.y\n        };\n      }\n\n      $target.css(imageSize);\n    };\n\n    /**\n     * remove media object\n     *\n     * @param {jQuery} $editable\n     * @param {String} value - dummy argument (for keep interface)\n     * @param {jQuery} $target - target element\n     */\n    this.removeMedia = function ($editable, value, $target) {\n      beforeCommand($editable);\n      $target.detach();\n\n      handler.bindCustomEvent(\n        $(), $editable.data('callbacks'), 'media.delete'\n      )($target, $editable);\n\n      afterCommand($editable);\n    };\n\n    /**\n     * set focus\n     *\n     * @param $editable\n     */\n    this.focus = function ($editable) {\n      $editable.focus();\n\n      // [workaround] for firefox bug http://goo.gl/lVfAaI\n      if (agent.isFF && !range.create().isOnEditable()) {\n        range.createFromNode($editable[0])\n             .normalize()\n             .collapse()\n             .select();\n      }\n    };\n  };\n\n  /**\n   * @class module.Button\n   *\n   * Button\n   */\n  var Button = function () {\n    /**\n     * update button status\n     *\n     * @param {jQuery} $container\n     * @param {Object} styleInfo\n     */\n    this.update = function ($container, styleInfo) {\n      /**\n       * handle dropdown's check mark (for fontname, fontsize, lineHeight).\n       * @param {jQuery} $btn\n       * @param {Number} value\n       */\n      var checkDropdownMenu = function ($btn, value) {\n        $btn.find('.dropdown-menu li a').each(function () {\n          // always compare string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (value + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n      };\n\n      /**\n       * update button state(active or not).\n       *\n       * @private\n       * @param {String} selector\n       * @param {Function} pred\n       */\n      var btnState = function (selector, pred) {\n        var $btn = $container.find(selector);\n        $btn.toggleClass('active', pred());\n      };\n\n      if (styleInfo.image) {\n        var $img = $(styleInfo.image);\n\n        btnState('button[data-event=\"imageShape\"][data-value=\"img-rounded\"]', function () {\n          return $img.hasClass('img-rounded');\n        });\n        btnState('button[data-event=\"imageShape\"][data-value=\"img-circle\"]', function () {\n          return $img.hasClass('img-circle');\n        });\n        btnState('button[data-event=\"imageShape\"][data-value=\"img-thumbnail\"]', function () {\n          return $img.hasClass('img-thumbnail');\n        });\n        btnState('button[data-event=\"imageShape\"]:not([data-value])', function () {\n          return !$img.is('.img-rounded, .img-circle, .img-thumbnail');\n        });\n\n        var imgFloat = $img.css('float');\n        btnState('button[data-event=\"floatMe\"][data-value=\"left\"]', function () {\n          return imgFloat === 'left';\n        });\n        btnState('button[data-event=\"floatMe\"][data-value=\"right\"]', function () {\n          return imgFloat === 'right';\n        });\n        btnState('button[data-event=\"floatMe\"][data-value=\"none\"]', function () {\n          return imgFloat !== 'left' && imgFloat !== 'right';\n        });\n\n        var style = $img.attr('style');\n        btnState('button[data-event=\"resize\"][data-value=\"1\"]', function () {\n          return !!/(^|\\s)(max-)?width\\s*:\\s*100%/.test(style);\n        });\n        btnState('button[data-event=\"resize\"][data-value=\"0.5\"]', function () {\n          return !!/(^|\\s)(max-)?width\\s*:\\s*50%/.test(style);\n        });\n        btnState('button[data-event=\"resize\"][data-value=\"0.25\"]', function () {\n          return !!/(^|\\s)(max-)?width\\s*:\\s*25%/.test(style);\n        });\n        return;\n      }\n\n      // fontname\n      var $fontname = $container.find('.note-fontname');\n      if ($fontname.length) {\n        var selectedFont = styleInfo['font-family'];\n        if (!!selectedFont) {\n\n          var list = selectedFont.split(',');\n          for (var i = 0, len = list.length; i < len; i++) {\n            selectedFont = list[i].replace(/[\\'\\\"]/g, '').replace(/\\s+$/, '').replace(/^\\s+/, '');\n            if (agent.isFontInstalled(selectedFont)) {\n              break;\n            }\n          }\n          \n          $fontname.find('.note-current-fontname').text(selectedFont);\n          checkDropdownMenu($fontname, selectedFont);\n\n        }\n      }\n\n      // fontsize\n      var $fontsize = $container.find('.note-fontsize');\n      $fontsize.find('.note-current-fontsize').text(styleInfo['font-size']);\n      checkDropdownMenu($fontsize, parseFloat(styleInfo['font-size']));\n\n      // lineheight\n      var $lineHeight = $container.find('.note-height');\n      checkDropdownMenu($lineHeight, parseFloat(styleInfo['line-height']));\n\n      btnState('button[data-event=\"bold\"]', function () {\n        return styleInfo['font-bold'] === 'bold';\n      });\n      btnState('button[data-event=\"italic\"]', function () {\n        return styleInfo['font-italic'] === 'italic';\n      });\n      btnState('button[data-event=\"underline\"]', function () {\n        return styleInfo['font-underline'] === 'underline';\n      });\n      btnState('button[data-event=\"strikethrough\"]', function () {\n        return styleInfo['font-strikethrough'] === 'strikethrough';\n      });\n      btnState('button[data-event=\"superscript\"]', function () {\n        return styleInfo['font-superscript'] === 'superscript';\n      });\n      btnState('button[data-event=\"subscript\"]', function () {\n        return styleInfo['font-subscript'] === 'subscript';\n      });\n      btnState('button[data-event=\"justifyLeft\"]', function () {\n        return styleInfo['text-align'] === 'left' || styleInfo['text-align'] === 'start';\n      });\n      btnState('button[data-event=\"justifyCenter\"]', function () {\n        return styleInfo['text-align'] === 'center';\n      });\n      btnState('button[data-event=\"justifyRight\"]', function () {\n        return styleInfo['text-align'] === 'right';\n      });\n      btnState('button[data-event=\"justifyFull\"]', function () {\n        return styleInfo['text-align'] === 'justify';\n      });\n      btnState('button[data-event=\"insertUnorderedList\"]', function () {\n        return styleInfo['list-style'] === 'unordered';\n      });\n      btnState('button[data-event=\"insertOrderedList\"]', function () {\n        return styleInfo['list-style'] === 'ordered';\n      });\n    };\n\n    /**\n     * update recent color\n     *\n     * @param {Node} button\n     * @param {String} eventName\n     * @param {Mixed} value\n     */\n    this.updateRecentColor = function (button, eventName, value) {\n      var $color = $(button).closest('.note-color');\n      var $recentColor = $color.find('.note-recent-color');\n      var colorInfo = JSON.parse($recentColor.attr('data-value'));\n      colorInfo[eventName] = value;\n      $recentColor.attr('data-value', JSON.stringify(colorInfo));\n      var sKey = eventName === 'backColor' ? 'background-color' : 'color';\n      $recentColor.find('i').css(sKey, value);\n    };\n  };\n\n  /**\n   * @class module.Toolbar\n   *\n   * Toolbar\n   */\n  var Toolbar = function () {\n    var button = new Button();\n\n    this.update = function ($toolbar, styleInfo) {\n      button.update($toolbar, styleInfo);\n    };\n\n    /**\n     * @param {Node} button\n     * @param {String} eventName\n     * @param {String} value\n     */\n    this.updateRecentColor = function (buttonNode, eventName, value) {\n      button.updateRecentColor(buttonNode, eventName, value);\n    };\n\n    /**\n     * activate buttons exclude codeview\n     * @param {jQuery} $toolbar\n     */\n    this.activate = function ($toolbar) {\n      $toolbar.find('button')\n              .not('button[data-event=\"codeview\"]')\n              .removeClass('disabled');\n    };\n\n    /**\n     * deactivate buttons exclude codeview\n     * @param {jQuery} $toolbar\n     */\n    this.deactivate = function ($toolbar) {\n      $toolbar.find('button')\n              .not('button[data-event=\"codeview\"]')\n              .addClass('disabled');\n    };\n\n    /**\n     * @param {jQuery} $container\n     * @param {Boolean} [bFullscreen=false]\n     */\n    this.updateFullscreen = function ($container, bFullscreen) {\n      var $btn = $container.find('button[data-event=\"fullscreen\"]');\n      $btn.toggleClass('active', bFullscreen);\n    };\n\n    /**\n     * @param {jQuery} $container\n     * @param {Boolean} [isCodeview=false]\n     */\n    this.updateCodeview = function ($container, isCodeview) {\n      var $btn = $container.find('button[data-event=\"codeview\"]');\n      $btn.toggleClass('active', isCodeview);\n\n      if (isCodeview) {\n        this.deactivate($container);\n      } else {\n        this.activate($container);\n      }\n    };\n\n    /**\n     * get button in toolbar \n     *\n     * @param {jQuery} $editable\n     * @param {String} name\n     * @return {jQuery}\n     */\n    this.get = function ($editable, name) {\n      var $toolbar = dom.makeLayoutInfo($editable).toolbar();\n\n      return $toolbar.find('[data-name=' + name + ']');\n    };\n\n    /**\n     * set button state\n     * @param {jQuery} $editable\n     * @param {String} name\n     * @param {Boolean} [isActive=true]\n     */\n    this.setButtonState = function ($editable, name, isActive) {\n      isActive = (isActive === false) ? false : true;\n\n      var $button = this.get($editable, name);\n      $button.toggleClass('active', isActive);\n    };\n  };\n\n  var EDITABLE_PADDING = 24;\n\n  var Statusbar = function () {\n    var $document = $(document);\n\n    this.attach = function (layoutInfo, options) {\n      if (!options.disableResizeEditor) {\n        layoutInfo.statusbar().on('mousedown', hStatusbarMousedown);\n      }\n    };\n\n    /**\n     * `mousedown` event handler on statusbar\n     *\n     * @param {MouseEvent} event\n     */\n    var hStatusbarMousedown = function (event) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      var $editable = dom.makeLayoutInfo(event.target).editable();\n      var editableTop = $editable.offset().top - $document.scrollTop();\n\n      var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);\n      var options = layoutInfo.editor().data('options');\n\n      $document.on('mousemove', function (event) {\n        var nHeight = event.clientY - (editableTop + EDITABLE_PADDING);\n\n        nHeight = (options.minHeight > 0) ? Math.max(nHeight, options.minHeight) : nHeight;\n        nHeight = (options.maxHeight > 0) ? Math.min(nHeight, options.maxHeight) : nHeight;\n\n        $editable.height(nHeight);\n      }).one('mouseup', function () {\n        $document.off('mousemove');\n      });\n    };\n  };\n\n  /**\n   * @class module.Popover\n   *\n   * Popover (http://getbootstrap.com/javascript/#popovers)\n   *\n   */\n  var Popover = function () {\n    var button = new Button();\n\n    /**\n     * returns position from placeholder\n     *\n     * @private\n     * @param {Node} placeholder\n     * @param {Boolean} isAirMode\n     * @return {Object}\n     * @return {Number} return.left\n     * @return {Number} return.top\n     */\n    var posFromPlaceholder = function (placeholder, isAirMode) {\n      var $placeholder = $(placeholder);\n      var pos = isAirMode ? $placeholder.offset() : $placeholder.position();\n      var height = $placeholder.outerHeight(true); // include margin\n\n      // popover below placeholder.\n      return {\n        left: pos.left,\n        top: pos.top + height\n      };\n    };\n\n    /**\n     * show popover\n     *\n     * @private\n     * @param {jQuery} popover\n     * @param {Position} pos\n     */\n    var showPopover = function ($popover, pos) {\n      $popover.css({\n        display: 'block',\n        left: pos.left,\n        top: pos.top\n      });\n    };\n\n    var PX_POPOVER_ARROW_OFFSET_X = 20;\n\n    /**\n     * update current state\n     * @param {jQuery} $popover - popover container\n     * @param {Object} styleInfo - style object\n     * @param {Boolean} isAirMode\n     */\n    this.update = function ($popover, styleInfo, isAirMode) {\n      button.update($popover, styleInfo);\n\n      var $linkPopover = $popover.find('.note-link-popover');\n      if (styleInfo.anchor) {\n        var $anchor = $linkPopover.find('a');\n        var href = $(styleInfo.anchor).attr('href');\n        var target = $(styleInfo.anchor).attr('target');\n        $anchor.attr('href', href).html(href);\n        if (!target) {\n          $anchor.removeAttr('target');\n        } else {\n          $anchor.attr('target', '_blank');\n        }\n        showPopover($linkPopover, posFromPlaceholder(styleInfo.anchor, isAirMode));\n      } else {\n        $linkPopover.hide();\n      }\n\n      var $imagePopover = $popover.find('.note-image-popover');\n      if (styleInfo.image) {\n        showPopover($imagePopover, posFromPlaceholder(styleInfo.image, isAirMode));\n      } else {\n        $imagePopover.hide();\n      }\n\n      var $airPopover = $popover.find('.note-air-popover');\n      if (isAirMode && !styleInfo.range.isCollapsed()) {\n        var rect = list.last(styleInfo.range.getClientRects());\n        if (rect) {\n          var bnd = func.rect2bnd(rect);\n          showPopover($airPopover, {\n            left: Math.max(bnd.left + bnd.width / 2 - PX_POPOVER_ARROW_OFFSET_X, 0),\n            top: bnd.top + bnd.height\n          });\n        }\n      } else {\n        $airPopover.hide();\n      }\n    };\n\n    /**\n     * @param {Node} button\n     * @param {String} eventName\n     * @param {String} value\n     */\n    this.updateRecentColor = function (button, eventName, value) {\n      button.updateRecentColor(button, eventName, value);\n    };\n\n    /**\n     * hide all popovers\n     * @param {jQuery} $popover - popover container\n     */\n    this.hide = function ($popover) {\n      $popover.children().hide();\n    };\n  };\n\n  /**\n   * @class module.Handle\n   *\n   * Handle\n   */\n  var Handle = function (handler) {\n    var $document = $(document);\n\n    /**\n     * `mousedown` event handler on $handle\n     *  - controlSizing: resize image\n     *\n     * @param {MouseEvent} event\n     */\n    var hHandleMousedown = function (event) {\n      if (dom.isControlSizing(event.target)) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        var layoutInfo = dom.makeLayoutInfo(event.target),\n            $handle = layoutInfo.handle(),\n            $popover = layoutInfo.popover(),\n            $editable = layoutInfo.editable(),\n            $editor = layoutInfo.editor();\n\n        var target = $handle.find('.note-control-selection').data('target'),\n            $target = $(target), posStart = $target.offset(),\n            scrollTop = $document.scrollTop();\n\n        var isAirMode = $editor.data('options').airMode;\n\n        $document.on('mousemove', function (event) {\n          handler.invoke('editor.resizeTo', {\n            x: event.clientX - posStart.left,\n            y: event.clientY - (posStart.top - scrollTop)\n          }, $target, !event.shiftKey);\n\n          handler.invoke('handle.update', $handle, {image: target}, isAirMode);\n          handler.invoke('popover.update', $popover, {image: target}, isAirMode);\n        }).one('mouseup', function () {\n          $document.off('mousemove');\n          handler.invoke('editor.afterCommand', $editable);\n        });\n\n        if (!$target.data('ratio')) { // original ratio.\n          $target.data('ratio', $target.height() / $target.width());\n        }\n      }\n    };\n\n    this.attach = function (layoutInfo) {\n      layoutInfo.handle().on('mousedown', hHandleMousedown);\n    };\n\n    /**\n     * update handle\n     * @param {jQuery} $handle\n     * @param {Object} styleInfo\n     * @param {Boolean} isAirMode\n     */\n    this.update = function ($handle, styleInfo, isAirMode) {\n      var $selection = $handle.find('.note-control-selection');\n      if (styleInfo.image) {\n        var $image = $(styleInfo.image);\n        var pos = isAirMode ? $image.offset() : $image.position();\n\n        // include margin\n        var imageSize = {\n          w: $image.outerWidth(true),\n          h: $image.outerHeight(true)\n        };\n\n        $selection.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top,\n          width: imageSize.w,\n          height: imageSize.h\n        }).data('target', styleInfo.image); // save current image element.\n        var sizingText = imageSize.w + 'x' + imageSize.h;\n        $selection.find('.note-control-selection-info').text(sizingText);\n      } else {\n        $selection.hide();\n      }\n    };\n\n    /**\n     * hide\n     *\n     * @param {jQuery} $handle\n     */\n    this.hide = function ($handle) {\n      $handle.children().hide();\n    };\n  };\n\n  var Fullscreen = function (handler) {\n    var $window = $(window);\n    var $scrollbar = $('html, body');\n\n    /**\n     * toggle fullscreen\n     *\n     * @param {Object} layoutInfo\n     */\n    this.toggle = function (layoutInfo) {\n\n      var $editor = $('.annotator-widget'),//layoutInfo.editor(),\n          $toolbar = layoutInfo.toolbar(),\n          $editable = layoutInfo.editable(),\n          $codable = layoutInfo.codable(),\n          $annotatorcontrols = $('.annotator-controls:visible');\n\n      var resize = function (size) {\n        $editable.css('height', size.h);\n        $codable.css('height', size.h);\n        if ($codable.data('cmeditor')) {\n          $codable.data('cmeditor').setsize(null, size.h);\n        }\n      };\n\n      $editor.toggleClass('fullscreen');\n      var isFullscreen = $editor.hasClass('fullscreen');\n      if (isFullscreen) {\n        $editable.data('orgheight', $editable.css('height'));\n\n        $window.on('resize', function () {\n          resize({\n            h: $window.height() - $toolbar.outerHeight() - $annotatorcontrols.outerHeight() - 5 // for padding\n          });\n        }).trigger('resize');\n\n        $scrollbar.css('overflow', 'hidden');\n      } else {\n        $window.off('resize');\n        resize({\n          h: $editable.data('orgheight')\n        });\n        $scrollbar.css('overflow', 'visible');\n      }\n\n      handler.invoke('toolbar.updateFullscreen', $toolbar, isFullscreen);\n    };\n  };\n\n\n  var CodeMirror;\n  if (agent.hasCodeMirror) {\n    if (agent.isSupportAmd) {\n        CodeMirror = window.CodeMirror;\n    } else {\n      CodeMirror = window.CodeMirror;\n    }\n  }\n\n  /**\n   * @class Codeview\n   */\n  var Codeview = function (handler) {\n\n    this.sync = function (layoutInfo) {\n      var isCodeview = handler.invoke('codeview.isActivated', layoutInfo);\n      if (isCodeview && agent.hasCodeMirror) {\n        layoutInfo.codable().data('cmEditor').save();\n      }\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     * @return {Boolean}\n     */\n    this.isActivated = function (layoutInfo) {\n      var $editor = layoutInfo.editor();\n      return $editor.hasClass('codeview');\n    };\n\n    /**\n     * toggle codeview\n     *\n     * @param {Object} layoutInfo\n     */\n    this.toggle = function (layoutInfo) {\n      if (this.isActivated(layoutInfo)) {\n        this.deactivate(layoutInfo);\n      } else {\n        this.activate(layoutInfo);\n      }\n    };\n\n    /**\n     * activate code view\n     *\n     * @param {Object} layoutInfo\n     */\n    this.activate = function (layoutInfo) {\n      var $editor = layoutInfo.editor(),\n          $toolbar = layoutInfo.toolbar(),\n          $editable = layoutInfo.editable(),\n          $codable = layoutInfo.codable(),\n          $popover = layoutInfo.popover(),\n          $handle = layoutInfo.handle();\n\n      var options = $editor.data('options');\n\n      $codable.val(dom.html($editable, options.prettifyHtml));\n      $codable.height($editable.height());\n\n      handler.invoke('toolbar.updateCodeview', $toolbar, true);\n      handler.invoke('popover.hide', $popover);\n      handler.invoke('handle.hide', $handle);\n\n      $editor.addClass('codeview');\n\n      $codable.focus();\n\n      // activate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\n        // CodeMirror TernServer\n        if (options.codemirror.tern) {\n          var server = new CodeMirror.TernServer(options.codemirror.tern);\n          cmEditor.ternServer = server;\n          cmEditor.on('cursorActivity', function (cm) {\n            server.updateArgHints(cm);\n          });\n        }\n\n        // CodeMirror hasn't Padding.\n        cmEditor.setSize(null, $editable.outerHeight());\n        $codable.data('cmEditor', cmEditor);\n      }\n    };\n\n    /**\n     * deactivate code view\n     *\n     * @param {Object} layoutInfo\n     */\n    this.deactivate = function (layoutInfo) {\n      var $holder = layoutInfo.holder(),\n          $editor = layoutInfo.editor(),\n          $toolbar = layoutInfo.toolbar(),\n          $editable = layoutInfo.editable(),\n          $codable = layoutInfo.codable();\n\n      var options = $editor.data('options');\n\n      // deactivate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = $codable.data('cmEditor');\n        $codable.val(cmEditor.getValue());\n        cmEditor.toTextArea();\n      }\n\n      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n      var isChange = $editable.html() !== value;\n\n      $editable.html(value);\n      $editable.height(options.height ? $codable.height() : 'auto');\n      $editor.removeClass('codeview');\n\n      if (isChange) {\n        handler.bindCustomEvent(\n          $holder, $editable.data('callbacks'), 'change'\n        )($editable.html(), $editable);\n      }\n\n      $editable.focus();\n\n      handler.invoke('toolbar.updateCodeview', $toolbar, false);\n    };\n  };\n\n  var DragAndDrop = function (handler) {\n    var $document = $(document);\n\n    /**\n     * attach Drag and Drop Events\n     *\n     * @param {Object} layoutInfo - layout Informations\n     * @param {Object} options\n     */\n    this.attach = function (layoutInfo, options) {\n      if (options.airMode || options.disableDragAndDrop) {\n        // prevent default drop event\n        $document.on('drop', function (e) {\n          e.preventDefault();\n        });\n      } else {\n        this.attachDragAndDropEvent(layoutInfo, options);\n      }\n    };\n\n    /**\n     * attach Drag and Drop Events\n     *\n     * @param {Object} layoutInfo - layout Informations\n     * @param {Object} options\n     */\n    this.attachDragAndDropEvent = function (layoutInfo, options) {\n      var collection = $(),\n          $editor = layoutInfo.editor(),\n          $dropzone = layoutInfo.dropzone(),\n          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\n      // show dropzone on dragenter when dragging a object to document\n      // -but only if the editor is visible, i.e. has a positive width and height\n      $document.on('dragenter', function (e) {\n        var isCodeview = handler.invoke('codeview.isActivated', layoutInfo);\n        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n        if (!isCodeview && !collection.length && hasEditorSize) {\n          $editor.addClass('dragover');\n          $dropzone.width($editor.width());\n          $dropzone.height($editor.height());\n          $dropzoneMessage.text(options.langInfo.image.dragImageHere);\n        }\n        collection = collection.add(e.target);\n      }).on('dragleave', function (e) {\n        collection = collection.not(e.target);\n        if (!collection.length) {\n          $editor.removeClass('dragover');\n        }\n      }).on('drop', function () {\n        collection = $();\n        $editor.removeClass('dragover');\n      });\n\n      // change dropzone's message on hover.\n      $dropzone.on('dragenter', function () {\n        $dropzone.addClass('hover');\n        $dropzoneMessage.text(options.langInfo.image.dropImage);\n      }).on('dragleave', function () {\n        $dropzone.removeClass('hover');\n        $dropzoneMessage.text(options.langInfo.image.dragImageHere);\n      });\n\n      // attach dropImage\n      $dropzone.on('drop', function (event) {\n        event.preventDefault();\n\n        var dataTransfer = event.originalEvent.dataTransfer;\n        var html = dataTransfer.getData('text/html');\n        var text = dataTransfer.getData('text/plain');\n\n        var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);\n\n        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n          layoutInfo.editable().focus();\n          handler.insertImages(layoutInfo, dataTransfer.files);\n        } else if (html) {\n          $(html).each(function () {\n            layoutInfo.editable().focus();\n            handler.invoke('editor.insertNode', layoutInfo.editable(), this);\n          });\n        } else if (text) {\n          layoutInfo.editable().focus();\n          handler.invoke('editor.insertText', layoutInfo.editable(), text);\n        }\n      }).on('dragover', false); // prevent default dragover event\n    };\n  };\n\n  var Clipboard = function (handler) {\n\n    this.attach = function (layoutInfo) {\n      layoutInfo.editable().on('paste', hPasteClipboardImage);\n    };\n\n    /**\n     * paste clipboard image\n     *\n     * @param {Event} event\n     */\n    var hPasteClipboardImage = function (event) {\n      var clipboardData = event.originalEvent.clipboardData;\n      var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);\n      var $editable = layoutInfo.editable();\n\n      if (!clipboardData || !clipboardData.items || !clipboardData.items.length) {\n        var callbacks = $editable.data('callbacks');\n        // only can run if it has onImageUpload method\n        if (!callbacks.onImageUpload) {\n          return;\n        }\n\n        // save cursor\n        handler.invoke('editor.saveNode', $editable);\n        handler.invoke('editor.saveRange', $editable);\n\n        $editable.html('');\n\n        setTimeout(function () {\n          var $img = $editable.find('img');\n\n          // if img is no in clipboard, insert text or dom\n          if (!$img.length || $img[0].src.indexOf('data:') === -1) {\n            var html = $editable.html();\n\n            handler.invoke('editor.restoreNode', $editable);\n            handler.invoke('editor.restoreRange', $editable);\n\n            handler.invoke('editor.focus', $editable);\n            try {\n              handler.invoke('editor.pasteHTML', $editable, html);\n            } catch (ex) {\n              handler.invoke('editor.insertText', $editable, html);\n            }\n            return;\n          }\n\n          var datauri = $img[0].src;\n\n          var data = atob(datauri.split(',')[1]);\n          var array = new Uint8Array(data.length);\n          for (var i = 0; i < data.length; i++) {\n            array[i] = data.charCodeAt(i);\n          }\n\n          var blob = new Blob([array], { type : 'image/png' });\n          blob.name = 'clipboard.png';\n\n          handler.invoke('editor.restoreNode', $editable);\n          handler.invoke('editor.restoreRange', $editable);\n          handler.insertImages(layoutInfo, [blob]);\n\n          handler.invoke('editor.afterCommand', $editable);\n        }, 0);\n\n        return;\n      }\n\n      var item = list.head(clipboardData.items);\n      var isClipboardImage = item.kind === 'file' && item.type.indexOf('image/') !== -1;\n\n      if (isClipboardImage) {\n        handler.insertImages(layoutInfo, [item.getAsFile()]);\n      }\n\n      handler.invoke('editor.afterCommand', $editable);\n    };\n  };\n\n  var LinkDialog = function (handler) {\n\n    /**\n     * toggle button status\n     *\n     * @private\n     * @param {jQuery} $btn\n     * @param {Boolean} isEnable\n     */\n    var toggleBtn = function ($btn, isEnable) {\n      $btn.toggleClass('disabled', !isEnable);\n      $btn.attr('disabled', !isEnable);\n    };\n\n    /**\n     * bind enter key\n     *\n     * @private\n     * @param {jQuery} $input\n     * @param {jQuery} $btn\n     */\n    var bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    /**\n     * Show link dialog and set event handlers on dialog controls.\n     *\n     * @param {jQuery} $editable\n     * @param {jQuery} $dialog\n     * @param {Object} linkInfo\n     * @return {Promise}\n     */\n    this.showLinkDialog = function ($editable, $dialog, linkInfo) {\n      return $.Deferred(function (deferred) {\n        var $linkDialog = $dialog.find('.note-link-dialog');\n\n        var $linkText = $linkDialog.find('.note-link-text'),\n        $linkUrl = $linkDialog.find('.note-link-url'),\n        $linkBtn = $linkDialog.find('.note-link-btn'),\n        $openInNewWindow = $linkDialog.find('input[type=checkbox]');\n\n        $linkDialog.one('shown.bs.modal', function () {\n          $linkText.val(linkInfo.text);\n\n          $linkText.on('input', function () {\n            toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n            // if linktext was modified by keyup,\n            // stop cloning text from linkUrl\n            linkInfo.text = $linkText.val();\n          });\n\n          // if no url was given, copy text to url\n          if (!linkInfo.url) {\n            linkInfo.url = linkInfo.text;\n            toggleBtn($linkBtn, linkInfo.text);\n          }\n\n          $linkUrl.on('input', function () {\n            toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n            // display same link on `Text to display` input\n            // when create a new link\n            if (!linkInfo.text) {\n              $linkText.val($linkUrl.val());\n            }\n          }).val(linkInfo.url).trigger('focus').trigger('select');\n\n          bindEnterKey($linkUrl, $linkBtn);\n          bindEnterKey($linkText, $linkBtn);\n\n          $openInNewWindow.prop('checked', linkInfo.newWindow);\n\n          $linkBtn.one('click', function (event) {\n            event.preventDefault();\n\n            deferred.resolve({\n              range: linkInfo.range,\n              url: $linkUrl.val(),\n              text: $linkText.val(),\n              newWindow: $openInNewWindow.is(':checked')\n            });\n            $linkDialog.modal('hide');\n          });\n        }).one('hidden.bs.modal', function () {\n          // detach events\n          $linkText.off('input keypress');\n          $linkUrl.off('input keypress');\n          $linkBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        }).modal('show');\n      }).promise();\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     */\n    this.show = function (layoutInfo) {\n      var $editor = layoutInfo.editor(),\n          $dialog = layoutInfo.dialog(),\n          $editable = layoutInfo.editable(),\n          $popover = layoutInfo.popover(),\n          linkInfo = handler.invoke('editor.getLinkInfo', $editable);\n\n      var options = $editor.data('options');\n\n      handler.invoke('editor.saveRange', $editable);\n      this.showLinkDialog($editable, $dialog, linkInfo).then(function (linkInfo) {\n        handler.invoke('editor.restoreRange', $editable);\n        handler.invoke('editor.createLink', $editable, linkInfo, options);\n        // hide popover after creating link\n        handler.invoke('popover.hide', $popover);\n      }).fail(function () {\n        handler.invoke('editor.restoreRange', $editable);\n      });\n    };\n  };\n\n  var ImageDialog = function (handler) {\n    /**\n     * toggle button status\n     *\n     * @private\n     * @param {jQuery} $btn\n     * @param {Boolean} isEnable\n     */\n    var toggleBtn = function ($btn, isEnable) {\n      $btn.toggleClass('disabled', !isEnable);\n      $btn.attr('disabled', !isEnable);\n    };\n\n    /**\n     * bind enter key\n     *\n     * @private\n     * @param {jQuery} $input\n     * @param {jQuery} $btn\n     */\n    var bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.show = function (layoutInfo) {\n      var $dialog = layoutInfo.dialog(),\n          $editable = layoutInfo.editable();\n\n      handler.invoke('editor.saveRange', $editable);\n      this.showImageDialog($editable, $dialog).then(function (data) {\n        handler.invoke('editor.restoreRange', $editable);\n\n        if (typeof data === 'string') {\n          // image url\n          handler.invoke('editor.insertImage', $editable, data);\n        } else {\n          // array of files\n          handler.insertImages(layoutInfo, data);\n        }\n      }).fail(function () {\n        handler.invoke('editor.restoreRange', $editable);\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $editable\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showImageDialog = function ($editable, $dialog) {\n      return $.Deferred(function (deferred) {\n        var $imageDialog = $dialog.find('.note-image-dialog');\n\n        var $imageInput = $dialog.find('.note-image-input'),\n            $imageUrl = $dialog.find('.note-image-url'),\n            $imageBtn = $dialog.find('.note-image-btn');\n\n        $imageDialog.one('shown.bs.modal', function () {\n          // Cloning imageInput to clear element.\n          $imageInput.replaceWith($imageInput.clone()\n            .on('change', function () {\n              deferred.resolve(this.files || this.value);\n              $imageDialog.modal('hide');\n            })\n            .val('')\n          );\n\n          $imageBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($imageUrl.val());\n            $imageDialog.modal('hide');\n          });\n\n          $imageUrl.on('keyup paste', function (event) {\n            var url;\n            \n            if (event.type === 'paste') {\n              url = event.originalEvent.clipboardData.getData('text');\n            } else {\n              url = $imageUrl.val();\n            }\n            \n            toggleBtn($imageBtn, url);\n          }).val('').trigger('focus');\n          bindEnterKey($imageUrl, $imageBtn);\n        }).one('hidden.bs.modal', function () {\n          $imageInput.off('change');\n          $imageUrl.off('keyup paste keypress');\n          $imageBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        }).modal('show');\n      });\n    };\n  };\n\n  var HelpDialog = function (handler) {\n    /**\n     * show help dialog\n     *\n     * @param {jQuery} $editable\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showHelpDialog = function ($editable, $dialog) {\n      return $.Deferred(function (deferred) {\n        var $helpDialog = $dialog.find('.note-help-dialog');\n\n        $helpDialog.one('hidden.bs.modal', function () {\n          deferred.resolve();\n        }).modal('show');\n      }).promise();\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     */\n    this.show = function (layoutInfo) {\n      var $dialog = layoutInfo.dialog(),\n          $editable = layoutInfo.editable();\n\n      handler.invoke('editor.saveRange', $editable, true);\n      this.showHelpDialog($editable, $dialog).then(function () {\n        handler.invoke('editor.restoreRange', $editable);\n      });\n    };\n  };\n\n\n  /**\n   * @class EventHandler\n   *\n   * EventHandler\n   *  - TODO: new instance per a editor\n   */\n  var EventHandler = function () {\n    /**\n     * Modules\n     */\n    var modules = this.modules = {\n      editor: new Editor(this),\n      toolbar: new Toolbar(this),\n      statusbar: new Statusbar(this),\n      popover: new Popover(this),\n      handle: new Handle(this),\n      fullscreen: new Fullscreen(this),\n      codeview: new Codeview(this),\n      dragAndDrop: new DragAndDrop(this),\n      clipboard: new Clipboard(this),\n      linkDialog: new LinkDialog(this),\n      imageDialog: new ImageDialog(this),\n      helpDialog: new HelpDialog(this)\n    };\n\n    /**\n     * invoke module's method\n     *\n     * @param {String} moduleAndMethod - ex) 'editor.redo'\n     * @param {...*} arguments - arguments of method\n     * @return {*}\n     */\n    this.invoke = function () {\n      var moduleAndMethod = list.head(list.from(arguments));\n      var args = list.tail(list.from(arguments));\n\n      var splits = moduleAndMethod.split('.');\n      var hasSeparator = splits.length > 1;\n      var moduleName = hasSeparator && list.head(splits);\n      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\n      var module = this.getModule(moduleName);\n      var method = module[methodName];\n\n      return method && method.apply(module, args);\n    };\n\n    /**\n     * returns module\n     *\n     * @param {String} moduleName - name of module\n     * @return {Module} - defaults is editor\n     */\n    this.getModule = function (moduleName) {\n      return this.modules[moduleName] || this.modules.editor;\n    };\n\n    /**\n     * @param {jQuery} $holder\n     * @param {Object} callbacks\n     * @param {String} eventNamespace\n     * @returns {Function}\n     */\n    var bindCustomEvent = this.bindCustomEvent = function ($holder, callbacks, eventNamespace) {\n      return function () {\n        var callback = callbacks[func.namespaceToCamel(eventNamespace, 'on')];\n        if (callback) {\n          callback.apply($holder[0], arguments);\n        }\n        return $holder.trigger('summernote.' + eventNamespace, arguments);\n      };\n    };\n\n    /**\n     * insert Images from file array.\n     *\n     * @private\n     * @param {Object} layoutInfo\n     * @param {File[]} files\n     */\n    this.insertImages = function (layoutInfo, files) {\n      var $editor = layoutInfo.editor(),\n          $editable = layoutInfo.editable(),\n          $holder = layoutInfo.holder();\n\n      var callbacks = $editable.data('callbacks');\n      var options = $editor.data('options');\n\n      // If onImageUpload options setted\n      if (callbacks.onImageUpload) {\n        bindCustomEvent($holder, callbacks, 'image.upload')(files);\n      // else insert Image as dataURL\n      } else {\n        $.each(files, function (idx, file) {\n          var filename = file.name;\n          if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n            bindCustomEvent($holder, callbacks, 'image.upload.error')(options.langInfo.image.maximumFileSizeError);\n          } else {\n            async.readFileAsDataURL(file).then(function (sDataURL) {\n              modules.editor.insertImage($editable, sDataURL, filename);\n            }).fail(function () {\n              bindCustomEvent($holder, callbacks, 'image.upload.error')(options.langInfo.image.maximumFileSizeError);\n            });\n          }\n        });\n      }\n    };\n\n    var commands = {\n      /**\n       * @param {Object} layoutInfo\n       */\n      showLinkDialog: function (layoutInfo) {\n        modules.linkDialog.show(layoutInfo);\n      },\n\n      /**\n       * @param {Object} layoutInfo\n       */\n      showImageDialog: function (layoutInfo) {\n        modules.imageDialog.show(layoutInfo);\n      },\n\n      /**\n       * @param {Object} layoutInfo\n       */\n      showHelpDialog: function (layoutInfo) {\n        modules.helpDialog.show(layoutInfo);\n      },\n\n      /**\n       * @param {Object} layoutInfo\n       */\n      fullscreen: function (layoutInfo) {\n        modules.fullscreen.toggle(layoutInfo);\n      },\n\n      /**\n       * @param {Object} layoutInfo\n       */\n      codeview: function (layoutInfo) {\n        modules.codeview.toggle(layoutInfo);\n      }\n    };\n\n    var hMousedown = function (event) {\n      //preventDefault Selection for FF, IE8+\n      if (dom.isImg(event.target)) {\n        event.preventDefault();\n      }\n    };\n\n    var hKeyupAndMouseup = function (event) {\n      var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);\n      modules.editor.removeBogus(layoutInfo.editable());\n      hToolbarAndPopoverUpdate(event);\n    };\n\n    var hToolbarAndPopoverUpdate = function (event) {\n      // delay for range after mouseup\n      setTimeout(function () {\n        var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);\n        var styleInfo = modules.editor.currentStyle(event.target);\n        if (!styleInfo) { return; }\n\n        var isAirMode = layoutInfo.editor().data('options').airMode;\n        if (!isAirMode) {\n          modules.toolbar.update(layoutInfo.toolbar(), styleInfo);\n        }\n\n        modules.popover.update(layoutInfo.popover(), styleInfo, isAirMode);\n        modules.handle.update(layoutInfo.handle(), styleInfo, isAirMode);\n      }, 0);\n    };\n\n    var hScrollAndBlur = function (event) {\n      var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);\n      //hide popover and handle when scrolled\n      modules.popover.hide(layoutInfo.popover());\n      modules.handle.hide(layoutInfo.handle());\n    };\n\n    var hToolbarAndPopoverMousedown = function (event) {\n      // prevent default event when insertTable (FF, Webkit)\n      var $btn = $(event.target).closest('[data-event]');\n      if ($btn.length) {\n        event.preventDefault();\n      }\n    };\n\n    var hToolbarAndPopoverClick = function (event) {\n      var $btn = $(event.target).closest('[data-event]');\n\n      if ($btn.length) {\n        var eventName = $btn.attr('data-event'),\n            value = $btn.attr('data-value'),\n            hide = $btn.attr('data-hide');\n\n        var layoutInfo = dom.makeLayoutInfo(event.target);\n\n        // before command: detect control selection element($target)\n        var $target;\n        if ($.inArray(eventName, ['resize', 'floatMe', 'removeMedia', 'imageShape']) !== -1) {\n          var $selection = layoutInfo.handle().find('.note-control-selection');\n          $target = $($selection.data('target'));\n        }\n\n        // If requested, hide the popover when the button is clicked.\n        // Useful for things like showHelpDialog.\n        if (hide) {\n          $btn.parents('.popover').hide();\n        }\n\n        if ($.isFunction($.summernote.pluginEvents[eventName])) {\n          $.summernote.pluginEvents[eventName](event, modules.editor, layoutInfo, value);\n        } else if (modules.editor[eventName]) { // on command\n          var $editable = layoutInfo.editable();\n          $editable.focus();\n          modules.editor[eventName]($editable, value, $target);\n          event.preventDefault();\n        } else if (commands[eventName]) {\n          commands[eventName].call(this, layoutInfo);\n          event.preventDefault();\n        }\n\n        // after command\n        if ($.inArray(eventName, ['backColor', 'foreColor']) !== -1) {\n          var options = layoutInfo.editor().data('options', options);\n          var module = options.airMode ? modules.popover : modules.toolbar;\n          module.updateRecentColor(list.head($btn), eventName, value);\n        }\n\n        hToolbarAndPopoverUpdate(event);\n      }\n    };\n\n    var PX_PER_EM = 18;\n    var hDimensionPickerMove = function (event, options) {\n      var $picker = $(event.target.parentNode); // target is mousecatcher\n      var $dimensionDisplay = $picker.next();\n      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\n      var posOffset;\n      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n      if (event.offsetX === undefined) {\n        var posCatcher = $(event.target).offset();\n        posOffset = {\n          x: event.pageX - posCatcher.left,\n          y: event.pageY - posCatcher.top\n        };\n      } else {\n        posOffset = {\n          x: event.offsetX,\n          y: event.offsetY\n        };\n      }\n\n      var dim = {\n        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n      };\n\n      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n      $catcher.attr('data-value', dim.c + 'x' + dim.r);\n\n      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n      }\n\n      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n      }\n\n      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n    };\n    \n    /**\n     * bind KeyMap on keydown\n     *\n     * @param {Object} layoutInfo\n     * @param {Object} keyMap\n     */\n    this.bindKeyMap = function (layoutInfo, keyMap) {\n      var $editor = layoutInfo.editor();\n      var $editable = layoutInfo.editable();\n\n      $editable.on('keydown', function (event) {\n        var keys = [];\n\n        // modifier\n        if (event.metaKey) { keys.push('CMD'); }\n        if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n        if (event.shiftKey) { keys.push('SHIFT'); }\n\n        // keycode\n        var keyName = key.nameFromCode[event.keyCode];\n        if (keyName) {\n          keys.push(keyName);\n        }\n\n        var pluginEvent;\n        var keyString = keys.join('+');\n        var eventName = keyMap[keyString];\n        if (eventName) {\n          // FIXME Summernote doesn't support event pipeline yet.\n          //  - Plugin -> Base Code\n          pluginEvent = $.summernote.pluginEvents[keyString];\n          if ($.isFunction(pluginEvent)) {\n            if (pluginEvent(event, modules.editor, layoutInfo)) {\n              return false;\n            }\n          }\n\n          pluginEvent = $.summernote.pluginEvents[eventName];\n\n          if ($.isFunction(pluginEvent)) {\n            pluginEvent(event, modules.editor, layoutInfo);\n          } else if (modules.editor[eventName]) {\n            modules.editor[eventName]($editable, $editor.data('options'));\n            event.preventDefault();\n          } else if (commands[eventName]) {\n            commands[eventName].call(this, layoutInfo);\n            event.preventDefault();\n          }\n        } else if (key.isEdit(event.keyCode)) {\n          modules.editor.afterCommand($editable);\n        }\n      });\n    };\n\n    /**\n     * attach eventhandler\n     *\n     * @param {Object} layoutInfo - layout Informations\n     * @param {Object} options - user options include custom event handlers\n     */\n    this.attach = function (layoutInfo, options) {\n      // handlers for editable\n      if (options.shortcuts) {\n        this.bindKeyMap(layoutInfo, options.keyMap[agent.isMac ? 'mac' : 'pc']);\n      }\n      layoutInfo.editable().on('mousedown', hMousedown);\n      layoutInfo.editable().on('keyup mouseup', hKeyupAndMouseup);\n      layoutInfo.editable().on('scroll blur', hScrollAndBlur);\n\n      // handler for clipboard\n      modules.clipboard.attach(layoutInfo, options);\n\n      // handler for handle and popover\n      modules.handle.attach(layoutInfo, options);\n      layoutInfo.popover().on('click', hToolbarAndPopoverClick);\n      layoutInfo.popover().on('mousedown', hToolbarAndPopoverMousedown);\n\n      // handler for drag and drop\n      modules.dragAndDrop.attach(layoutInfo, options);\n\n      // handlers for frame mode (toolbar, statusbar)\n      if (!options.airMode) {\n        // handler for toolbar\n        layoutInfo.toolbar().on('click', hToolbarAndPopoverClick);\n        layoutInfo.toolbar().on('mousedown', hToolbarAndPopoverMousedown);\n\n        // handler for statusbar\n        modules.statusbar.attach(layoutInfo, options);\n      }\n\n      // handler for table dimension\n      var $catcherContainer = options.airMode ? layoutInfo.popover() :\n                                                layoutInfo.toolbar();\n      var $catcher = $catcherContainer.find('.note-dimension-picker-mousecatcher');\n      $catcher.css({\n        width: options.insertTableMaxSize.col + 'em',\n        height: options.insertTableMaxSize.row + 'em'\n      }).on('mousemove', function (event) {\n        hDimensionPickerMove(event, options);\n      });\n\n      // save options on editor\n      layoutInfo.editor().data('options', options);\n\n      // ret styleWithCSS for backColor / foreColor clearing with 'inherit'.\n      if (!agent.isMSIE) {\n        // [workaround] for Firefox\n        //  - protect FF Error: NS_ERROR_FAILURE: Failure\n        setTimeout(function () {\n          document.execCommand('styleWithCSS', 0, options.styleWithSpan);\n        }, 0);\n      }\n\n      // History\n      var history = new History(layoutInfo.editable());\n      layoutInfo.editable().data('NoteHistory', history);\n\n      // All editor status will be saved on editable with jquery's data\n      // for support multiple editor with singleton object.\n      layoutInfo.editable().data('callbacks', {\n        onInit: options.onInit,\n        onFocus: options.onFocus,\n        onBlur: options.onBlur,\n        onKeydown: options.onKeydown,\n        onKeyup: options.onKeyup,\n        onMousedown: options.onMousedown,\n        onEnter: options.onEnter,\n        onPaste: options.onPaste,\n        onBeforeCommand: options.onBeforeCommand,\n        onChange: options.onChange,\n        onImageUpload: options.onImageUpload,\n        onImageUploadError: options.onImageUploadError,\n        onMediaDelete : options.onMediaDelete\n      });\n\n      // Textarea: auto filling the code before form submit.\n      if (dom.isTextarea(list.head(layoutInfo.holder()))) {\n        layoutInfo.holder().closest('form').submit(function () {\n          layoutInfo.holder().val(layoutInfo.holder().code());\n        });\n      }\n    };\n\n    /**\n     * attach jquery custom event\n     *\n     * @param {Object} layoutInfo - layout Informations\n     */\n    this.attachCustomEvent = function (layoutInfo, options) {\n      var $holder = layoutInfo.holder();\n      var $editable = layoutInfo.editable();\n      var callbacks = $editable.data('callbacks');\n\n      $editable.focus(bindCustomEvent($holder, callbacks, 'focus'));\n      $editable.blur(bindCustomEvent($holder, callbacks, 'blur'));\n\n      $editable.keydown(function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          bindCustomEvent($holder, callbacks, 'enter').call(this, event);\n        }\n        bindCustomEvent($holder, callbacks, 'keydown').call(this, event);\n      });\n      $editable.keyup(bindCustomEvent($holder, callbacks, 'keyup'));\n\n      $editable.on('mousedown', bindCustomEvent($holder, callbacks, 'mousedown'));\n      $editable.on('mouseup', bindCustomEvent($holder, callbacks, 'mouseup'));\n      $editable.on('scroll', bindCustomEvent($holder, callbacks, 'scroll'));\n\n      $editable.on('paste', bindCustomEvent($holder, callbacks, 'paste'));\n      \n      // [workaround] for old IE - IE8 don't have input events\n      //  - TODO check IE version\n      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n      $editable.on(changeEventName, function () {\n        bindCustomEvent($holder, callbacks, 'change')($editable.html(), $editable);\n      });\n\n      if (!options.airMode) {\n        layoutInfo.toolbar().click(bindCustomEvent($holder, callbacks, 'toolbar.click'));\n        layoutInfo.popover().click(bindCustomEvent($holder, callbacks, 'popover.click'));\n      }\n\n      // Textarea: auto filling the code before form submit.\n      if (dom.isTextarea(list.head($holder))) {\n        $holder.closest('form').submit(function (e) {\n          bindCustomEvent($holder, callbacks, 'submit').call(this, e, $holder.code());\n        });\n      }\n\n      // fire init event\n      bindCustomEvent($holder, callbacks, 'init')(layoutInfo);\n\n      // fire plugin init event\n      for (var i = 0, len = $.summernote.plugins.length; i < len; i++) {\n        if ($.isFunction($.summernote.plugins[i].init)) {\n          $.summernote.plugins[i].init(layoutInfo);\n        }\n      }\n    };\n      \n    this.detach = function (layoutInfo, options) {\n      layoutInfo.holder().off();\n      layoutInfo.editable().off();\n\n      layoutInfo.popover().off();\n      layoutInfo.handle().off();\n      layoutInfo.dialog().off();\n\n      if (!options.airMode) {\n        layoutInfo.dropzone().off();\n        layoutInfo.toolbar().off();\n        layoutInfo.statusbar().off();\n      }\n    };\n  };\n\n  /**\n   * @class Renderer\n   *\n   * renderer\n   *\n   * rendering toolbar and editable\n   */\n  var Renderer = function () {\n\n    /**\n     * bootstrap button template\n     * @private\n     * @param {String} label button name\n     * @param {Object} [options] button options\n     * @param {String} [options.event] data-event\n     * @param {String} [options.className] button's class name\n     * @param {String} [options.value] data-value\n     * @param {String} [options.title] button's title for popup\n     * @param {String} [options.dropdown] dropdown html\n     * @param {String} [options.hide] data-hide\n     */\n    var tplButton = function (label, options) {\n      var event = options.event;\n      var value = options.value;\n      var title = options.title;\n      var className = options.className;\n      var dropdown = options.dropdown;\n      var hide = options.hide;\n\n      return '<button type=\"button\"' +\n                 ' class=\"btn btn-default btn-sm btn-small' +\n                   (className ? ' ' + className : '') +\n                   (dropdown ? ' dropdown-toggle' : '') +\n                 '\"' +\n                 (dropdown ? ' data-toggle=\"dropdown\"' : '') +\n                 (title ? ' title=\"' + title + '\"' : '') +\n                 (event ? ' data-event=\"' + event + '\"' : '') +\n                 (value ? ' data-value=\\'' + value + '\\'' : '') +\n                 (hide ? ' data-hide=\\'' + hide + '\\'' : '') +\n                 ' tabindex=\"-1\">' +\n               label +\n               (dropdown ? ' <span class=\"caret\"></span>' : '') +\n             '</button>' +\n             (dropdown || '');\n    };\n\n    /**\n     * bootstrap icon button template\n     * @private\n     * @param {String} iconClassName\n     * @param {Object} [options]\n     * @param {String} [options.event]\n     * @param {String} [options.value]\n     * @param {String} [options.title]\n     * @param {String} [options.dropdown]\n     */\n    var tplIconButton = function (iconClassName, options) {\n      var label = '<i class=\"' + iconClassName + '\"></i>';\n      return tplButton(label, options);\n    };\n\n    /**\n     * bootstrap popover template\n     * @private\n     * @param {String} className\n     * @param {String} content\n     */\n    var tplPopover = function (className, content) {\n      var $popover = $('<div class=\"' + className + ' popover bottom in\" style=\"display: none;\">' +\n               '<div class=\"arrow\"></div>' +\n               '<div class=\"popover-content\">' +\n               '</div>' +\n             '</div>');\n      \n      $popover.find('.popover-content').append(content);\n      return $popover;\n    };\n\n    /**\n     * bootstrap dialog template\n     *\n     * @param {String} className\n     * @param {String} [title='']\n     * @param {String} body\n     * @param {String} [footer='']\n     */\n    var tplDialog = function (className, title, body, footer) {\n      return '<div class=\"' + className + ' modal\" aria-hidden=\"false\">' +\n               '<div class=\"modal-dialog\">' +\n                 '<div class=\"modal-content\">' +\n                   (title ?\n                   '<div class=\"modal-header\">' +\n                     '<button type=\"button\" class=\"close\" aria-hidden=\"true\" tabindex=\"-1\">&times;</button>' +\n                     '<h4 class=\"modal-title\">' + title + '</h4>' +\n                   '</div>' : ''\n                   ) +\n                   '<div class=\"modal-body\">' + body + '</div>' +\n                   (footer ?\n                   '<div class=\"modal-footer\">' + footer + '</div>' : ''\n                   ) +\n                 '</div>' +\n               '</div>' +\n             '</div>';\n    };\n\n    var tplButtonInfo = {\n      picture: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'picture-o', {\n          event: 'showImageDialog',\n          title: lang.image.image,\n          hide: true\n        });\n      },\n      link: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'link', {\n          event: 'showLinkDialog',\n          title: lang.link.link,\n          hide: true\n        });\n      },\n      table: function (lang, options) {\n        var dropdown = '<ul class=\"note-table dropdown-menu\">' +\n                         '<div class=\"note-dimension-picker\">' +\n                           '<div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"></div>' +\n                           '<div class=\"note-dimension-picker-highlighted\"></div>' +\n                           '<div class=\"note-dimension-picker-unhighlighted\"></div>' +\n                         '</div>' +\n                         '<div class=\"note-dimension-display\"> 1 x 1 </div>' +\n                       '</ul>';\n        return tplIconButton(options.iconPrefix + 'table', {\n          title: lang.table.table,\n          dropdown: dropdown\n        });\n      },\n      style: function (lang, options) {\n        var items = options.styleTags.reduce(function (memo, v) {\n          var label = lang.style[v === 'p' ? 'normal' : v];\n          return memo + '<li><a data-event=\"formatBlock\" href=\"#\" data-value=\"' + v + '\">' +\n                   (\n                     (v === 'p' || v === 'pre') ? label :\n                     '<' + v + '>' + label + '</' + v + '>'\n                   ) +\n                 '</a></li>';\n        }, '');\n\n        return tplIconButton(options.iconPrefix + 'magic', {\n          title: lang.style.style,\n          dropdown: '<ul class=\"dropdown-menu\">' + items + '</ul>'\n        });\n      },\n      fontname: function (lang, options) {\n        var realFontList = [];\n        var items = options.fontNames.reduce(function (memo, v) {\n          if (!agent.isFontInstalled(v) && options.fontNamesIgnoreCheck.indexOf(v) === -1) {\n            return memo;\n          }\n          realFontList.push(v);\n          return memo + '<li><a data-event=\"fontName\" href=\"#\" data-value=\"' + v + '\" style=\"font-family:\\'' + v + '\\'\">' +\n                          '<i class=\"' + options.iconPrefix + 'check\"></i> ' + v +\n                        '</a></li>';\n        }, '');\n\n        var hasDefaultFont = agent.isFontInstalled(options.defaultFontName);\n        var defaultFontName = (hasDefaultFont) ? options.defaultFontName : realFontList[0];\n          \n        var label = '<span class=\"note-current-fontname\">' +\n                        defaultFontName +\n                     '</span>';\n        return tplButton(label, {\n          title: lang.font.name,\n          dropdown: '<ul class=\"dropdown-menu note-check\">' + items + '</ul>'\n        });\n      },\n      fontsize: function (lang, options) {\n        var items = options.fontSizes.reduce(function (memo, v) {\n          return memo + '<li><a data-event=\"fontSize\" href=\"#\" data-value=\"' + v + '\">' +\n                          '<i class=\"fa fa-check\"></i> ' + v +\n                        '</a></li>';\n        }, '');\n\n        var label = '<span class=\"note-current-fontsize\">11</span>';\n        return tplButton(label, {\n          title: lang.font.size,\n          dropdown: '<ul class=\"dropdown-menu note-check\">' + items + '</ul>'\n        });\n      },\n      color: function (lang, options) {\n        var colorButtonLabel = '<i class=\"' + options.iconPrefix + 'font\" style=\"color:black;background-color:yellow;\"></i>';\n        var colorButton = tplButton(colorButtonLabel, {\n          className: 'note-recent-color',\n          title: lang.color.recent,\n          event: 'color',\n          value: '{\"backColor\":\"yellow\"}'\n        });\n\n        var dropdown = '<ul class=\"dropdown-menu\">' +\n                         '<li>' +\n                           '<div class=\"btn-group\">' +\n                             '<div class=\"note-palette-title\">' + lang.color.background + '</div>' +\n                             '<div class=\"note-color-reset\" data-event=\"backColor\"' +\n                               ' data-value=\"inherit\" title=\"' + lang.color.transparent + '\">' +\n                               lang.color.setTransparent +\n                             '</div>' +\n                             '<div class=\"note-color-palette\" data-target-event=\"backColor\"></div>' +\n                           '</div>' +\n                           '<div class=\"btn-group\">' +\n                             '<div class=\"note-palette-title\">' + lang.color.foreground + '</div>' +\n                             '<div class=\"note-color-reset\" data-event=\"foreColor\" data-value=\"inherit\" title=\"' + lang.color.reset + '\">' +\n                               lang.color.resetToDefault +\n                             '</div>' +\n                             '<div class=\"note-color-palette\" data-target-event=\"foreColor\"></div>' +\n                           '</div>' +\n                         '</li>' +\n                       '</ul>';\n\n        var moreButton = tplButton('', {\n          title: lang.color.more,\n          dropdown: dropdown\n        });\n\n        return colorButton + moreButton;\n      },\n      bold: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'bold', {\n          event: 'bold',\n          title: lang.font.bold\n        });\n      },\n      italic: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'italic', {\n          event: 'italic',\n          title: lang.font.italic\n        });\n      },\n      underline: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'underline', {\n          event: 'underline',\n          title: lang.font.underline\n        });\n      },\n      strikethrough: function (lang) {\n        return tplIconButton('fa fa-strikethrough', {\n          event: 'strikethrough',\n          title: lang.font.strikethrough\n        });\n      },\n      superscript: function (lang) {\n        return tplIconButton('fa fa-superscript', {\n          event: 'superscript',\n          title: lang.font.superscript\n        });\n      },\n      subscript: function (lang) {\n        return tplIconButton('fa fa-subscript', {\n          event: 'subscript',\n          title: lang.font.subscript\n        });\n      },\n      clear: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'eraser', {\n          event: 'removeFormat',\n          title: lang.font.clear\n        });\n      },\n      ul: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'list-ul', {\n          event: 'insertUnorderedList',\n          title: lang.lists.unordered\n        });\n      },\n      ol: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'list-ol', {\n          event: 'insertOrderedList',\n          title: lang.lists.ordered\n        });\n      },\n      paragraph: function (lang, options) {\n        var leftButton = tplIconButton(options.iconPrefix + 'align-left', {\n          title: lang.paragraph.left,\n          event: 'justifyLeft'\n        });\n        var centerButton = tplIconButton(options.iconPrefix + 'align-center', {\n          title: lang.paragraph.center,\n          event: 'justifyCenter'\n        });\n        var rightButton = tplIconButton(options.iconPrefix + 'align-right', {\n          title: lang.paragraph.right,\n          event: 'justifyRight'\n        });\n        var justifyButton = tplIconButton(options.iconPrefix + 'align-justify', {\n          title: lang.paragraph.justify,\n          event: 'justifyFull'\n        });\n\n        var outdentButton = tplIconButton(options.iconPrefix + 'outdent', {\n          title: lang.paragraph.outdent,\n          event: 'outdent'\n        });\n        var indentButton = tplIconButton(options.iconPrefix + 'indent', {\n          title: lang.paragraph.indent,\n          event: 'indent'\n        });\n\n        var dropdown = '<div class=\"dropdown-menu\">' +\n                         '<div class=\"note-align btn-group\">' +\n                           leftButton + centerButton + rightButton + justifyButton +\n                         '</div>' +\n                         '<div class=\"note-list btn-group\">' +\n                           indentButton + outdentButton +\n                         '</div>' +\n                       '</div>';\n\n        return tplIconButton(options.iconPrefix + 'align-left', {\n          title: lang.paragraph.paragraph,\n          dropdown: dropdown\n        });\n      },\n      height: function (lang, options) {\n        var items = options.lineHeights.reduce(function (memo, v) {\n          return memo + '<li><a data-event=\"lineHeight\" href=\"#\" data-value=\"' + parseFloat(v) + '\">' +\n                          '<i class=\"' + options.iconPrefix + 'check\"></i> ' + v +\n                        '</a></li>';\n        }, '');\n\n        return tplIconButton(options.iconPrefix + 'text-height', {\n          title: lang.font.height,\n          dropdown: '<ul class=\"dropdown-menu note-check\">' + items + '</ul>'\n        });\n\n      },\n      help: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'question', {\n          event: 'showHelpDialog',\n          title: lang.options.help,\n          hide: true\n        });\n      },\n      fullscreen: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'arrows-alt', {\n          event: 'fullscreen',\n          title: lang.options.fullscreen\n        });\n      },\n      codeview: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'code', {\n          event: 'codeview',\n          title: lang.options.codeview\n        });\n      },\n      undo: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'undo', {\n          event: 'undo',\n          title: lang.history.undo\n        });\n      },\n      redo: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'repeat', {\n          event: 'redo',\n          title: lang.history.redo\n        });\n      },\n      hr: function (lang, options) {\n        return tplIconButton(options.iconPrefix + 'minus', {\n          event: 'insertHorizontalRule',\n          title: lang.hr.insert\n        });\n      }\n    };\n\n    var tplPopovers = function (lang, options) {\n      var tplLinkPopover = function () {\n        var linkButton = tplIconButton(options.iconPrefix + 'edit', {\n          title: lang.link.edit,\n          event: 'showLinkDialog',\n          hide: true\n        });\n        var unlinkButton = tplIconButton(options.iconPrefix + 'unlink', {\n          title: lang.link.unlink,\n          event: 'unlink'\n        });\n        var content = '<a href=\"http://www.google.com\" target=\"_blank\">www.google.com</a>&nbsp;&nbsp;' +\n                      '<div class=\"note-insert btn-group\">' +\n                        linkButton + unlinkButton +\n                      '</div>';\n        return tplPopover('note-link-popover', content);\n      };\n\n      var tplImagePopover = function () {\n        var fullButton = tplButton('<span class=\"note-fontsize-10\">100%</span>', {\n          title: lang.image.resizeFull,\n          event: 'resize',\n          value: '1'\n        });\n        var halfButton = tplButton('<span class=\"note-fontsize-10\">50%</span>', {\n          title: lang.image.resizeHalf,\n          event: 'resize',\n          value: '0.5'\n        });\n        var quarterButton = tplButton('<span class=\"note-fontsize-10\">25%</span>', {\n          title: lang.image.resizeQuarter,\n          event: 'resize',\n          value: '0.25'\n        });\n\n        var leftButton = tplIconButton(options.iconPrefix + 'align-left', {\n          title: lang.image.floatLeft,\n          event: 'floatMe',\n          value: 'left'\n        });\n        var rightButton = tplIconButton(options.iconPrefix + 'align-right', {\n          title: lang.image.floatRight,\n          event: 'floatMe',\n          value: 'right'\n        });\n        var justifyButton = tplIconButton(options.iconPrefix + 'align-justify', {\n          title: lang.image.floatNone,\n          event: 'floatMe',\n          value: 'none'\n        });\n\n        var roundedButton = tplIconButton(options.iconPrefix + 'square', {\n          title: lang.image.shapeRounded,\n          event: 'imageShape',\n          value: 'img-rounded'\n        });\n        var circleButton = tplIconButton(options.iconPrefix + 'circle-o', {\n          title: lang.image.shapeCircle,\n          event: 'imageShape',\n          value: 'img-circle'\n        });\n        var thumbnailButton = tplIconButton(options.iconPrefix + 'picture-o', {\n          title: lang.image.shapeThumbnail,\n          event: 'imageShape',\n          value: 'img-thumbnail'\n        });\n        var noneButton = tplIconButton(options.iconPrefix + 'times', {\n          title: lang.image.shapeNone,\n          event: 'imageShape',\n          value: ''\n        });\n\n        var removeButton = tplIconButton(options.iconPrefix + 'trash-o', {\n          title: lang.image.remove,\n          event: 'removeMedia',\n          value: 'none'\n        });\n\n        var content = '<div class=\"btn-group\">' + fullButton + halfButton + quarterButton + '</div>' +\n                      '<div class=\"btn-group\">' + leftButton + rightButton + justifyButton + '</div>' +\n                      '<div class=\"btn-group\">' + roundedButton + circleButton + thumbnailButton + noneButton + '</div>' +\n                      '<div class=\"btn-group\">' + removeButton + '</div>';\n        return tplPopover('note-image-popover', content);\n      };\n\n      var tplAirPopover = function () {\n        var $content = $('<div />');\n        for (var idx = 0, len = options.airPopover.length; idx < len; idx ++) {\n          var group = options.airPopover[idx];\n          \n          var $group = $('<div class=\"note-' + group[0] + ' btn-group\">');\n          for (var i = 0, lenGroup = group[1].length; i < lenGroup; i++) {\n            var $button = $(tplButtonInfo[group[1][i]](lang, options));\n\n            $button.attr('data-name', group[1][i]);\n            \n            $group.append($button);\n          }\n          $content.append($group);\n        }\n\n        return tplPopover('note-air-popover', $content.children());\n      };\n\n      var $notePopover = $('<div class=\"note-popover\" />');\n      \n      $notePopover.append(tplLinkPopover());\n      $notePopover.append(tplImagePopover());\n      \n      if (options.airMode) {\n        $notePopover.append(tplAirPopover());\n      }\n      \n      return $notePopover;\n    };\n\n    var tplHandles = function () {\n      return '<div class=\"note-handle\">' +\n               '<div class=\"note-control-selection\">' +\n                 '<div class=\"note-control-selection-bg\"></div>' +\n                 '<div class=\"note-control-holder note-control-nw\"></div>' +\n                 '<div class=\"note-control-holder note-control-ne\"></div>' +\n                 '<div class=\"note-control-holder note-control-sw\"></div>' +\n                 '<div class=\"note-control-sizing note-control-se\"></div>' +\n                 '<div class=\"note-control-selection-info\"></div>' +\n               '</div>' +\n             '</div>';\n    };\n\n    /**\n     * shortcut table template\n     * @param {String} title\n     * @param {String} body\n     */\n    var tplShortcut = function (title, keys) {\n      var keyClass = 'note-shortcut-col col-xs-6 note-shortcut-';\n      var body = [];\n\n      for (var i in keys) {\n        if (keys.hasOwnProperty(i)) {\n          body.push(\n            '<div class=\"' + keyClass + 'key\">' + keys[i].kbd + '</div>' +\n            '<div class=\"' + keyClass + 'name\">' + keys[i].text + '</div>'\n            );\n        }\n      }\n\n      return '<div class=\"note-shortcut-row row\"><div class=\"' + keyClass + 'title col-xs-offset-6\">' + title + '</div></div>' +\n             '<div class=\"note-shortcut-row row\">' + body.join('</div><div class=\"note-shortcut-row row\">') + '</div>';\n    };\n\n    var tplShortcutText = function (lang) {\n      var keys = [\n        { kbd: ' + B', text: lang.font.bold },\n        { kbd: ' + I', text: lang.font.italic },\n        { kbd: ' + U', text: lang.font.underline },\n        { kbd: ' + \\\\', text: lang.font.clear }\n      ];\n\n      return tplShortcut(lang.shortcut.textFormatting, keys);\n    };\n\n    var tplShortcutAction = function (lang) {\n      var keys = [\n        { kbd: ' + Z', text: lang.history.undo },\n        { kbd: ' +  + Z', text: lang.history.redo },\n        { kbd: ' + ]', text: lang.paragraph.indent },\n        { kbd: ' + [', text: lang.paragraph.outdent },\n        { kbd: ' + ENTER', text: lang.hr.insert }\n      ];\n\n      return tplShortcut(lang.shortcut.action, keys);\n    };\n\n    var tplShortcutPara = function (lang) {\n      var keys = [\n        { kbd: ' +  + L', text: lang.paragraph.left },\n        { kbd: ' +  + E', text: lang.paragraph.center },\n        { kbd: ' +  + R', text: lang.paragraph.right },\n        { kbd: ' +  + J', text: lang.paragraph.justify },\n        { kbd: ' +  + NUM7', text: lang.lists.ordered },\n        { kbd: ' +  + NUM8', text: lang.lists.unordered }\n      ];\n\n      return tplShortcut(lang.shortcut.paragraphFormatting, keys);\n    };\n\n    var tplShortcutStyle = function (lang) {\n      var keys = [\n        { kbd: ' + NUM0', text: lang.style.normal },\n        { kbd: ' + NUM1', text: lang.style.h1 },\n        { kbd: ' + NUM2', text: lang.style.h2 },\n        { kbd: ' + NUM3', text: lang.style.h3 },\n        { kbd: ' + NUM4', text: lang.style.h4 },\n        { kbd: ' + NUM5', text: lang.style.h5 },\n        { kbd: ' + NUM6', text: lang.style.h6 }\n      ];\n\n      return tplShortcut(lang.shortcut.documentStyle, keys);\n    };\n\n    var tplExtraShortcuts = function (lang, options) {\n      var extraKeys = options.extraKeys;\n      var keys = [];\n\n      for (var key in extraKeys) {\n        if (extraKeys.hasOwnProperty(key)) {\n          keys.push({ kbd: key, text: extraKeys[key] });\n        }\n      }\n\n      return tplShortcut(lang.shortcut.extraKeys, keys);\n    };\n\n    var tplShortcutTable = function (lang, options) {\n      var colClass = 'class=\"note-shortcut note-shortcut-col col-sm-6 col-xs-12\"';\n      var template = [\n        '<div ' + colClass + '>' + tplShortcutAction(lang, options) + '</div>' +\n        '<div ' + colClass + '>' + tplShortcutText(lang, options) + '</div>',\n        '<div ' + colClass + '>' + tplShortcutStyle(lang, options) + '</div>' +\n        '<div ' + colClass + '>' + tplShortcutPara(lang, options) + '</div>'\n      ];\n\n      if (options.extraKeys) {\n        template.push('<div ' + colClass + '>' + tplExtraShortcuts(lang, options) + '</div>');\n      }\n\n      return '<div class=\"note-shortcut-row row\">' +\n               template.join('</div><div class=\"note-shortcut-row row\">') +\n             '</div>';\n    };\n\n    var replaceMacKeys = function (sHtml) {\n      return sHtml.replace(//g, 'Ctrl').replace(//g, 'Shift');\n    };\n\n    var tplDialogInfo = {\n      image: function (lang, options) {\n        var imageLimitation = '';\n        if (options.maximumImageFileSize) {\n          var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n          var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n                             ' ' + ' KMGTP'[unit] + 'B';\n          imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n        }\n\n        var body = '<div class=\"form-group row-fluid note-group-select-from-files\">' +\n                     '<label>' + lang.image.selectFromFiles + '</label>' +\n                     '<input class=\"note-image-input\" type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n                     imageLimitation +\n                   '</div>' +\n                   '<div class=\"form-group row-fluid\">' +\n                     '<label>' + lang.image.url + '</label>' +\n                     '<input class=\"note-image-url form-control span12\" type=\"text\" />' +\n                   '</div>';\n        var footer = '<button href=\"#\" class=\"btn btn-primary note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n        return tplDialog('note-image-dialog', lang.image.insert, body, footer);\n      },\n\n      link: function (lang, options) {\n        var body = '<div class=\"form-group row-fluid\">' +\n                     '<label>' + lang.link.textToDisplay + '</label>' +\n                     '<input class=\"note-link-text form-control span12\" type=\"text\" />' +\n                   '</div>' +\n                   '<div class=\"form-group row-fluid\">' +\n                     '<label>' + lang.link.url + '</label>' +\n                     '<input class=\"note-link-url form-control span12\" type=\"text\" />' +\n                   '</div>' +\n                   (!options.disableLinkTarget ?\n                     '<div class=\"checkbox\">' +\n                       '<label>' + '<input type=\"checkbox\" checked> ' +\n                         lang.link.openInNewWindow +\n                       '</label>' +\n                     '</div>' : ''\n                   );\n        var footer = '<button href=\"#\" class=\"btn btn-primary note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n        return tplDialog('note-link-dialog', lang.link.insert, body, footer);\n      },\n\n      help: function (lang, options) {\n        var body = '<a class=\"modal-close pull-right\" aria-hidden=\"true\" tabindex=\"-1\">' + lang.shortcut.close + '</a>' +\n                   '<div class=\"title\">' + lang.shortcut.shortcuts + '</div>' +\n                   (agent.isMac ? tplShortcutTable(lang, options) : replaceMacKeys(tplShortcutTable(lang, options))) +\n                   '<p class=\"text-center\">' +\n                     '<a href=\"//summernote.org/\" target=\"_blank\">Summernote 0.6.7</a>  ' +\n                     '<a href=\"//github.com/summernote/summernote\" target=\"_blank\">Project</a>  ' +\n                     '<a href=\"//github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>' +\n                   '</p>';\n        return tplDialog('note-help-dialog', '', body, '');\n      }\n    };\n\n    var tplDialogs = function (lang, options) {\n      var dialogs = '';\n\n      $.each(tplDialogInfo, function (idx, tplDialog) {\n        dialogs += tplDialog(lang, options);\n      });\n\n      return '<div class=\"note-dialog\">' + dialogs + '</div>';\n    };\n\n    var tplStatusbar = function () {\n      return '<div class=\"note-resizebar\">' +\n               '<div class=\"note-icon-bar\"></div>' +\n               '<div class=\"note-icon-bar\"></div>' +\n               '<div class=\"note-icon-bar\"></div>' +\n             '</div>';\n    };\n\n    var representShortcut = function (str) {\n      if (agent.isMac) {\n        str = str.replace('CMD', '').replace('SHIFT', '');\n      }\n\n      return str.replace('BACKSLASH', '\\\\')\n                .replace('SLASH', '/')\n                .replace('LEFTBRACKET', '[')\n                .replace('RIGHTBRACKET', ']');\n    };\n\n    /**\n     * createTooltip\n     *\n     * @param {jQuery} $container\n     * @param {Object} keyMap\n     * @param {String} [sPlacement]\n     */\n    __webpack_require__(/*! bootstrap/js/dist/tooltip */ \"./node_modules/bootstrap/js/dist/tooltip.js\");\n    var createTooltip = function ($container, keyMap, sPlacement) {\n      var invertedKeyMap = func.invertObject(keyMap);\n      var $buttons = $container.find('button');\n\n      $buttons.each(function (i, elBtn) {\n        var $btn = $(elBtn);\n        var sShortcut = invertedKeyMap[$btn.data('event')];\n        if (sShortcut) {\n          $btn.attr('title', function (i, v) {\n            return v + ' (' + representShortcut(sShortcut) + ')';\n          });\n        }\n      // bootstrap tooltip on btn-group bug\n      // https://github.com/twbs/bootstrap/issues/5687\n      }).tooltip({\n        container: 'body',\n        trigger: 'hover',\n        placement: sPlacement || 'top'\n      }).on('click', function () {\n        $(this).tooltip('hide');\n      });\n    };\n\n    // createPalette\n    var createPalette = function ($container, options) {\n      var colorInfo = options.colors;\n      $container.find('.note-color-palette').each(function () {\n        var $palette = $(this), eventName = $palette.attr('data-target-event');\n        var paletteContents = [];\n        for (var row = 0, lenRow = colorInfo.length; row < lenRow; row++) {\n          var colors = colorInfo[row];\n          var buttons = [];\n          for (var col = 0, lenCol = colors.length; col < lenCol; col++) {\n            var color = colors[col];\n            buttons.push(['<button type=\"button\" class=\"note-color-btn\" style=\"background-color:', color,\n                           ';\" data-event=\"', eventName,\n                           '\" data-value=\"', color,\n                           '\" title=\"', color,\n                           '\" data-toggle=\"button\" tabindex=\"-1\"></button>'].join(''));\n          }\n          paletteContents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n        }\n        $palette.html(paletteContents.join(''));\n      });\n    };\n\n    /**\n     * create summernote layout (air mode)\n     *\n     * @param {jQuery} $holder\n     * @param {Object} options\n     */\n    this.createLayoutByAirMode = function ($holder, options) {\n      var langInfo = options.langInfo;\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      var id = func.uniqueId();\n\n      $holder.addClass('note-air-editor note-editable');\n      $holder.attr({\n        'id': 'note-editor-' + id,\n        'contentEditable': true\n      });\n\n      var body = document.body;\n\n      // create Popover\n      var $popover = $(tplPopovers(langInfo, options));\n      $popover.addClass('note-air-layout');\n      $popover.attr('id', 'note-popover-' + id);\n      $popover.appendTo(body);\n      createTooltip($popover, keyMap);\n      createPalette($popover, options);\n\n      // create Handle\n      var $handle = $(tplHandles());\n      $handle.addClass('note-air-layout');\n      $handle.attr('id', 'note-handle-' + id);\n      $handle.appendTo(body);\n\n      // create Dialog\n      var $dialog = $(tplDialogs(langInfo, options));\n      $dialog.addClass('note-air-layout');\n      $dialog.attr('id', 'note-dialog-' + id);\n      $dialog.find('button.close, a.modal-close').click(function () {\n        $(this).closest('.modal').modal('hide');\n      });\n      $dialog.appendTo(body);\n    };\n\n    /**\n     * create summernote layout (normal mode)\n     *\n     * @param {jQuery} $holder\n     * @param {Object} options\n     */\n    this.createLayoutByFrame = function ($holder, options) {\n      var langInfo = options.langInfo;\n\n      //01. create Editor\n      var $editor = $('<div class=\"note-editor\"></div>');\n      if (options.width) {\n        $editor.width(options.width);\n      }\n\n      //02. statusbar (resizebar)\n      if (options.height > 0) {\n        $('<div class=\"note-statusbar\">' + (options.disableResizeEditor ? '' : tplStatusbar()) + '</div>').prependTo($editor);\n      }\n\n      //03. create Editable\n      var isContentEditable = !$holder.is(':disabled');\n      var $editable = $('<div class=\"note-editable\" contentEditable=\"' + isContentEditable + '\"></div>')\n          .prependTo($editor);\n      if (options.height) {\n        $editable.height(options.height);\n      }\n      if (options.direction) {\n        $editable.attr('dir', options.direction);\n      }\n      var placeholder = $holder.attr('placeholder') || options.placeholder;\n      if (placeholder) {\n        $editable.attr('data-placeholder', placeholder);\n      }\n\n      $editable.html(dom.html($holder));\n\n      //031. create codable\n      $('<textarea class=\"note-codable\"></textarea>').prependTo($editor);\n\n      //04. create Toolbar\n      var $toolbar = $('<div class=\"note-toolbar btn-toolbar\" />');\n      for (var idx = 0, len = options.toolbar.length; idx < len; idx ++) {\n        var groupName = options.toolbar[idx][0];\n        var groupButtons = options.toolbar[idx][1];\n\n        var $group = $('<div class=\"note-' + groupName + ' btn-group\" />');\n        for (var i = 0, btnLength = groupButtons.length; i < btnLength; i++) {\n          var buttonInfo = tplButtonInfo[groupButtons[i]];\n          // continue creating toolbar even if a button doesn't exist\n          if (!$.isFunction(buttonInfo)) { continue; }\n\n          var $button = $(buttonInfo(langInfo, options));\n          $button.attr('data-name', groupButtons[i]);  // set button's alias, becuase to get button element from $toolbar\n          $group.append($button);\n        }\n        $toolbar.append($group);\n      }\n      \n      $toolbar.prependTo($editor);\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      createPalette($toolbar, options);\n      createTooltip($toolbar, keyMap, 'bottom');\n\n      //05. create Popover\n      var $popover = $(tplPopovers(langInfo, options)).prependTo($editor);\n      createPalette($popover, options);\n      createTooltip($popover, keyMap);\n\n      //06. handle(control selection, ...)\n      $(tplHandles()).prependTo($editor);\n\n      //07. create Dialog\n      var $dialog = $(tplDialogs(langInfo, options)).prependTo($editor);\n      $dialog.find('button.close, a.modal-close').click(function () {\n        $(this).closest('.modal').modal('hide');\n      });\n\n      //08. create Dropzone\n      $('<div class=\"note-dropzone\"><div class=\"note-dropzone-message\"></div></div>').prependTo($editor);\n\n      //09. Editor/Holder switch\n      $editor.insertAfter($holder);\n      $holder.hide();\n    };\n\n    this.hasNoteEditor = function ($holder) {\n      return this.noteEditorFromHolder($holder).length > 0;\n    };\n\n    this.noteEditorFromHolder = function ($holder) {\n      if ($holder.hasClass('note-air-editor')) {\n        return $holder;\n      } else if ($holder.next().hasClass('note-editor')) {\n        return $holder.next();\n      } else {\n        return $();\n      }\n    };\n\n    /**\n     * create summernote layout\n     *\n     * @param {jQuery} $holder\n     * @param {Object} options\n     */\n    this.createLayout = function ($holder, options) {\n      if (options.airMode) {\n        this.createLayoutByAirMode($holder, options);\n      } else {\n        this.createLayoutByFrame($holder, options);\n      }\n    };\n\n    /**\n     * returns layoutInfo from holder\n     *\n     * @param {jQuery} $holder - placeholder\n     * @return {Object}\n     */\n    this.layoutInfoFromHolder = function ($holder) {\n      var $editor = this.noteEditorFromHolder($holder);\n      if (!$editor.length) {\n        return;\n      }\n\n      // connect $holder to $editor\n      $editor.data('holder', $holder);\n\n      return dom.buildLayoutInfo($editor);\n    };\n\n    /**\n     * removeLayout\n     *\n     * @param {jQuery} $holder - placeholder\n     * @param {Object} layoutInfo\n     * @param {Object} options\n     *\n     */\n    this.removeLayout = function ($holder, layoutInfo, options) {\n      if (options.airMode) {\n        $holder.removeClass('note-air-editor note-editable')\n               .removeAttr('id contentEditable');\n\n        layoutInfo.popover().remove();\n        layoutInfo.handle().remove();\n        layoutInfo.dialog().remove();\n      } else {\n        $holder.html(layoutInfo.editable().html());\n\n        layoutInfo.editor().remove();\n        $holder.show();\n      }\n    };\n\n    /**\n     *\n     * @return {Object}\n     * @return {function(label, options=):string} return.button {@link #tplButton function to make text button}\n     * @return {function(iconClass, options=):string} return.iconButton {@link #tplIconButton function to make icon button}\n     * @return {function(className, title=, body=, footer=):string} return.dialog {@link #tplDialog function to make dialog}\n     */\n    this.getTemplate = function () {\n      return {\n        button: tplButton,\n        iconButton: tplIconButton,\n        dialog: tplDialog\n      };\n    };\n\n    /**\n     * add button information\n     *\n     * @param {String} name button name\n     * @param {Function} buttonInfo function to make button, reference to {@link #tplButton},{@link #tplIconButton}\n     */\n    this.addButtonInfo = function (name, buttonInfo) {\n      tplButtonInfo[name] = buttonInfo;\n    };\n\n    /**\n     *\n     * @param {String} name\n     * @param {Function} dialogInfo function to make dialog, reference to {@link #tplDialog}\n     */\n    this.addDialogInfo = function (name, dialogInfo) {\n      tplDialogInfo[name] = dialogInfo;\n    };\n  };\n\n\n  // jQuery namespace for summernote\n  /**\n   * @class $.summernote \n   * \n   * summernote attribute  \n   * \n   * @mixin defaults\n   * @singleton  \n   * \n   */\n  $.summernote = $.summernote || {};\n\n  // extends default settings\n  //  - $.summernote.version\n  //  - $.summernote.options\n  //  - $.summernote.lang\n  $.extend($.summernote, defaults);\n\n  var renderer = new Renderer();\n  var eventHandler = new EventHandler();\n\n  $.extend($.summernote, {\n    /** @property {Renderer} */\n    renderer: renderer,\n    /** @property {EventHandler} */\n    eventHandler: eventHandler,\n    /** \n     * @property {Object} core \n     * @property {core.agent} core.agent \n     * @property {core.dom} core.dom\n     * @property {core.range} core.range \n     */\n    core: {\n      agent: agent,\n      list : list,\n      dom: dom,\n      range: range\n    },\n    /** \n     * @property {Object} \n     * pluginEvents event list for plugins\n     * event has name and callback function.\n     * \n     * ``` \n     * $.summernote.addPlugin({\n     *     events : {\n     *          'hello' : function(layoutInfo, value, $target) {\n     *              console.log('event name is hello, value is ' + value );\n     *          }\n     *     }     \n     * })\n     * ```\n     * \n     * * event name is data-event property.\n     * * layoutInfo is a summernote layout information.\n     * * value is data-value property.\n     */\n    pluginEvents: {},\n\n    plugins : []\n  });\n\n  /**\n   * @method addPlugin\n   *\n   * add Plugin in Summernote \n   * \n   * Summernote can make a own plugin.\n   *\n   * ### Define plugin\n   * ```\n   * // get template function  \n   * var tmpl = $.summernote.renderer.getTemplate();\n   * \n   * // add a button   \n   * $.summernote.addPlugin({\n   *     buttons : {\n   *        // \"hello\"  is button's namespace.      \n   *        \"hello\" : function(lang, options) {\n   *            // make icon button by template function          \n   *            return tmpl.iconButton('fa fa-header', {\n   *                // callback function name when button clicked \n   *                event : 'hello',\n   *                // set data-value property                 \n   *                value : 'hello',                \n   *                hide : true\n   *            });           \n   *        }\n   *     \n   *     }, \n   *     \n   *     events : {\n   *        \"hello\" : function(layoutInfo, value) {\n   *            // here is event code \n   *        }\n   *     }     \n   * });\n   * ``` \n   * ### Use a plugin in toolbar\n   * \n   * ``` \n   *    $(\"#editor\").summernote({\n   *    ...\n   *    toolbar : [\n   *        // display hello plugin in toolbar     \n   *        ['group', [ 'hello' ]]\n   *    ]\n   *    ...    \n   *    });\n   * ```\n   *  \n   *  \n   * @param {Object} plugin\n   * @param {Object} [plugin.buttons] define plugin button. for detail, see to Renderer.addButtonInfo\n   * @param {Object} [plugin.dialogs] define plugin dialog. for detail, see to Renderer.addDialogInfo\n   * @param {Object} [plugin.events] add event in $.summernote.pluginEvents \n   * @param {Object} [plugin.langs] update $.summernote.lang\n   * @param {Object} [plugin.options] update $.summernote.options\n   */\n  $.summernote.addPlugin = function (plugin) {\n\n    // save plugin list\n    $.summernote.plugins.push(plugin);\n\n    if (plugin.buttons) {\n      $.each(plugin.buttons, function (name, button) {\n        renderer.addButtonInfo(name, button);\n      });\n    }\n\n    if (plugin.dialogs) {\n      $.each(plugin.dialogs, function (name, dialog) {\n        renderer.addDialogInfo(name, dialog);\n      });\n    }\n\n    if (plugin.events) {\n      $.each(plugin.events, function (name, event) {\n        $.summernote.pluginEvents[name] = event;\n      });\n    }\n\n    if (plugin.langs) {\n      $.each(plugin.langs, function (locale, lang) {\n        if ($.summernote.lang[locale]) {\n          $.extend($.summernote.lang[locale], lang);\n        }\n      });\n    }\n\n    if (plugin.options) {\n      $.extend($.summernote.options, plugin.options);\n    }\n  };\n\n  /*\n   * extend $.fn\n   */\n  $.fn.extend({\n    /**\n     * @method\n     * Initialize summernote\n     *  - create editor layout and attach Mouse and keyboard events.\n     * \n     * ```\n     * $(\"#summernote\").summernote( { options ..} );\n     * ```\n     *   \n     * @member $.fn\n     * @param {Object|String} options reference to $.summernote.options\n     * @return {this}\n     */\n    summernote: function () {\n      // check first argument's type\n      //  - {String}: External API call {{module}}.{{method}}\n      //  - {Object}: init options\n      var type = $.type(list.head(arguments));\n      var isExternalAPICalled = type === 'string';\n      var hasInitOptions = type === 'object';\n\n      // extend default options with custom user options\n      var options = hasInitOptions ? list.head(arguments) : {};\n\n      options = $.extend({}, $.summernote.options, options);\n\n      // Include langInfo in options for later use, e.g. for image drag-n-drop\n      // Setup language info with en-US as default\n      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n\n      // override plugin options\n      if (!isExternalAPICalled && hasInitOptions) {\n        for (var i = 0, len = $.summernote.plugins.length; i < len; i++) {\n          var plugin = $.summernote.plugins[i];\n\n          if (options.plugin[plugin.name]) {\n            $.summernote.plugins[i] = $.extend(true, plugin, options.plugin[plugin.name]);\n          }\n        }\n      }\n\n      this.each(function (idx, holder) {\n        var $holder = $(holder);\n\n        // if layout isn't created yet, createLayout and attach events\n        if (!renderer.hasNoteEditor($holder)) {\n          renderer.createLayout($holder, options);\n\n          var layoutInfo = renderer.layoutInfoFromHolder($holder);\n          $holder.data('layoutInfo', layoutInfo);\n\n          eventHandler.attach(layoutInfo, options);\n          eventHandler.attachCustomEvent(layoutInfo, options);\n\n        }\n      });\n\n      var $first = this.first();\n      if ($first.length) {\n        var layoutInfo = renderer.layoutInfoFromHolder($first);\n\n        // external API\n        if (isExternalAPICalled) {\n          var moduleAndMethod = list.head(list.from(arguments));\n          var args = list.tail(list.from(arguments));\n\n          // TODO now external API only works for editor\n          var params = [moduleAndMethod, layoutInfo.editable()].concat(args);\n          return eventHandler.invoke.apply(eventHandler, params);\n        } else if (options.focus) {\n          // focus on first editable element for initialize editor\n          layoutInfo.editable().focus();\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * @method \n     * \n     * get the HTML contents of note or set the HTML contents of note.\n     *\n     * * get contents \n     * ```\n     * var content = $(\"#summernote\").code();\n     * ```\n     * * set contents \n     *\n     * ```\n     * $(\"#summernote\").code(html);\n     * ```\n     *\n     * @member $.fn \n     * @param {String} [html] - HTML contents(optional, set)\n     * @return {this|String} - context(set) or HTML contents of note(get).\n     */\n    code: function (html) {\n      // get the HTML contents of note\n      if (html === undefined) {\n        var $holder = this.first();\n        if (!$holder.length) {\n          return;\n        }\n\n        var layoutInfo = renderer.layoutInfoFromHolder($holder);\n        var $editable = layoutInfo && layoutInfo.editable();\n\n        if ($editable && $editable.length) {\n          var isCodeview = eventHandler.invoke('codeview.isActivated', layoutInfo);\n          eventHandler.invoke('codeview.sync', layoutInfo);\n          return isCodeview ? layoutInfo.codable().val() :\n                              layoutInfo.editable().html();\n        }\n        return dom.value($holder);\n      }\n\n      // set the HTML contents of note\n      this.each(function (i, holder) {\n        var layoutInfo = renderer.layoutInfoFromHolder($(holder));\n        var $editable = layoutInfo && layoutInfo.editable();\n        if ($editable) {\n          $editable.html(html);\n        }\n      });\n\n      return this;\n    },\n\n    /**\n     * @method\n     * \n     * destroy Editor Layout and detach Key and Mouse Event\n     *\n     * @member $.fn\n     * @return {this}\n     */\n    destroy: function () {\n      this.each(function (idx, holder) {\n        var $holder = $(holder);\n\n        if (!renderer.hasNoteEditor($holder)) {\n          return;\n        }\n\n        var info = renderer.layoutInfoFromHolder($holder);\n        var options = info.editor().data('options');\n\n        eventHandler.detach(info, options);\n        renderer.removeLayout($holder, info, options);\n      });\n\n      return this;\n    }\n  });\n}));\n\n\n//# sourceURL=webpack:///./src/edited/summernote_for_hxatlite.js?");

/***/ }),

/***/ "./src/static/css/annotation_base.css":
/*!********************************************!*\
  !*** ./src/static/css/annotation_base.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/css/annotation_base.css?");

/***/ }),

/***/ "./src/static/css/instructions.css":
/*!*****************************************!*\
  !*** ./src/static/css/instructions.css ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/css/instructions.css?");

/***/ }),

/***/ "./src/static/vendors/Annotator/annotator-full.js":
/*!********************************************************!*\
  !*** ./src/static/vendors/Annotator/annotator-full.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/*\n** Annotator v1.2.10\n** https://github.com/okfn/annotator/\n**\n** Copyright 2015, the Annotator project contributors.\n** Dual licensed under the MIT and GPLv3 licenses.\n** https://github.com/okfn/annotator/blob/master/LICENSE\n**\n** Built at: 2015-02-26 03:26:47Z\n */\n\n\n//\n\n// Generated by CoffeeScript 1.6.3\n(function() {\n  var $, Annotator, Delegator, LinkParser, Range, Util, base64Decode, base64UrlDecode, createDateFromISO8601, findChild, fn, functions, g, getNodeName, getNodePosition, gettext, parseToken, simpleXPathJQuery, simpleXPathPure, _Annotator, _gettext, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _t,\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  simpleXPathJQuery = function(relativeRoot) {\n    var jq;\n    jq = this.map(function() {\n      var elem, idx, path, tagName;\n      path = '';\n      elem = this;\n      while ((elem != null ? elem.nodeType : void 0) === Node.ELEMENT_NODE && elem !== relativeRoot) {\n        tagName = elem.tagName.replace(\":\", \"\\\\:\");\n        idx = $(elem.parentNode).children(tagName).index(elem) + 1;\n        idx = \"[\" + idx + \"]\";\n        path = \"/\" + elem.tagName.toLowerCase() + idx + path;\n        elem = elem.parentNode;\n      }\n      return path;\n    });\n    return jq.get();\n  };\n\n  simpleXPathPure = function(relativeRoot) {\n    var getPathSegment, getPathTo, jq, rootNode;\n    getPathSegment = function(node) {\n      var name, pos;\n      name = getNodeName(node);\n      pos = getNodePosition(node);\n      return \"\" + name + \"[\" + pos + \"]\";\n    };\n    rootNode = relativeRoot;\n    getPathTo = function(node) {\n      var xpath;\n      xpath = '';\n      while (node !== rootNode) {\n        if (node == null) {\n          throw new Error(\"Called getPathTo on a node which was not a descendant of @rootNode. \" + rootNode);\n        }\n        xpath = (getPathSegment(node)) + '/' + xpath;\n        node = node.parentNode;\n      }\n      xpath = '/' + xpath;\n      xpath = xpath.replace(/\\/$/, '');\n      return xpath;\n    };\n    jq = this.map(function() {\n      var path;\n      path = getPathTo(this);\n      return path;\n    });\n    return jq.get();\n  };\n\n  findChild = function(node, type, index) {\n    var child, children, found, name, _i, _len;\n    if (!node.hasChildNodes()) {\n      throw new Error(\"XPath error: node has no children!\");\n    }\n    children = node.childNodes;\n    found = 0;\n    for (_i = 0, _len = children.length; _i < _len; _i++) {\n      child = children[_i];\n      name = getNodeName(child);\n      if (name === type) {\n        found += 1;\n        if (found === index) {\n          return child;\n        }\n      }\n    }\n    throw new Error(\"XPath error: wanted child not found.\");\n  };\n\n  getNodeName = function(node) {\n    var nodeName;\n    nodeName = node.nodeName.toLowerCase();\n    switch (nodeName) {\n      case \"#text\":\n        return \"text()\";\n      case \"#comment\":\n        return \"comment()\";\n      case \"#cdata-section\":\n        return \"cdata-section()\";\n      default:\n        return nodeName;\n    }\n  };\n\n  getNodePosition = function(node) {\n    var pos, tmp;\n    pos = 0;\n    tmp = node;\n    while (tmp) {\n      if (tmp.nodeName === node.nodeName) {\n        pos++;\n      }\n      tmp = tmp.previousSibling;\n    }\n    return pos;\n  };\n\n  gettext = null;\n\n  if (typeof Gettext !== \"undefined\" && Gettext !== null) {\n    _gettext = new Gettext({\n      domain: \"annotator\"\n    });\n    gettext = function(msgid) {\n      return _gettext.gettext(msgid);\n    };\n  } else {\n    gettext = function(msgid) {\n      return msgid;\n    };\n  }\n\n  _t = function(msgid) {\n    return gettext(msgid);\n  };\n\n  if (!(typeof jQuery !== \"undefined\" && jQuery !== null ? (_ref = jQuery.fn) != null ? _ref.jquery : void 0 : void 0)) {\n    console.error(_t(\"Annotator requires jQuery: have you included lib/vendor/jquery.js?\"));\n  }\n\n  if (!(JSON && JSON.parse && JSON.stringify)) {\n    console.error(_t(\"Annotator requires a JSON implementation: have you included lib/vendor/json2.js?\"));\n  }\n\n  $ = jQuery;\n\n  Util = {};\n\n  Util.flatten = function(array) {\n    var flatten;\n    flatten = function(ary) {\n      var el, flat, _i, _len;\n      flat = [];\n      for (_i = 0, _len = ary.length; _i < _len; _i++) {\n        el = ary[_i];\n        flat = flat.concat(el && $.isArray(el) ? flatten(el) : el);\n      }\n      return flat;\n    };\n    return flatten(array);\n  };\n\n  Util.contains = function(parent, child) {\n    var node;\n    node = child;\n    while (node != null) {\n      if (node === parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  };\n\n  Util.getTextNodes = function(jq) {\n    var getTextNodes;\n    getTextNodes = function(node) {\n      var nodes;\n      if (node && node.nodeType !== Node.TEXT_NODE) {\n        nodes = [];\n        if (node.nodeType !== Node.COMMENT_NODE) {\n          node = node.lastChild;\n          while (node) {\n            nodes.push(getTextNodes(node));\n            node = node.previousSibling;\n          }\n        }\n        return nodes.reverse();\n      } else {\n        return node;\n      }\n    };\n    return jq.map(function() {\n      return Util.flatten(getTextNodes(this));\n    });\n  };\n\n  Util.getLastTextNodeUpTo = function(n) {\n    var result;\n    switch (n.nodeType) {\n      case Node.TEXT_NODE:\n        return n;\n      case Node.ELEMENT_NODE:\n        if (n.lastChild != null) {\n          result = Util.getLastTextNodeUpTo(n.lastChild);\n          if (result != null) {\n            return result;\n          }\n        }\n        break;\n    }\n    n = n.previousSibling;\n    if (n != null) {\n      return Util.getLastTextNodeUpTo(n);\n    } else {\n      return null;\n    }\n  };\n\n  Util.getFirstTextNodeNotBefore = function(n) {\n    var result;\n    switch (n.nodeType) {\n      case Node.TEXT_NODE:\n        return n;\n      case Node.ELEMENT_NODE:\n        if (n.firstChild != null) {\n          result = Util.getFirstTextNodeNotBefore(n.firstChild);\n          if (result != null) {\n            return result;\n          }\n        }\n        break;\n    }\n    n = n.nextSibling;\n    if (n != null) {\n      return Util.getFirstTextNodeNotBefore(n);\n    } else {\n      return null;\n    }\n  };\n\n  Util.readRangeViaSelection = function(range) {\n    var sel;\n    sel = Util.getGlobal().getSelection();\n    sel.removeAllRanges();\n    sel.addRange(range.toRange());\n    return sel.toString();\n  };\n\n  Util.xpathFromNode = function(el, relativeRoot) {\n    var exception, result;\n    try {\n      result = simpleXPathJQuery.call(el, relativeRoot);\n    } catch (_error) {\n      exception = _error;\n      console.log(\"jQuery-based XPath construction failed! Falling back to manual.\");\n      result = simpleXPathPure.call(el, relativeRoot);\n    }\n    return result;\n  };\n\n  Util.nodeFromXPath = function(xp, root) {\n    var idx, name, node, step, steps, _i, _len, _ref1;\n    steps = xp.substring(1).split(\"/\");\n    node = root;\n    for (_i = 0, _len = steps.length; _i < _len; _i++) {\n      step = steps[_i];\n      _ref1 = step.split(\"[\"), name = _ref1[0], idx = _ref1[1];\n      idx = idx != null ? parseInt((idx != null ? idx.split(\"]\") : void 0)[0]) : 1;\n      node = findChild(node, name.toLowerCase(), idx);\n    }\n    return node;\n  };\n\n  Util.escape = function(html) {\n    return html.replace(/&(?!\\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n  };\n\n  Util.uuid = (function() {\n    var counter;\n    counter = 0;\n    return function() {\n      return counter++;\n    };\n  })();\n\n  Util.getGlobal = function() {\n    return (function() {\n      return this;\n    })();\n  };\n\n  Util.maxZIndex = function($elements) {\n    var all, el;\n    all = (function() {\n      var _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = $elements.length; _i < _len; _i++) {\n        el = $elements[_i];\n        if ($(el).css('position') === 'static') {\n          _results.push(-1);\n        } else {\n          _results.push(parseFloat($(el).css('z-index')) || -1);\n        }\n      }\n      return _results;\n    })();\n    return Math.max.apply(Math, all);\n  };\n\n  Util.mousePosition = function(e, offsetEl) {\n    var offset, _ref1;\n    if ((_ref1 = $(offsetEl).css('position')) !== 'absolute' && _ref1 !== 'fixed' && _ref1 !== 'relative') {\n      offsetEl = $(offsetEl).offsetParent()[0];\n    }\n    offset = $(offsetEl).offset();\n    return {\n      top: e.pageY - offset.top,\n      left: e.pageX - offset.left\n    };\n  };\n\n  Util.preventEventDefault = function(event) {\n    return event != null ? typeof event.preventDefault === \"function\" ? event.preventDefault() : void 0 : void 0;\n  };\n\n  functions = [\"log\", \"debug\", \"info\", \"warn\", \"exception\", \"assert\", \"dir\", \"dirxml\", \"trace\", \"group\", \"groupEnd\", \"groupCollapsed\", \"time\", \"timeEnd\", \"profile\", \"profileEnd\", \"count\", \"clear\", \"table\", \"error\", \"notifyFirebug\", \"firebug\", \"userObjects\"];\n\n  if (typeof console !== \"undefined\" && console !== null) {\n    if (console.group == null) {\n      console.group = function(name) {\n        return console.log(\"GROUP: \", name);\n      };\n    }\n    if (console.groupCollapsed == null) {\n      console.groupCollapsed = console.group;\n    }\n    for (_i = 0, _len = functions.length; _i < _len; _i++) {\n      fn = functions[_i];\n      if (console[fn] == null) {\n        console[fn] = function() {\n          return console.log(_t(\"Not implemented:\") + (\" console.\" + name));\n        };\n      }\n    }\n  } else {\n    this.console = {};\n    for (_j = 0, _len1 = functions.length; _j < _len1; _j++) {\n      fn = functions[_j];\n      this.console[fn] = function() {};\n    }\n    this.console['error'] = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return alert(\"ERROR: \" + (args.join(', ')));\n    };\n    this.console['warn'] = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return alert(\"WARNING: \" + (args.join(', ')));\n    };\n  }\n\n  Delegator = (function() {\n    Delegator.prototype.events = {};\n\n    Delegator.prototype.options = {};\n\n    Delegator.prototype.element = null;\n\n    function Delegator(element, options) {\n      this.options = $.extend(true, {}, this.options, options);\n      this.element = $(element);\n      this._closures = {};\n      this.on = this.subscribe;\n      this.addEvents();\n    }\n\n    Delegator.prototype.destroy = function() {\n      return this.removeEvents();\n    };\n\n    Delegator.prototype.addEvents = function() {\n      var event, _k, _len2, _ref1, _results;\n      _ref1 = Delegator._parseEvents(this.events);\n      _results = [];\n      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n        event = _ref1[_k];\n        _results.push(this._addEvent(event.selector, event.event, event.functionName));\n      }\n      return _results;\n    };\n\n    Delegator.prototype.removeEvents = function() {\n      var event, _k, _len2, _ref1, _results;\n      _ref1 = Delegator._parseEvents(this.events);\n      _results = [];\n      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n        event = _ref1[_k];\n        _results.push(this._removeEvent(event.selector, event.event, event.functionName));\n      }\n      return _results;\n    };\n\n    Delegator.prototype._addEvent = function(selector, event, functionName) {\n      var closure,\n        _this = this;\n      closure = function() {\n        return _this[functionName].apply(_this, arguments);\n      };\n      if (selector === '' && Delegator._isCustomEvent(event)) {\n        this.subscribe(event, closure);\n      } else {\n        this.element.delegate(selector, event, closure);\n      }\n      this._closures[\"\" + selector + \"/\" + event + \"/\" + functionName] = closure;\n      return this;\n    };\n\n    Delegator.prototype._removeEvent = function(selector, event, functionName) {\n      var closure;\n      closure = this._closures[\"\" + selector + \"/\" + event + \"/\" + functionName];\n      if (selector === '' && Delegator._isCustomEvent(event)) {\n        this.unsubscribe(event, closure);\n      } else {\n        this.element.undelegate(selector, event, closure);\n      }\n      delete this._closures[\"\" + selector + \"/\" + event + \"/\" + functionName];\n      return this;\n    };\n\n    Delegator.prototype.publish = function() {\n      this.element.triggerHandler.apply(this.element, arguments);\n      return this;\n    };\n\n    Delegator.prototype.subscribe = function(event, callback) {\n      var closure;\n      closure = function() {\n        return callback.apply(this, [].slice.call(arguments, 1));\n      };\n      closure.guid = callback.guid = ($.guid += 1);\n      this.element.bind(event, closure);\n      return this;\n    };\n\n    Delegator.prototype.unsubscribe = function() {\n      this.element.unbind.apply(this.element, arguments);\n      return this;\n    };\n\n    return Delegator;\n\n  })();\n\n  Delegator._parseEvents = function(eventsObj) {\n    var event, events, functionName, sel, selector, _k, _ref1;\n    events = [];\n    for (sel in eventsObj) {\n      functionName = eventsObj[sel];\n      _ref1 = sel.split(' '), selector = 2 <= _ref1.length ? __slice.call(_ref1, 0, _k = _ref1.length - 1) : (_k = 0, []), event = _ref1[_k++];\n      events.push({\n        selector: selector.join(' '),\n        event: event,\n        functionName: functionName\n      });\n    }\n    return events;\n  };\n\n  Delegator.natives = (function() {\n    var key, specials, val;\n    specials = (function() {\n      var _ref1, _results;\n      _ref1 = jQuery.event.special;\n      _results = [];\n      for (key in _ref1) {\n        if (!__hasProp.call(_ref1, key)) continue;\n        val = _ref1[key];\n        _results.push(key);\n      }\n      return _results;\n    })();\n    return \"blur focus focusin focusout load resize scroll unload click dblclick\\nmousedown mouseup mousemove mouseover mouseout mouseenter mouseleave\\nchange select submit keydown keypress keyup error\".split(/[^a-z]+/).concat(specials);\n  })();\n\n  Delegator._isCustomEvent = function(event) {\n    event = event.split('.')[0];\n    return $.inArray(event, Delegator.natives) === -1;\n  };\n\n  Range = {};\n\n  Range.sniff = function(r) {\n    if (r.commonAncestorContainer != null) {\n      return new Range.BrowserRange(r);\n    } else if (typeof r.start === \"string\") {\n      return new Range.SerializedRange(r);\n    } else if (r.start && typeof r.start === \"object\") {\n      return new Range.NormalizedRange(r);\n    } else {\n      console.error(_t(\"Could not sniff range type\"));\n      return false;\n    }\n  };\n\n  Range.nodeFromXPath = function(xpath, root) {\n    var customResolver, evaluateXPath, namespace, node, segment;\n    if (root == null) {\n      root = document;\n    }\n    evaluateXPath = function(xp, nsResolver) {\n      var exception;\n      if (nsResolver == null) {\n        nsResolver = null;\n      }\n      try {\n        return document.evaluate('.' + xp, root, nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n      } catch (_error) {\n        exception = _error;\n        console.log(\"XPath evaluation failed.\");\n        console.log(\"Trying fallback...\");\n        return Util.nodeFromXPath(xp, root);\n      }\n    };\n    if (!$.isXMLDoc(document.documentElement)) {\n      return evaluateXPath(xpath);\n    } else {\n      customResolver = document.createNSResolver(document.ownerDocument === null ? document.documentElement : document.ownerDocument.documentElement);\n      node = evaluateXPath(xpath, customResolver);\n      if (!node) {\n        xpath = ((function() {\n          var _k, _len2, _ref1, _results;\n          _ref1 = xpath.split('/');\n          _results = [];\n          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n            segment = _ref1[_k];\n            if (segment && segment.indexOf(':') === -1) {\n              _results.push(segment.replace(/^([a-z]+)/, 'xhtml:$1'));\n            } else {\n              _results.push(segment);\n            }\n          }\n          return _results;\n        })()).join('/');\n        namespace = document.lookupNamespaceURI(null);\n        customResolver = function(ns) {\n          if (ns === 'xhtml') {\n            return namespace;\n          } else {\n            return document.documentElement.getAttribute('xmlns:' + ns);\n          }\n        };\n        node = evaluateXPath(xpath, customResolver);\n      }\n      return node;\n    }\n  };\n\n  Range.RangeError = (function(_super) {\n    __extends(RangeError, _super);\n\n    function RangeError(type, message, parent) {\n      this.type = type;\n      this.message = message;\n      this.parent = parent != null ? parent : null;\n      RangeError.__super__.constructor.call(this, this.message);\n    }\n\n    return RangeError;\n\n  })(Error);\n\n  Range.BrowserRange = (function() {\n    function BrowserRange(obj) {\n      this.commonAncestorContainer = obj.commonAncestorContainer;\n      this.startContainer = obj.startContainer;\n      this.startOffset = obj.startOffset;\n      this.endContainer = obj.endContainer;\n      this.endOffset = obj.endOffset;\n    }\n\n    BrowserRange.prototype.normalize = function(root) {\n      var n, node, nr, r;\n      if (this.tainted) {\n        console.error(_t(\"You may only call normalize() once on a BrowserRange!\"));\n        return false;\n      } else {\n        this.tainted = true;\n      }\n      r = {};\n      if (this.startContainer.nodeType === Node.ELEMENT_NODE) {\n        r.start = Util.getFirstTextNodeNotBefore(this.startContainer.childNodes[this.startOffset]);\n        r.startOffset = 0;\n      } else {\n        r.start = this.startContainer;\n        r.startOffset = this.startOffset;\n      }\n      if (this.endContainer.nodeType === Node.ELEMENT_NODE) {\n        node = this.endContainer.childNodes[this.endOffset];\n        if (node != null) {\n          n = node;\n          while ((n != null) && (n.nodeType !== Node.TEXT_NODE)) {\n            n = n.firstChild;\n          }\n          if (n != null) {\n            r.end = n;\n            r.endOffset = 0;\n          }\n        }\n        if (r.end == null) {\n          node = this.endContainer.childNodes[this.endOffset - 1];\n          r.end = Util.getLastTextNodeUpTo(node);\n          r.endOffset = r.end.nodeValue.length;\n        }\n      } else {\n        r.end = this.endContainer;\n        r.endOffset = this.endOffset;\n      }\n      nr = {};\n      if (r.startOffset > 0) {\n        if (r.start.nodeValue.length > r.startOffset) {\n          nr.start = r.start.splitText(r.startOffset);\n        } else {\n          nr.start = r.start.nextSibling;\n        }\n      } else {\n        nr.start = r.start;\n      }\n      if (r.start === r.end) {\n        if (nr.start.nodeValue.length > (r.endOffset - r.startOffset)) {\n          nr.start.splitText(r.endOffset - r.startOffset);\n        }\n        nr.end = nr.start;\n      } else {\n        if (r.end.nodeValue.length > r.endOffset) {\n          r.end.splitText(r.endOffset);\n        }\n        nr.end = r.end;\n      }\n      nr.commonAncestor = this.commonAncestorContainer;\n      while (nr.commonAncestor.nodeType !== Node.ELEMENT_NODE) {\n        nr.commonAncestor = nr.commonAncestor.parentNode;\n      }\n      return new Range.NormalizedRange(nr);\n    };\n\n    BrowserRange.prototype.serialize = function(root, ignoreSelector) {\n      return this.normalize(root).serialize(root, ignoreSelector);\n    };\n\n    return BrowserRange;\n\n  })();\n\n  Range.NormalizedRange = (function() {\n    function NormalizedRange(obj) {\n      this.commonAncestor = obj.commonAncestor;\n      this.start = obj.start;\n      this.end = obj.end;\n    }\n\n    NormalizedRange.prototype.normalize = function(root) {\n      return this;\n    };\n\n    NormalizedRange.prototype.limit = function(bounds) {\n      var nodes, parent, startParents, _k, _len2, _ref1;\n      nodes = $.grep(this.textNodes(), function(node) {\n        return node.parentNode === bounds || $.contains(bounds, node.parentNode);\n      });\n      if (!nodes.length) {\n        return null;\n      }\n      this.start = nodes[0];\n      this.end = nodes[nodes.length - 1];\n      startParents = $(this.start).parents();\n      _ref1 = $(this.end).parents();\n      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n        parent = _ref1[_k];\n        if (startParents.index(parent) !== -1) {\n          this.commonAncestor = parent;\n          break;\n        }\n      }\n      return this;\n    };\n\n    NormalizedRange.prototype.serialize = function(root, ignoreSelector) {\n      var end, serialization, start;\n      serialization = function(node, isEnd) {\n        var n, nodes, offset, origParent, textNodes, xpath, _k, _len2;\n        if (ignoreSelector) {\n          origParent = $(node).parents(\":not(\" + ignoreSelector + \")\").eq(0);\n        } else {\n          origParent = $(node).parent();\n        }\n        xpath = Util.xpathFromNode(origParent, root)[0];\n        textNodes = Util.getTextNodes(origParent);\n        nodes = textNodes.slice(0, textNodes.index(node));\n        offset = 0;\n        for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {\n          n = nodes[_k];\n          offset += n.nodeValue.length;\n        }\n        if (isEnd) {\n          return [xpath, offset + node.nodeValue.length];\n        } else {\n          return [xpath, offset];\n        }\n      };\n      start = serialization(this.start);\n      end = serialization(this.end, true);\n      return new Range.SerializedRange({\n        start: start[0],\n        end: end[0],\n        startOffset: start[1],\n        endOffset: end[1]\n      });\n    };\n\n    NormalizedRange.prototype.text = function() {\n      var node;\n      return ((function() {\n        var _k, _len2, _ref1, _results;\n        _ref1 = this.textNodes();\n        _results = [];\n        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n          node = _ref1[_k];\n          _results.push(node.nodeValue);\n        }\n        return _results;\n      }).call(this)).join('');\n    };\n\n    NormalizedRange.prototype.textNodes = function() {\n      var end, start, textNodes, _ref1;\n      textNodes = Util.getTextNodes($(this.commonAncestor));\n      _ref1 = [textNodes.index(this.start), textNodes.index(this.end)], start = _ref1[0], end = _ref1[1];\n      return $.makeArray(textNodes.slice(start, +end + 1 || 9e9));\n    };\n\n    NormalizedRange.prototype.toRange = function() {\n      var range;\n      range = document.createRange();\n      range.setStartBefore(this.start);\n      range.setEndAfter(this.end);\n      return range;\n    };\n\n    return NormalizedRange;\n\n  })();\n\n  Range.SerializedRange = (function() {\n    function SerializedRange(obj) {\n      this.start = obj.start;\n      this.startOffset = obj.startOffset;\n      this.end = obj.end;\n      this.endOffset = obj.endOffset;\n    }\n\n    SerializedRange.prototype.normalize = function(root) {\n      var contains, e, length, node, p, range, targetOffset, tn, _k, _l, _len2, _len3, _ref1, _ref2;\n      range = {};\n      _ref1 = ['start', 'end'];\n      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n        p = _ref1[_k];\n        try {\n          node = Range.nodeFromXPath(this[p], root);\n        } catch (_error) {\n          e = _error;\n          throw new Range.RangeError(p, (\"Error while finding \" + p + \" node: \" + this[p] + \": \") + e, e);\n        }\n        if (!node) {\n          throw new Range.RangeError(p, \"Couldn't find \" + p + \" node: \" + this[p]);\n        }\n        length = 0;\n        targetOffset = this[p + 'Offset'];\n        if (p === 'end') {\n          targetOffset--;\n        }\n        _ref2 = Util.getTextNodes($(node));\n        for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {\n          tn = _ref2[_l];\n          if (length + tn.nodeValue.length > targetOffset) {\n            range[p + 'Container'] = tn;\n            range[p + 'Offset'] = this[p + 'Offset'] - length;\n            break;\n          } else {\n            length += tn.nodeValue.length;\n          }\n        }\n        if (range[p + 'Offset'] == null) {\n          throw new Range.RangeError(\"\" + p + \"offset\", \"Couldn't find offset \" + this[p + 'Offset'] + \" in element \" + this[p]);\n        }\n      }\n      contains = document.compareDocumentPosition == null ? function(a, b) {\n        return a.contains(b);\n      } : function(a, b) {\n        return a.compareDocumentPosition(b) & 16;\n      };\n      $(range.startContainer).parents().each(function() {\n        if (contains(this, range.endContainer)) {\n          range.commonAncestorContainer = this;\n          return false;\n        }\n      });\n      return new Range.BrowserRange(range).normalize(root);\n    };\n\n    SerializedRange.prototype.serialize = function(root, ignoreSelector) {\n      return this.normalize(root).serialize(root, ignoreSelector);\n    };\n\n    SerializedRange.prototype.toObject = function() {\n      return {\n        start: this.start,\n        startOffset: this.startOffset,\n        end: this.end,\n        endOffset: this.endOffset\n      };\n    };\n\n    return SerializedRange;\n\n  })();\n\n  _Annotator = this.Annotator;\n\n  Annotator = (function(_super) {\n    __extends(Annotator, _super);\n\n    Annotator.prototype.events = {\n      \".annotator-adder button click\": \"onAdderClick\",\n      \".annotator-adder button mousedown\": \"onAdderMousedown\",\n      \".annotator-hl mouseover\": \"onHighlightMouseover\",\n      \".annotator-hl mouseout\": \"startViewerHideTimer\"\n    };\n\n    Annotator.prototype.html = {\n      adder: '<div class=\"annotator-adder\"><button>' + _t('Annotate') + '</button></div>',\n      wrapper: '<div class=\"annotator-wrapper\"></div>'\n    };\n\n    Annotator.prototype.options = {\n      readOnly: false\n    };\n\n    Annotator.prototype.plugins = {};\n\n    Annotator.prototype.editor = null;\n\n    Annotator.prototype.viewer = null;\n\n    Annotator.prototype.selectedRanges = null;\n\n    Annotator.prototype.mouseIsDown = false;\n\n    Annotator.prototype.ignoreMouseup = false;\n\n    Annotator.prototype.viewerHideTimer = null;\n\n    function Annotator(element, options) {\n      this.onDeleteAnnotation = __bind(this.onDeleteAnnotation, this);\n      this.onEditAnnotation = __bind(this.onEditAnnotation, this);\n      this.onAdderClick = __bind(this.onAdderClick, this);\n      this.onAdderMousedown = __bind(this.onAdderMousedown, this);\n      this.onHighlightMouseover = __bind(this.onHighlightMouseover, this);\n      this.checkForEndSelection = __bind(this.checkForEndSelection, this);\n      this.checkForStartSelection = __bind(this.checkForStartSelection, this);\n      this.clearViewerHideTimer = __bind(this.clearViewerHideTimer, this);\n      this.startViewerHideTimer = __bind(this.startViewerHideTimer, this);\n      this.showViewer = __bind(this.showViewer, this);\n      this.onEditorSubmit = __bind(this.onEditorSubmit, this);\n      this.onEditorHide = __bind(this.onEditorHide, this);\n      this.showEditor = __bind(this.showEditor, this);\n      Annotator.__super__.constructor.apply(this, arguments);\n      this.plugins = {};\n      if (!Annotator.supported()) {\n        return this;\n      }\n      if (!this.options.readOnly) {\n        this._setupDocumentEvents();\n      }\n      this._setupWrapper()._setupViewer()._setupEditor();\n      this._setupDynamicStyle();\n      this.adder = $(this.html.adder).appendTo(this.wrapper).hide();\n      Annotator._instances.push(this);\n    }\n\n    Annotator.prototype._setupWrapper = function() {\n      this.wrapper = $(this.html.wrapper);\n      this.element.find('script').remove();\n      this.element.wrapInner(this.wrapper);\n      this.wrapper = this.element.find('.annotator-wrapper');\n      return this;\n    };\n\n    Annotator.prototype._setupViewer = function() {\n      var _this = this;\n      this.viewer = new Annotator.Viewer({\n        readOnly: this.options.readOnly\n      });\n      this.viewer.hide().on(\"edit\", this.onEditAnnotation).on(\"delete\", this.onDeleteAnnotation).addField({\n        load: function(field, annotation) {\n          if (annotation.text) {\n            $(field).html(Util.escape(annotation.text));\n          } else {\n            $(field).html(\"<i>\" + (_t('No Comment')) + \"</i>\");\n          }\n          return _this.publish('annotationViewerTextField', [field, annotation]);\n        }\n      }).element.appendTo(this.wrapper).bind({\n        \"mouseover\": this.clearViewerHideTimer,\n        \"mouseout\": this.startViewerHideTimer\n      });\n      return this;\n    };\n\n    Annotator.prototype._setupEditor = function() {\n      this.editor = new Annotator.Editor();\n      this.editor.hide().on('hide', this.onEditorHide).on('save', this.onEditorSubmit).addField({\n        type: 'textarea',\n        label: _t('Comments') + '\\u2026',\n        load: function(field, annotation) {\n          return $(field).find('textarea').val(annotation.text || '');\n        },\n        submit: function(field, annotation) {\n          return annotation.text = $(field).find('textarea').val();\n        }\n      });\n      this.editor.element.appendTo(this.wrapper);\n      return this;\n    };\n\n    Annotator.prototype._setupDocumentEvents = function() {\n      $(document).bind({\n        \"mouseup\": this.checkForEndSelection,\n        \"mousedown\": this.checkForStartSelection\n      });\n      return this;\n    };\n\n    Annotator.prototype._setupDynamicStyle = function() {\n      var max, sel, style, x;\n      style = $('#annotator-dynamic-style');\n      if (!style.length) {\n        style = $('<style id=\"annotator-dynamic-style\"></style>').appendTo(document.head);\n      }\n      sel = '*' + ((function() {\n        var _k, _len2, _ref1, _results;\n        _ref1 = ['adder', 'outer', 'notice', 'filter'];\n        _results = [];\n        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n          x = _ref1[_k];\n          _results.push(\":not(.annotator-\" + x + \")\");\n        }\n        return _results;\n      })()).join('');\n      max = Util.maxZIndex($(document.body).find(sel));\n      max = Math.max(max, 1000);\n      style.text([\".annotator-adder, .annotator-outer, .annotator-notice {\", \"  z-index: \" + (max + 20) + \";\", \"}\", \".annotator-filter {\", \"  z-index: \" + (max + 10) + \";\", \"}\"].join(\"\\n\"));\n      return this;\n    };\n\n    Annotator.prototype.destroy = function() {\n      var idx, name, plugin, _base, _ref1;\n      Annotator.__super__.destroy.apply(this, arguments);\n      $(document).unbind({\n        \"mouseup\": this.checkForEndSelection,\n        \"mousedown\": this.checkForStartSelection\n      });\n      $('#annotator-dynamic-style').remove();\n      this.adder.remove();\n      this.viewer.destroy();\n      this.editor.destroy();\n      this.wrapper.find('.annotator-hl').each(function() {\n        $(this).contents().insertBefore(this);\n        return $(this).remove();\n      });\n      this.wrapper.contents().insertBefore(this.wrapper);\n      this.wrapper.remove();\n      this.element.data('annotator', null);\n      _ref1 = this.plugins;\n      for (name in _ref1) {\n        plugin = _ref1[name];\n        if (typeof (_base = this.plugins[name]).destroy === \"function\") {\n          _base.destroy();\n        }\n      }\n      idx = Annotator._instances.indexOf(this);\n      if (idx !== -1) {\n        return Annotator._instances.splice(idx, 1);\n      }\n    };\n\n    Annotator.prototype.getSelectedRanges = function() {\n      var browserRange, i, normedRange, r, ranges, rangesToIgnore, selection, _k, _len2;\n      selection = Util.getGlobal().getSelection();\n      ranges = [];\n      rangesToIgnore = [];\n      if (!selection.isCollapsed) {\n        ranges = (function() {\n          var _k, _ref1, _results;\n          _results = [];\n          for (i = _k = 0, _ref1 = selection.rangeCount; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {\n            r = selection.getRangeAt(i);\n            browserRange = new Range.BrowserRange(r);\n            normedRange = browserRange.normalize().limit(this.wrapper[0]);\n            if (normedRange === null) {\n              rangesToIgnore.push(r);\n            }\n            _results.push(normedRange);\n          }\n          return _results;\n        }).call(this);\n        selection.removeAllRanges();\n      }\n      for (_k = 0, _len2 = rangesToIgnore.length; _k < _len2; _k++) {\n        r = rangesToIgnore[_k];\n        selection.addRange(r);\n      }\n      return $.grep(ranges, function(range) {\n        if (range) {\n          selection.addRange(range.toRange());\n        }\n        return range;\n      });\n    };\n\n    Annotator.prototype.createAnnotation = function() {\n      var annotation;\n      annotation = {};\n      this.publish('beforeAnnotationCreated', [annotation]);\n      return annotation;\n    };\n\n    Annotator.prototype.setupAnnotation = function(annotation) {\n      var e, normed, normedRanges, r, root, _k, _l, _len2, _len3, _ref1;\n      root = this.wrapper[0];\n      annotation.ranges || (annotation.ranges = this.selectedRanges);\n      normedRanges = [];\n      _ref1 = annotation.ranges || [];\n      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n        r = _ref1[_k];\n        try {\n          normedRanges.push(Range.sniff(r).normalize(root));\n        } catch (_error) {\n          e = _error;\n          if (e instanceof Range.RangeError) {\n            this.publish('rangeNormalizeFail', [annotation, r, e]);\n          } else {\n            throw e;\n          }\n        }\n      }\n      annotation.quote = [];\n      annotation.ranges = [];\n      annotation.highlights = [];\n      for (_l = 0, _len3 = normedRanges.length; _l < _len3; _l++) {\n        normed = normedRanges[_l];\n        annotation.quote.push($.trim(normed.text()));\n        annotation.ranges.push(normed.serialize(this.wrapper[0], '.annotator-hl'));\n        $.merge(annotation.highlights, this.highlightRange(normed));\n      }\n      annotation.quote = annotation.quote.join(' / ');\n      $(annotation.highlights).data('annotation', annotation);\n      $(annotation.highlights).attr('data-annotation-id', annotation.id);\n      return annotation;\n    };\n\n    Annotator.prototype.updateAnnotation = function(annotation) {\n      this.publish('beforeAnnotationUpdated', [annotation]);\n      $(annotation.highlights).attr('data-annotation-id', annotation.id);\n      this.publish('annotationUpdated', [annotation]);\n      return annotation;\n    };\n\n    Annotator.prototype.deleteAnnotation = function(annotation) {\n      var child, h, _k, _len2, _ref1;\n      if (annotation.highlights != null) {\n        _ref1 = annotation.highlights;\n        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n          h = _ref1[_k];\n          if (!(h.parentNode != null)) {\n            continue;\n          }\n          child = h.childNodes[0];\n          $(h).replaceWith(h.childNodes);\n        }\n      }\n      this.publish('annotationDeleted', [annotation]);\n      return annotation;\n    };\n\n    Annotator.prototype.loadAnnotations = function(annotations) {\n      var clone, loader,\n        _this = this;\n      if (annotations == null) {\n        annotations = [];\n      }\n      loader = function(annList) {\n        var n, now, _k, _len2;\n        if (annList == null) {\n          annList = [];\n        }\n        now = annList.splice(0, 10);\n        for (_k = 0, _len2 = now.length; _k < _len2; _k++) {\n          n = now[_k];\n          _this.setupAnnotation(n);\n        }\n        if (annList.length > 0) {\n          return setTimeout((function() {\n            return loader(annList);\n          }), 10);\n        } else {\n          return _this.publish('annotationsLoaded', [clone]);\n        }\n      };\n      clone = annotations.slice();\n      loader(annotations);\n      return this;\n    };\n\n    Annotator.prototype.dumpAnnotations = function() {\n      if (this.plugins['Store']) {\n        return this.plugins['Store'].dumpAnnotations();\n      } else {\n        console.warn(_t(\"Can't dump annotations without Store plugin.\"));\n        return false;\n      }\n    };\n\n    Annotator.prototype.highlightRange = function(normedRange, cssClass) {\n      var hl, node, white, _k, _len2, _ref1, _results;\n      if (cssClass == null) {\n        cssClass = 'annotator-hl';\n      }\n      white = /^\\s*$/;\n      hl = $(\"<span class='\" + cssClass + \"'></span>\");\n      _ref1 = normedRange.textNodes();\n      _results = [];\n      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n        node = _ref1[_k];\n        if (!white.test(node.nodeValue)) {\n          _results.push($(node).wrapAll(hl).parent().show()[0]);\n        }\n      }\n      return _results;\n    };\n\n    Annotator.prototype.highlightRanges = function(normedRanges, cssClass) {\n      var highlights, r, _k, _len2;\n      if (cssClass == null) {\n        cssClass = 'annotator-hl';\n      }\n      highlights = [];\n      for (_k = 0, _len2 = normedRanges.length; _k < _len2; _k++) {\n        r = normedRanges[_k];\n        $.merge(highlights, this.highlightRange(r, cssClass));\n      }\n      return highlights;\n    };\n\n    Annotator.prototype.addPlugin = function(name, options) {\n      var klass, _base;\n      if (this.plugins[name]) {\n        console.error(_t(\"You cannot have more than one instance of any plugin.\"));\n      } else {\n        klass = Annotator.Plugin[name];\n        if (typeof klass === 'function') {\n          this.plugins[name] = new klass(this.element[0], options);\n          this.plugins[name].annotator = this;\n          if (typeof (_base = this.plugins[name]).pluginInit === \"function\") {\n            _base.pluginInit();\n          }\n        } else {\n          console.error(_t(\"Could not load \") + name + _t(\" plugin. Have you included the appropriate <script> tag?\"));\n        }\n      }\n      return this;\n    };\n\n    Annotator.prototype.showEditor = function(annotation, location) {\n      this.editor.element.css(location);\n      this.editor.load(annotation);\n      this.publish('annotationEditorShown', [this.editor, annotation]);\n      return this;\n    };\n\n    Annotator.prototype.onEditorHide = function() {\n      this.publish('annotationEditorHidden', [this.editor]);\n      return this.ignoreMouseup = false;\n    };\n\n    Annotator.prototype.onEditorSubmit = function(annotation) {\n      return this.publish('annotationEditorSubmit', [this.editor, annotation]);\n    };\n\n    Annotator.prototype.showViewer = function(annotations, location) {\n      this.viewer.element.css(location);\n      this.viewer.load(annotations);\n      return this.publish('annotationViewerShown', [this.viewer, annotations]);\n    };\n\n    Annotator.prototype.startViewerHideTimer = function() {\n      if (!this.viewerHideTimer) {\n        return this.viewerHideTimer = setTimeout(this.viewer.hide, 250);\n      }\n    };\n\n    Annotator.prototype.clearViewerHideTimer = function() {\n      clearTimeout(this.viewerHideTimer);\n      return this.viewerHideTimer = false;\n    };\n\n    Annotator.prototype.checkForStartSelection = function(event) {\n      if (!(event && this.isAnnotator(event.target))) {\n        this.startViewerHideTimer();\n      }\n      return this.mouseIsDown = true;\n    };\n\n    Annotator.prototype.checkForEndSelection = function(event) {\n      var container, range, _k, _len2, _ref1;\n      this.mouseIsDown = false;\n      if (this.ignoreMouseup) {\n        return;\n      }\n      this.selectedRanges = this.getSelectedRanges();\n      _ref1 = this.selectedRanges;\n      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n        range = _ref1[_k];\n        container = range.commonAncestor;\n        if (this.isAnnotator(container)) {\n          return;\n        }\n      }\n      if (event && this.selectedRanges.length) {\n        return this.adder.css(Util.mousePosition(event, this.wrapper[0])).show();\n      } else {\n        return this.adder.hide();\n      }\n    };\n\n    Annotator.prototype.isAnnotator = function(element) {\n      return !!$(element).parents().addBack().filter('[class^=annotator-]').not('[class=annotator-hl]').not(this.wrapper).length;\n    };\n\n    Annotator.prototype.onHighlightMouseover = function(event) {\n      var annotations;\n      this.clearViewerHideTimer();\n      if (this.mouseIsDown) {\n        return false;\n      }\n      if (this.viewer.isShown()) {\n        this.viewer.hide();\n      }\n      annotations = $(event.target).parents('.annotator-hl').addBack().map(function() {\n        return $(this).data(\"annotation\");\n      }).toArray();\n      return this.showViewer(annotations, Util.mousePosition(event, this.wrapper[0]));\n    };\n\n    Annotator.prototype.onAdderMousedown = function(event) {\n      if (event != null) {\n        event.preventDefault();\n      }\n      return this.ignoreMouseup = true;\n    };\n\n    Annotator.prototype.onAdderClick = function(event) {\n      var annotation, cancel, cleanup, position, save,\n        _this = this;\n      if (event != null) {\n        event.preventDefault();\n      }\n      position = this.adder.position();\n      this.adder.hide();\n      annotation = this.setupAnnotation(this.createAnnotation());\n      $(annotation.highlights).addClass('annotator-hl-temporary');\n      save = function() {\n        cleanup();\n        $(annotation.highlights).removeClass('annotator-hl-temporary');\n        return _this.publish('annotationCreated', [annotation]);\n      };\n      cancel = function() {\n        cleanup();\n        return _this.deleteAnnotation(annotation);\n      };\n      cleanup = function() {\n        _this.unsubscribe('annotationEditorHidden', cancel);\n        return _this.unsubscribe('annotationEditorSubmit', save);\n      };\n      this.subscribe('annotationEditorHidden', cancel);\n      this.subscribe('annotationEditorSubmit', save);\n      return this.showEditor(annotation, position);\n    };\n\n    Annotator.prototype.onEditAnnotation = function(annotation) {\n      var cleanup, offset, update,\n        _this = this;\n      offset = this.viewer.element.position();\n      update = function() {\n        cleanup();\n        return _this.updateAnnotation(annotation);\n      };\n      cleanup = function() {\n        _this.unsubscribe('annotationEditorHidden', cleanup);\n        return _this.unsubscribe('annotationEditorSubmit', update);\n      };\n      this.subscribe('annotationEditorHidden', cleanup);\n      this.subscribe('annotationEditorSubmit', update);\n      this.viewer.hide();\n      return this.showEditor(annotation, offset);\n    };\n\n    Annotator.prototype.onDeleteAnnotation = function(annotation) {\n      this.viewer.hide();\n      return this.deleteAnnotation(annotation);\n    };\n\n    return Annotator;\n\n  })(Delegator);\n\n  Annotator.Plugin = (function(_super) {\n    __extends(Plugin, _super);\n\n    function Plugin(element, options) {\n      Plugin.__super__.constructor.apply(this, arguments);\n    }\n\n    Plugin.prototype.pluginInit = function() {};\n\n    return Plugin;\n\n  })(Delegator);\n\n  g = Util.getGlobal();\n\n  if (((_ref1 = g.document) != null ? _ref1.evaluate : void 0) == null) {\n    $.getScript('/static/vendor/Annotator/xpath.min.js');\n  }\n\n  if (g.getSelection == null) {\n    $.getScript('/static/vendor/Annotator/ierange.min.js');\n  }\n\n  if (g.JSON == null) {\n    $.getScript('/static/vendor/Annotator/json2.min.js');\n  }\n\n  if (g.Node == null) {\n    g.Node = {\n      ELEMENT_NODE: 1,\n      ATTRIBUTE_NODE: 2,\n      TEXT_NODE: 3,\n      CDATA_SECTION_NODE: 4,\n      ENTITY_REFERENCE_NODE: 5,\n      ENTITY_NODE: 6,\n      PROCESSING_INSTRUCTION_NODE: 7,\n      COMMENT_NODE: 8,\n      DOCUMENT_NODE: 9,\n      DOCUMENT_TYPE_NODE: 10,\n      DOCUMENT_FRAGMENT_NODE: 11,\n      NOTATION_NODE: 12\n    };\n  }\n\n  Annotator.$ = $;\n\n  Annotator.Delegator = Delegator;\n\n  Annotator.Range = Range;\n\n  Annotator.Util = Util;\n\n  Annotator._instances = [];\n\n  Annotator._t = _t;\n\n  Annotator.supported = function() {\n    return (function() {\n      return !!this.getSelection;\n    })();\n  };\n\n  Annotator.noConflict = function() {\n    Util.getGlobal().Annotator = _Annotator;\n    return this;\n  };\n\n  $.fn.annotator = function(options) {\n    var args;\n    args = Array.prototype.slice.call(arguments, 1);\n    return this.each(function() {\n      var instance;\n      instance = $.data(this, 'annotator');\n      if (options === 'destroy') {\n        $.removeData(this, 'annotator');\n        return instance != null ? instance.destroy(args) : void 0;\n      } else if (instance) {\n        return options && instance[options].apply(instance, args);\n      } else {\n        instance = new Annotator(this, options);\n        return $.data(this, 'annotator', instance);\n      }\n    });\n  };\n\n  this.Annotator = Annotator;\n\n  Annotator.Widget = (function(_super) {\n    __extends(Widget, _super);\n\n    Widget.prototype.classes = {\n      hide: 'annotator-hide',\n      invert: {\n        x: 'annotator-invert-x',\n        y: 'annotator-invert-y'\n      }\n    };\n\n    function Widget(element, options) {\n      Widget.__super__.constructor.apply(this, arguments);\n      this.classes = $.extend({}, Annotator.Widget.prototype.classes, this.classes);\n    }\n\n    Widget.prototype.destroy = function() {\n      this.removeEvents();\n      return this.element.remove();\n    };\n\n    Widget.prototype.checkOrientation = function() {\n      var current, offset, viewport, widget, window;\n      this.resetOrientation();\n      window = $(Annotator.Util.getGlobal());\n      widget = this.element.children(\":first\");\n      offset = widget.offset();\n      viewport = {\n        top: window.scrollTop(),\n        right: window.width() + window.scrollLeft()\n      };\n      current = {\n        top: offset.top,\n        right: offset.left + widget.width()\n      };\n      if ((current.top - viewport.top) < 0) {\n        this.invertY();\n      }\n      if ((current.right - viewport.right) > 0) {\n        this.invertX();\n      }\n      return this;\n    };\n\n    Widget.prototype.resetOrientation = function() {\n      this.element.removeClass(this.classes.invert.x).removeClass(this.classes.invert.y);\n      return this;\n    };\n\n    Widget.prototype.invertX = function() {\n      this.element.addClass(this.classes.invert.x);\n      return this;\n    };\n\n    Widget.prototype.invertY = function() {\n      this.element.addClass(this.classes.invert.y);\n      return this;\n    };\n\n    Widget.prototype.isInvertedY = function() {\n      return this.element.hasClass(this.classes.invert.y);\n    };\n\n    Widget.prototype.isInvertedX = function() {\n      return this.element.hasClass(this.classes.invert.x);\n    };\n\n    return Widget;\n\n  })(Delegator);\n\n  Annotator.Editor = (function(_super) {\n    __extends(Editor, _super);\n\n    Editor.prototype.events = {\n      \"form submit\": \"submit\",\n      \".annotator-save click\": \"submit\",\n      \".annotator-cancel click\": \"hide\",\n      \".annotator-cancel mouseover\": \"onCancelButtonMouseover\",\n      \"textarea keydown\": \"processKeypress\"\n    };\n\n    Editor.prototype.classes = {\n      hide: 'annotator-hide',\n      focus: 'annotator-focus'\n    };\n\n    Editor.prototype.html = \"<div class=\\\"annotator-outer annotator-editor\\\">\\n  <form class=\\\"annotator-widget\\\">\\n    <ul class=\\\"annotator-listing\\\"></ul>\\n    <div class=\\\"annotator-controls\\\">\\n      <a href=\\\"#cancel\\\" class=\\\"annotator-cancel\\\">\" + _t('Cancel') + \"</a>\\n<a href=\\\"#save\\\" class=\\\"annotator-save annotator-focus\\\">\" + _t('Save') + \"</a>\\n    </div>\\n  </form>\\n</div>\";\n\n    Editor.prototype.options = {};\n\n    function Editor(options) {\n      this.onCancelButtonMouseover = __bind(this.onCancelButtonMouseover, this);\n      this.processKeypress = __bind(this.processKeypress, this);\n      this.submit = __bind(this.submit, this);\n      this.load = __bind(this.load, this);\n      this.hide = __bind(this.hide, this);\n      this.show = __bind(this.show, this);\n      Editor.__super__.constructor.call(this, $(this.html)[0], options);\n      this.fields = [];\n      this.annotation = {};\n    }\n\n    Editor.prototype.show = function(event) {\n      Annotator.Util.preventEventDefault(event);\n      this.element.removeClass(this.classes.hide);\n      this.element.find('.annotator-save').addClass(this.classes.focus);\n      this.checkOrientation();\n      this.element.find(\":input:first\").focus();\n      //this.setupDraggables();\n      return this.publish('show');\n    };\n\n    Editor.prototype.hide = function(event) {\n      Annotator.Util.preventEventDefault(event);\n      this.element.addClass(this.classes.hide);\n      return this.publish('hide');\n    };\n\n    Editor.prototype.load = function(annotation) {\n      var field, _k, _len2, _ref2;\n      this.annotation = annotation;\n      this.publish('load', [this.annotation]);\n      _ref2 = this.fields;\n      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n        field = _ref2[_k];\n        field.load(field.element, this.annotation);\n      }\n      return this.show();\n    };\n\n    Editor.prototype.submit = function(event) {\n      var field, _k, _len2, _ref2;\n      Annotator.Util.preventEventDefault(event);\n      _ref2 = this.fields;\n      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n        field = _ref2[_k];\n        field.submit(field.element, this.annotation);\n      }\n      this.publish('save', [this.annotation]);\n      return this.hide();\n    };\n\n    Editor.prototype.addField = function(options) {\n      var element, field, input;\n      field = $.extend({\n        id: 'annotator-field-' + Annotator.Util.uuid(),\n        type: 'input',\n        label: '',\n        load: function() {},\n        submit: function() {}\n      }, options);\n      input = null;\n      element = $('<li class=\"annotator-item\" />');\n      field.element = element[0];\n      switch (field.type) {\n        case 'textarea':\n          input = $('<textarea />');\n          break;\n        case 'input':\n        case 'checkbox':\n          input = $('<input />');\n          break;\n        case 'select':\n          input = $('<select />');\n      }\n      element.append(input);\n      input.attr({\n        id: field.id,\n        placeholder: field.label\n      });\n      if (field.type === 'checkbox') {\n        input[0].type = 'checkbox';\n        element.addClass('annotator-checkbox');\n        element.append($('<label />', {\n          \"for\": field.id,\n          html: field.label\n        }));\n      }\n      this.element.find('ul:first').append(element);\n      this.fields.push(field);\n      return field.element;\n    };\n\n    Editor.prototype.checkOrientation = function() {\n      var controls, list;\n      Editor.__super__.checkOrientation.apply(this, arguments);\n      list = this.element.find('ul');\n      controls = this.element.find('.annotator-controls');\n      if (this.element.hasClass(this.classes.invert.y)) {\n        controls.insertBefore(list);\n      } else if (controls.is(':first-child')) {\n        controls.insertAfter(list);\n      }\n      return this;\n    };\n\n    Editor.prototype.processKeypress = function(event) {\n      if (event.keyCode === 27) {\n        return this.hide();\n      } else if (event.keyCode === 13 && !event.shiftKey) {\n        return this.submit();\n      }\n    };\n\n    Editor.prototype.onCancelButtonMouseover = function() {\n      return this.element.find('.' + this.classes.focus).removeClass(this.classes.focus);\n    };\n\n    Editor.prototype.setupDraggables = function() {\n      var classes, controls, cornerItem, editor, mousedown, onMousedown, onMousemove, onMouseup, resize, textarea, throttle,\n        _this = this;\n      this.element.find('.annotator-resize').remove();\n      if (this.element.hasClass(this.classes.invert.y)) {\n        cornerItem = this.element.find('.annotator-item:last');\n      } else {\n        cornerItem = this.element.find('.annotator-item:first');\n      }\n      if (cornerItem) {\n        $('<span class=\"annotator-resize\"></span>').appendTo(cornerItem);\n      }\n      mousedown = null;\n      classes = this.classes;\n      editor = this.element;\n      textarea = null;\n      resize = editor.find('.annotator-resize');\n      controls = editor.find('.annotator-controls');\n      throttle = false;\n      onMousedown = function(event) {\n        if (event.target === this) {\n          mousedown = {\n            element: this,\n            top: event.pageY,\n            left: event.pageX\n          };\n          textarea = editor.find('textarea:first');\n          $(window).bind({\n            'mouseup.annotator-editor-resize': onMouseup,\n            'mousemove.annotator-editor-resize': onMousemove\n          });\n          return event.preventDefault();\n        }\n      };\n      onMouseup = function() {\n        mousedown = null;\n        return $(window).unbind('.annotator-editor-resize');\n      };\n      onMousemove = function(event) {\n        var diff, directionX, directionY, height, width;\n        if (mousedown && throttle === false) {\n          diff = {\n            top: event.pageY - mousedown.top,\n            left: event.pageX - mousedown.left\n          };\n          if (mousedown.element === resize[0]) {\n            height = textarea.outerHeight();\n            width = textarea.outerWidth();\n            directionX = editor.hasClass(classes.invert.x) ? -1 : 1;\n            directionY = editor.hasClass(classes.invert.y) ? 1 : -1;\n            textarea.height(height + (diff.top * directionY));\n            textarea.width(width + (diff.left * directionX));\n            if (textarea.outerHeight() !== height) {\n              mousedown.top = event.pageY;\n            }\n            if (textarea.outerWidth() !== width) {\n              mousedown.left = event.pageX;\n            }\n          } else if (mousedown.element === controls[0]) {\n            editor.css({\n              top: parseInt(editor.css('top'), 10) + diff.top,\n              left: parseInt(editor.css('left'), 10) + diff.left\n            });\n            mousedown.top = event.pageY;\n            mousedown.left = event.pageX;\n          }\n          throttle = true;\n          return setTimeout(function() {\n            return throttle = false;\n          }, 1000 / 60);\n        }\n      };\n      resize.bind('mousedown', onMousedown);\n      return controls.bind('mousedown', onMousedown);\n    };\n\n    return Editor;\n\n  })(Annotator.Widget);\n\n  Annotator.Viewer = (function(_super) {\n    __extends(Viewer, _super);\n\n    Viewer.prototype.events = {\n      \".annotator-edit click\": \"onEditClick\",\n      \".annotator-delete click\": \"onDeleteClick\"\n    };\n\n    Viewer.prototype.classes = {\n      hide: 'annotator-hide',\n      showControls: 'annotator-visible'\n    };\n\n    Viewer.prototype.html = {\n      element: \"<div class=\\\"annotator-outer annotator-viewer\\\">\\n  <ul class=\\\"annotator-widget annotator-listing\\\"></ul>\\n</div>\",\n      item: \"<li class=\\\"annotator-annotation annotator-item\\\">\\n  <span class=\\\"annotator-controls\\\">\\n    <a href=\\\"#\\\" title=\\\"View as webpage\\\" class=\\\"annotator-link\\\">View as webpage</a>\\n    <button title=\\\"Edit\\\" class=\\\"annotator-edit\\\">Edit</button>\\n    <button title=\\\"Delete\\\" class=\\\"annotator-delete\\\">Delete</button>\\n  </span>\\n</li>\"\n    };\n\n    Viewer.prototype.options = {\n      readOnly: false\n    };\n\n    function Viewer(options) {\n      this.onDeleteClick = __bind(this.onDeleteClick, this);\n      this.onEditClick = __bind(this.onEditClick, this);\n      this.load = __bind(this.load, this);\n      this.hide = __bind(this.hide, this);\n      this.show = __bind(this.show, this);\n      Viewer.__super__.constructor.call(this, $(this.html.element)[0], options);\n      this.item = $(this.html.item)[0];\n      this.fields = [];\n      this.annotations = [];\n    }\n\n    Viewer.prototype.show = function(event) {\n      var controls,\n        _this = this;\n      Annotator.Util.preventEventDefault(event);\n      controls = this.element.find('.annotator-controls').addClass(this.classes.showControls);\n      setTimeout((function() {\n        return controls.removeClass(_this.classes.showControls);\n      }), 500);\n      this.element.removeClass(this.classes.hide);\n      return this.checkOrientation().publish('show');\n    };\n\n    Viewer.prototype.isShown = function() {\n      return !this.element.hasClass(this.classes.hide);\n    };\n\n    Viewer.prototype.hide = function(event) {\n      Annotator.Util.preventEventDefault(event);\n      this.element.addClass(this.classes.hide);\n      return this.publish('hide');\n    };\n\n    Viewer.prototype.load = function(annotations) {\n      var annotation, controller, controls, del, edit, element, field, item, link, links, list, _k, _l, _len2, _len3, _ref2, _ref3;\n      this.annotations = annotations || [];\n      list = this.element.find('ul:first').empty();\n      _ref2 = this.annotations;\n      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n        annotation = _ref2[_k];\n        item = $(this.item).clone().appendTo(list).data('annotation', annotation);\n        controls = item.find('.annotator-controls');\n        link = controls.find('.annotator-link');\n        edit = controls.find('.annotator-edit');\n        del = controls.find('.annotator-delete');\n        links = new LinkParser(annotation.links || []).get('alternate', {\n          'type': 'text/html'\n        });\n        if (links.length === 0 || (links[0].href == null)) {\n          link.remove();\n        } else {\n          link.attr('href', links[0].href);\n        }\n        if (this.options.readOnly) {\n          edit.remove();\n          del.remove();\n        } else {\n          controller = {\n            showEdit: function() {\n              return edit.removeAttr('disabled');\n            },\n            hideEdit: function() {\n              return edit.attr('disabled', 'disabled');\n            },\n            showDelete: function() {\n              return del.removeAttr('disabled');\n            },\n            hideDelete: function() {\n              return del.attr('disabled', 'disabled');\n            }\n          };\n        }\n        _ref3 = this.fields;\n        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {\n          field = _ref3[_l];\n          element = $(field.element).clone().appendTo(item)[0];\n          field.load(element, annotation, controller);\n        }\n      }\n      this.publish('load', [this.annotations]);\n      return this.show();\n    };\n\n    Viewer.prototype.addField = function(options) {\n      var field;\n      field = $.extend({\n        load: function() {}\n      }, options);\n      field.element = $('<div />')[0];\n      this.fields.push(field);\n      field.element;\n      return this;\n    };\n\n    Viewer.prototype.onEditClick = function(event) {\n      return this.onButtonClick(event, 'edit');\n    };\n\n    Viewer.prototype.onDeleteClick = function(event) {\n      return this.onButtonClick(event, 'delete');\n    };\n\n    Viewer.prototype.onButtonClick = function(event, type) {\n      var item;\n      item = $(event.target).parents('.annotator-annotation');\n      return this.publish(type, [item.data('annotation')]);\n    };\n\n    return Viewer;\n\n  })(Annotator.Widget);\n\n  LinkParser = (function() {\n    function LinkParser(data) {\n      this.data = data;\n    }\n\n    LinkParser.prototype.get = function(rel, cond) {\n      var d, k, keys, match, v, _k, _len2, _ref2, _results;\n      if (cond == null) {\n        cond = {};\n      }\n      cond = $.extend({}, cond, {\n        rel: rel\n      });\n      keys = (function() {\n        var _results;\n        _results = [];\n        for (k in cond) {\n          if (!__hasProp.call(cond, k)) continue;\n          v = cond[k];\n          _results.push(k);\n        }\n        return _results;\n      })();\n      _ref2 = this.data;\n      _results = [];\n      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n        d = _ref2[_k];\n        match = keys.reduce((function(m, k) {\n          return m && (d[k] === cond[k]);\n        }), true);\n        if (match) {\n          _results.push(d);\n        } else {\n          continue;\n        }\n      }\n      return _results;\n    };\n\n    return LinkParser;\n\n  })();\n\n  Annotator = Annotator || {};\n\n  Annotator.Notification = (function(_super) {\n    __extends(Notification, _super);\n\n    Notification.prototype.events = {\n      \"click\": \"hide\"\n    };\n\n    Notification.prototype.options = {\n      html: \"<div class='annotator-notice'></div>\",\n      classes: {\n        show: \"annotator-notice-show\",\n        info: \"annotator-notice-info\",\n        success: \"annotator-notice-success\",\n        error: \"annotator-notice-error\"\n      }\n    };\n\n    function Notification(options) {\n      this.hide = __bind(this.hide, this);\n      this.show = __bind(this.show, this);\n      Notification.__super__.constructor.call(this, $(this.options.html).appendTo(document.body)[0], options);\n    }\n\n    Notification.prototype.show = function(message, status) {\n      if (status == null) {\n        status = Annotator.Notification.INFO;\n      }\n      this.currentStatus = status;\n      $(this.element).addClass(this.options.classes.show).addClass(this.options.classes[this.currentStatus]).html(Util.escape(message || \"\"));\n      setTimeout(this.hide, 5000);\n      return this;\n    };\n\n    Notification.prototype.hide = function() {\n      if (this.currentStatus == null) {\n        this.currentStatus = Annotator.Notification.INFO;\n      }\n      $(this.element).removeClass(this.options.classes.show).removeClass(this.options.classes[this.currentStatus]);\n      return this;\n    };\n\n    return Notification;\n\n  })(Delegator);\n\n  Annotator.Notification.INFO = 'info';\n\n  Annotator.Notification.SUCCESS = 'success';\n\n  Annotator.Notification.ERROR = 'error';\n\n  $(function() {\n    var notification;\n    notification = new Annotator.Notification;\n    Annotator.showNotification = notification.show;\n    return Annotator.hideNotification = notification.hide;\n  });\n\n  Annotator.Plugin.Unsupported = (function(_super) {\n    __extends(Unsupported, _super);\n\n    function Unsupported() {\n      _ref2 = Unsupported.__super__.constructor.apply(this, arguments);\n      return _ref2;\n    }\n\n    Unsupported.prototype.options = {\n      message: Annotator._t(\"Sorry your current browser does not support the Annotator\")\n    };\n\n    Unsupported.prototype.pluginInit = function() {\n      var _this = this;\n      if (!Annotator.supported()) {\n        return $(function() {\n          Annotator.showNotification(_this.options.message);\n          if ((window.XMLHttpRequest === void 0) && (ActiveXObject !== void 0)) {\n            return $('html').addClass('ie6');\n          }\n        });\n      }\n    };\n\n    return Unsupported;\n\n  })(Annotator.Plugin);\n\n  createDateFromISO8601 = function(string) {\n    var d, date, offset, regexp, time, _ref3;\n    regexp = \"([0-9]{4})(-([0-9]{2})(-([0-9]{2})\" + \"(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\\\\.([0-9]+))?)?\" + \"(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?\";\n    d = string.match(new RegExp(regexp));\n    offset = 0;\n    date = new Date(d[1], 0, 1);\n    if (d[3]) {\n      date.setMonth(d[3] - 1);\n    }\n    if (d[5]) {\n      date.setDate(d[5]);\n    }\n    if (d[7]) {\n      date.setHours(d[7]);\n    }\n    if (d[8]) {\n      date.setMinutes(d[8]);\n    }\n    if (d[10]) {\n      date.setSeconds(d[10]);\n    }\n    if (d[12]) {\n      date.setMilliseconds(Number(\"0.\" + d[12]) * 1000);\n    }\n    if (d[14]) {\n      offset = (Number(d[16]) * 60) + Number(d[17]);\n      offset *= (_ref3 = d[15] === '-') != null ? _ref3 : {\n        1: -1\n      };\n    }\n    offset -= date.getTimezoneOffset();\n    time = Number(date) + (offset * 60 * 1000);\n    date.setTime(Number(time));\n    return date;\n  };\n\n  base64Decode = function(data) {\n    var ac, b64, bits, dec, h1, h2, h3, h4, i, o1, o2, o3, tmp_arr;\n    if (typeof atob !== \"undefined\" && atob !== null) {\n      return atob(data);\n    } else {\n      b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      i = 0;\n      ac = 0;\n      dec = \"\";\n      tmp_arr = [];\n      if (!data) {\n        return data;\n      }\n      data += '';\n      while (i < data.length) {\n        h1 = b64.indexOf(data.charAt(i++));\n        h2 = b64.indexOf(data.charAt(i++));\n        h3 = b64.indexOf(data.charAt(i++));\n        h4 = b64.indexOf(data.charAt(i++));\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n        if (h3 === 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1);\n        } else if (h4 === 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\n        } else {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n        }\n      }\n      return tmp_arr.join('');\n    }\n  };\n\n  base64UrlDecode = function(data) {\n    var i, m, _k, _ref3;\n    m = data.length % 4;\n    if (m !== 0) {\n      for (i = _k = 0, _ref3 = 4 - m; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; i = 0 <= _ref3 ? ++_k : --_k) {\n        data += '=';\n      }\n    }\n    data = data.replace(/-/g, '+');\n    data = data.replace(/_/g, '/');\n    return base64Decode(data);\n  };\n\n  parseToken = function(token) {\n    var head, payload, sig, _ref3;\n    _ref3 = token.split('.'), head = _ref3[0], payload = _ref3[1], sig = _ref3[2];\n    return JSON.parse(base64UrlDecode(payload));\n  };\n\n  Annotator.Plugin.Auth = (function(_super) {\n    __extends(Auth, _super);\n\n    Auth.prototype.options = {\n      token: null,\n      tokenUrl: '/auth/token',\n      autoFetch: true\n    };\n\n    function Auth(element, options) {\n      Auth.__super__.constructor.apply(this, arguments);\n      this.waitingForToken = [];\n      if (this.options.token) {\n        this.setToken(this.options.token);\n      } else {\n        this.requestToken();\n      }\n    }\n\n    Auth.prototype.requestToken = function() {\n      var _this = this;\n      this.requestInProgress = true;\n      return $.ajax({\n        url: this.options.tokenUrl,\n        dataType: 'text',\n        xhrFields: {\n          withCredentials: true\n        }\n      }).done(function(data, status, xhr) {\n        return _this.setToken(data);\n      }).fail(function(xhr, status, err) {\n        var msg;\n        msg = Annotator._t(\"Couldn't get auth token:\");\n        console.error(\"\" + msg + \" \" + err, xhr);\n        return Annotator.showNotification(\"\" + msg + \" \" + xhr.responseText, Annotator.Notification.ERROR);\n      }).always(function() {\n        return _this.requestInProgress = false;\n      });\n    };\n\n    Auth.prototype.setToken = function(token) {\n      var _results,\n        _this = this;\n      this.token = token;\n      this._unsafeToken = parseToken(token);\n      if (this.haveValidToken()) {\n        if (this.options.autoFetch) {\n          this.refreshTimeout = setTimeout((function() {\n            return _this.requestToken();\n          }), (this.timeToExpiry() - 2) * 1000);\n        }\n        this.updateHeaders();\n        _results = [];\n        while (this.waitingForToken.length > 0) {\n          _results.push(this.waitingForToken.pop()(this._unsafeToken));\n        }\n        return _results;\n      } else {\n        console.warn(Annotator._t(\"Didn't get a valid token.\"));\n        if (this.options.autoFetch) {\n          console.warn(Annotator._t(\"Getting a new token in 10s.\"));\n          return setTimeout((function() {\n            return _this.requestToken();\n          }), 10 * 1000);\n        }\n      }\n    };\n\n    Auth.prototype.haveValidToken = function() {\n      return (\n        this._unsafeToken &&\n        this._unsafeToken.issuedAt &&\n        this._unsafeToken.ttl &&\n        this._unsafeToken.consumerKey &&\n        this.timeToExpiry() > 0\n      );\n    };\n\n    Auth.prototype.timeToExpiry = function() {\n      var expiry, issue, now, timeToExpiry;\n      now = new Date().getTime() / 1000;\n      issue = createDateFromISO8601(this._unsafeToken.issuedAt).getTime() / 1000;\n      expiry = issue + this._unsafeToken.ttl;\n      timeToExpiry = expiry - now;\n      if (timeToExpiry > 0) {\n        return timeToExpiry;\n      } else {\n        return 0;\n      }\n    };\n\n    Auth.prototype.updateHeaders = function() {\n      var current;\n      current = this.element.data('annotator:headers');\n      return this.element.data('annotator:headers', $.extend(current, {\n        'x-annotator-auth-token': this.token\n      }));\n    };\n\n    Auth.prototype.withToken = function(callback) {\n      if (callback == null) {\n        return;\n      }\n      if (this.haveValidToken()) {\n        return callback(this._unsafeToken);\n      } else {\n        this.waitingForToken.push(callback);\n        if (!this.requestInProgress) {\n          return this.requestToken();\n        }\n      }\n    };\n\n    return Auth;\n\n  })(Annotator.Plugin);\n\n  Annotator.Plugin.Store = (function(_super) {\n    __extends(Store, _super);\n\n    Store.prototype.events = {\n      'annotationCreated': 'annotationCreated',\n      'annotationDeleted': 'annotationDeleted',\n      'annotationUpdated': 'annotationUpdated'\n    };\n\n    Store.prototype.options = {\n      annotationData: {},\n      emulateHTTP: false,\n      loadFromSearch: false,\n      prefix: '/store',\n      urls: {\n        create: '/annotations',\n        read: '/annotations/:id',\n        update: '/annotations/:id',\n        destroy: '/annotations/:id',\n        search: '/search'\n      }\n    };\n\n    function Store(element, options) {\n      this._onError = __bind(this._onError, this);\n      this._onLoadAnnotationsFromSearch = __bind(this._onLoadAnnotationsFromSearch, this);\n      this._onLoadAnnotations = __bind(this._onLoadAnnotations, this);\n      this._getAnnotations = __bind(this._getAnnotations, this);\n      Store.__super__.constructor.apply(this, arguments);\n      this.annotations = [];\n    }\n\n    Store.prototype.pluginInit = function() {\n      if (!Annotator.supported()) {\n        return;\n      }\n      if (this.annotator.plugins.Auth) {\n        return this.annotator.plugins.Auth.withToken();\n      } else {\n        return this._getAnnotations();\n      }\n    };\n\n    Store.prototype._getAnnotations = function() {\n      if (this.options.loadFromSearch) {\n        return this.loadAnnotationsFromSearch(this.options.loadFromSearch);\n      } else {\n        return this.loadAnnotations();\n      }\n    };\n\n    Store.prototype.annotationCreated = function(annotation) {\n      var _this = this;\n      if (__indexOf.call(this.annotations, annotation) < 0) {\n        this.registerAnnotation(annotation);\n        return this._apiRequest('create', annotation, function(data) {\n          if (data.id == null) {\n            console.warn(Annotator._t(\"Warning: No ID returned from server for annotation \"), annotation);\n          }\n          return _this.updateAnnotation(annotation, data);\n        });\n      } else {\n        return this.updateAnnotation(annotation, {});\n      }\n    };\n\n    Store.prototype.annotationUpdated = function(annotation) {\n      var _this = this;\n      if (__indexOf.call(this.annotations, annotation) >= 0) {\n        return this._apiRequest('update', annotation, (function(data) {\n          return _this.updateAnnotation(annotation, data);\n        }));\n      }\n    };\n\n    Store.prototype.annotationDeleted = function(annotation) {\n      var _this = this;\n      if (__indexOf.call(this.annotations, annotation) >= 0) {\n        return this._apiRequest('destroy', annotation, (function() {\n          return _this.unregisterAnnotation(annotation);\n        }));\n      }\n    };\n\n    Store.prototype.registerAnnotation = function(annotation) {\n      return this.annotations.push(annotation);\n    };\n\n    Store.prototype.unregisterAnnotation = function(annotation) {\n      return this.annotations.splice(this.annotations.indexOf(annotation), 1);\n    };\n\n    Store.prototype.updateAnnotation = function(annotation, data) {\n      if (__indexOf.call(this.annotations, annotation) < 0) {\n        console.error(Annotator._t(\"Trying to update unregistered annotation!\"));\n      } else {\n        $.extend(annotation, data);\n      }\n      return $(annotation.highlights).data('annotation', annotation);\n    };\n\n    Store.prototype.loadAnnotations = function() {\n      return this._apiRequest('read', null, this._onLoadAnnotations);\n    };\n\n    Store.prototype._onLoadAnnotations = function(data) {\n      var a, annotation, annotationMap, newData, _k, _l, _len2, _len3, _ref3;\n      if (data == null) {\n        data = [];\n      }\n      annotationMap = {};\n      _ref3 = this.annotations;\n      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\n        a = _ref3[_k];\n        annotationMap[a.id] = a;\n      }\n      newData = [];\n      for (_l = 0, _len3 = data.length; _l < _len3; _l++) {\n        a = data[_l];\n        if (annotationMap[a.id]) {\n          annotation = annotationMap[a.id];\n          this.updateAnnotation(annotation, a);\n        } else {\n          newData.push(a);\n        }\n      }\n      this.annotations = this.annotations.concat(newData);\n      return this.annotator.loadAnnotations(newData.slice());\n    };\n\n    Store.prototype.loadAnnotationsFromSearch = function(searchOptions) {\n      return this._apiRequest('search', searchOptions, this._onLoadAnnotationsFromSearch);\n    };\n\n    Store.prototype._onLoadAnnotationsFromSearch = function(data) {\n      if (data == null) {\n        data = {};\n      }\n      return this._onLoadAnnotations(data.rows || []);\n    };\n\n    Store.prototype.dumpAnnotations = function() {\n      var ann, _k, _len2, _ref3, _results;\n      _ref3 = this.annotations;\n      _results = [];\n      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\n        ann = _ref3[_k];\n        _results.push(JSON.parse(this._dataFor(ann)));\n      }\n      return _results;\n    };\n\n    Store.prototype._apiRequest = function(action, obj, onSuccess) {\n      var id, options, request, url;\n      id = obj && obj.id;\n      url = this._urlFor(action, id);\n      options = this._apiRequestOptions(action, obj, onSuccess);\n      request = $.ajax(url, options);\n      request._id = id;\n      request._action = action;\n      return request;\n    };\n\n    Store.prototype._apiRequestOptions = function(action, obj, onSuccess) {\n      var data, method, opts;\n      method = this._methodFor(action);\n      opts = {\n        type: method,\n        headers: this.element.data('annotator:headers'),\n        dataType: \"json\",\n        success: onSuccess || function() {},\n        error: this._onError\n      };\n      if (this.options.emulateHTTP && (method === 'PUT' || method === 'DELETE')) {\n        opts.headers = $.extend(opts.headers, {\n          'X-HTTP-Method-Override': method\n        });\n        opts.type = 'POST';\n      }\n      if (action === \"search\") {\n        opts = $.extend(opts, {\n          data: obj\n        });\n        return opts;\n      }\n      data = obj && this._dataFor(obj);\n      if (this.options.emulateJSON) {\n        opts.data = {\n          json: data\n        };\n        if (this.options.emulateHTTP) {\n          opts.data._method = method;\n        }\n        return opts;\n      }\n      opts = $.extend(opts, {\n        data: data,\n        contentType: \"application/json; charset=utf-8\"\n      });\n      return opts;\n    };\n\n    Store.prototype._urlFor = function(action, id) {\n      var url;\n      url = this.options.prefix != null ? this.options.prefix : '';\n      url += this.options.urls[action];\n      url = url.replace(/\\/:id/, id != null ? '/' + id : '');\n      url = url.replace(/:id/, id != null ? id : '');\n      return url;\n    };\n\n    Store.prototype._methodFor = function(action) {\n      var table;\n      table = {\n        'create': 'POST',\n        'read': 'GET',\n        'update': 'PUT',\n        'destroy': 'DELETE',\n        'search': 'GET'\n      };\n      return table[action];\n    };\n\n    Store.prototype._dataFor = function(annotation) {\n      var data, highlights;\n      highlights = annotation.highlights;\n      delete annotation.highlights;\n      $.extend(annotation, this.options.annotationData);\n      data = JSON.stringify(annotation);\n      if (highlights) {\n        annotation.highlights = highlights;\n      }\n      return data;\n    };\n\n    Store.prototype._onError = function(xhr) {\n      var action, message;\n      AController.annotationCore.alert(xhr);\n      // action = xhr._action;\n      // message = Annotator._t(\"Sorry we could not \") + action + Annotator._t(\" this annotation\");\n      // if (xhr._action === 'search') {\n      //   message = Annotator._t(\"Sorry we could not search the store for annotations\");\n      // } else if (xhr._action === 'read' && !xhr._id) {\n      //   message = Annotator._t(\"Sorry we could not \") + action + Annotator._t(\" the annotations from the store\");\n      // }\n      // switch (xhr.status) {\n      //   case 401:\n      //     message = Annotator._t(\"Sorry you are not allowed to \") + action + Annotator._t(\" this annotation\");\n      //     break;\n      //   case 404:\n      //     message = Annotator._t(\"Sorry we could not connect to the annotations store\");\n      //     break;\n      //   case 500:\n      //     message = Annotator._t(\"Sorry something went wrong with the annotation store\");\n      // }\n      // Annotator.showNotification(message, Annotator.Notification.ERROR);\n      // return console.error(Annotator._t(\"API request failed:\") + (\" '\" + xhr.status + \"'\"));\n    };\n\n    return Store;\n\n  })(Annotator.Plugin);\n\n  Annotator.Plugin.Permissions = (function(_super) {\n    __extends(Permissions, _super);\n\n    Permissions.prototype.events = {\n      'beforeAnnotationCreated': 'addFieldsToAnnotation'\n    };\n\n    Permissions.prototype.options = {\n      showViewPermissionsCheckbox: true,\n      showEditPermissionsCheckbox: true,\n      userId: function(user) {\n        return user;\n      },\n      userString: function(user) {\n        return user;\n      },\n      userAuthorize: function(action, annotation, user) {\n        var token, tokens, _k, _len2;\n        if (annotation.permissions) {\n          tokens = annotation.permissions[action] || [];\n          if (tokens.length === 0) {\n            return true;\n          }\n          for (_k = 0, _len2 = tokens.length; _k < _len2; _k++) {\n            token = tokens[_k];\n            if (this.userId(user) === token) {\n              return true;\n            }\n          }\n          return false;\n        } else if (annotation.user) {\n          if (user) {\n            return this.userId(user) === this.userId(annotation.user);\n          } else {\n            return false;\n          }\n        }\n        return true;\n      },\n      user: '',\n      permissions: {\n        'read': [],\n        'update': [],\n        'delete': [],\n        'admin': []\n      }\n    };\n\n    function Permissions(element, options) {\n      this._setAuthFromToken = __bind(this._setAuthFromToken, this);\n      this.updateViewer = __bind(this.updateViewer, this);\n      this.updateAnnotationPermissions = __bind(this.updateAnnotationPermissions, this);\n      this.updatePermissionsField = __bind(this.updatePermissionsField, this);\n      this.addFieldsToAnnotation = __bind(this.addFieldsToAnnotation, this);\n      Permissions.__super__.constructor.apply(this, arguments);\n      if (this.options.user) {\n        this.setUser(this.options.user);\n        delete this.options.user;\n      }\n    }\n\n    Permissions.prototype.pluginInit = function() {\n      var createCallback, self,\n        _this = this;\n      if (!Annotator.supported()) {\n        return;\n      }\n      self = this;\n      createCallback = function(method, type) {\n        return function(field, annotation) {\n          return self[method].call(self, type, field, annotation);\n        };\n      };\n      if (!this.user && this.annotator.plugins.Auth) {\n        this.annotator.plugins.Auth.withToken(this._setAuthFromToken);\n      }\n      if (this.options.showViewPermissionsCheckbox === true) {\n        this.annotator.editor.addField({\n          type: 'checkbox',\n          label: Annotator._t('Allow anyone to <strong>view</strong> this annotation'),\n          load: createCallback('updatePermissionsField', 'read'),\n          submit: createCallback('updateAnnotationPermissions', 'read')\n        });\n      }\n      if (this.options.showEditPermissionsCheckbox === true) {\n        this.annotator.editor.addField({\n          type: 'checkbox',\n          label: Annotator._t('Allow anyone to <strong>edit</strong> this annotation'),\n          load: createCallback('updatePermissionsField', 'update'),\n          submit: createCallback('updateAnnotationPermissions', 'update')\n        });\n      }\n      this.annotator.viewer.addField({\n        load: this.updateViewer\n      });\n      if (this.annotator.plugins.Filter) {\n        return this.annotator.plugins.Filter.addFilter({\n          label: Annotator._t('User'),\n          property: 'user',\n          isFiltered: function(input, user) {\n            var keyword, _k, _len2, _ref3;\n            user = _this.options.userString(user);\n            if (!(input && user)) {\n              return false;\n            }\n            _ref3 = input.split(/\\s*/);\n            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\n              keyword = _ref3[_k];\n              if (user.indexOf(keyword) === -1) {\n                return false;\n              }\n            }\n            return true;\n          }\n        });\n      }\n    };\n\n    Permissions.prototype.setUser = function(user) {\n      return this.user = user;\n    };\n\n    Permissions.prototype.addFieldsToAnnotation = function(annotation) {\n      if (annotation) {\n        annotation.permissions = $.extend(true, {}, this.options.permissions);\n        if (this.user) {\n          return annotation.user = this.user;\n        }\n      }\n    };\n\n    Permissions.prototype.authorize = function(action, annotation, user) {\n      if (user === void 0) {\n        user = this.user;\n      }\n      if (this.options.userAuthorize) {\n        return this.options.userAuthorize.call(this.options, action, annotation, user);\n      } else {\n        return true;\n      }\n    };\n\n    Permissions.prototype.updatePermissionsField = function(action, field, annotation) {\n      var input;\n      field = $(field).show();\n      input = field.find('input').removeAttr('disabled');\n      if (!this.authorize('admin', annotation)) {\n        field.hide();\n      }\n      if (this.authorize(action, annotation || {}, null)) {\n        return input.attr('checked', 'checked');\n      } else {\n        return input.removeAttr('checked');\n      }\n    };\n\n    Permissions.prototype.updateAnnotationPermissions = function(type, field, annotation) {\n      var dataKey;\n      if (!annotation.permissions) {\n        annotation.permissions = $.extend(true, {}, this.options.permissions);\n      }\n      dataKey = type + '-permissions';\n      if ($(field).find('input').is(':checked')) {\n        return annotation.permissions[type] = [];\n      } else {\n        return annotation.permissions[type] = [this.options.userId(this.user)];\n      }\n    };\n\n    Permissions.prototype.updateViewer = function(field, annotation, controls) {\n      var user, username;\n      field = $(field);\n      username = this.options.userString(annotation.user);\n      if (annotation.user && username && typeof username === 'string') {\n        user = Annotator.Util.escape(this.options.userString(annotation.user));\n        field.html(user).addClass('annotator-user');\n      } else {\n        field.remove();\n      }\n      if (controls) {\n        if (!this.authorize('update', annotation)) {\n          controls.hideEdit();\n        }\n        if (!this.authorize('delete', annotation)) {\n          return controls.hideDelete();\n        }\n      }\n    };\n\n    Permissions.prototype._setAuthFromToken = function(token) {\n      return this.setUser(token.userId);\n    };\n\n    return Permissions;\n\n  })(Annotator.Plugin);\n\n  Annotator.Plugin.AnnotateItPermissions = (function(_super) {\n    __extends(AnnotateItPermissions, _super);\n\n    function AnnotateItPermissions() {\n      this._setAuthFromToken = __bind(this._setAuthFromToken, this);\n      this.updateAnnotationPermissions = __bind(this.updateAnnotationPermissions, this);\n      this.updatePermissionsField = __bind(this.updatePermissionsField, this);\n      this.addFieldsToAnnotation = __bind(this.addFieldsToAnnotation, this);\n      _ref3 = AnnotateItPermissions.__super__.constructor.apply(this, arguments);\n      return _ref3;\n    }\n\n    AnnotateItPermissions.prototype.options = {\n      showViewPermissionsCheckbox: true,\n      showEditPermissionsCheckbox: true,\n      groups: {\n        world: 'group:__world__',\n        authenticated: 'group:__authenticated__',\n        consumer: 'group:__consumer__'\n      },\n      userId: function(user) {\n        return user.userId;\n      },\n      userString: function(user) {\n        return user.userId;\n      },\n      userAuthorize: function(action, annotation, user) {\n        var action_field, permissions, _ref4, _ref5, _ref6, _ref7;\n        permissions = annotation.permissions || {};\n        action_field = permissions[action] || [];\n        if (_ref4 = this.groups.world, __indexOf.call(action_field, _ref4) >= 0) {\n          return true;\n        } else if ((user != null) && (user.userId != null) && (user.consumerKey != null)) {\n          if (user.userId === annotation.user && user.consumerKey === annotation.consumer) {\n            return true;\n          } else if (_ref5 = this.groups.authenticated, __indexOf.call(action_field, _ref5) >= 0) {\n            return true;\n          } else if (user.consumerKey === annotation.consumer && (_ref6 = this.groups.consumer, __indexOf.call(action_field, _ref6) >= 0)) {\n            return true;\n          } else if (user.consumerKey === annotation.consumer && (_ref7 = user.userId, __indexOf.call(action_field, _ref7) >= 0)) {\n            return true;\n          } else if (user.consumerKey === annotation.consumer && user.admin) {\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      },\n      permissions: {\n        'read': ['group:__world__'],\n        'update': [],\n        'delete': [],\n        'admin': []\n      }\n    };\n\n    AnnotateItPermissions.prototype.addFieldsToAnnotation = function(annotation) {\n      if (annotation) {\n        annotation.permissions = this.options.permissions;\n        if (this.user) {\n          annotation.user = this.user.userId;\n          return annotation.consumer = this.user.consumerKey;\n        }\n      }\n    };\n\n    AnnotateItPermissions.prototype.updatePermissionsField = function(action, field, annotation) {\n      var input;\n      field = $(field).show();\n      input = field.find('input').removeAttr('disabled');\n      if (!this.authorize('admin', annotation)) {\n        field.hide();\n      }\n      if (this.user && this.authorize(action, annotation || {}, {\n        userId: '__nonexistentuser__',\n        consumerKey: this.user.consumerKey\n      })) {\n        return input.attr('checked', 'checked');\n      } else {\n        return input.removeAttr('checked');\n      }\n    };\n\n    AnnotateItPermissions.prototype.updateAnnotationPermissions = function(type, field, annotation) {\n      var dataKey;\n      if (!annotation.permissions) {\n        annotation.permissions = this.options.permissions;\n      }\n      dataKey = type + '-permissions';\n      if ($(field).find('input').is(':checked')) {\n        return annotation.permissions[type] = [type === 'read' ? this.options.groups.world : this.options.groups.consumer];\n      } else {\n        return annotation.permissions[type] = [];\n      }\n    };\n\n    AnnotateItPermissions.prototype._setAuthFromToken = function(token) {\n      return this.setUser(token);\n    };\n\n    return AnnotateItPermissions;\n\n  })(Annotator.Plugin.Permissions);\n\n  Annotator.Plugin.Filter = (function(_super) {\n    __extends(Filter, _super);\n\n    Filter.prototype.events = {\n      \".annotator-filter-property input focus\": \"_onFilterFocus\",\n      \".annotator-filter-property input blur\": \"_onFilterBlur\",\n      \".annotator-filter-property input keyup\": \"_onFilterKeyup\",\n      \".annotator-filter-previous click\": \"_onPreviousClick\",\n      \".annotator-filter-next click\": \"_onNextClick\",\n      \".annotator-filter-clear click\": \"_onClearClick\"\n    };\n\n    Filter.prototype.classes = {\n      active: 'annotator-filter-active',\n      hl: {\n        hide: 'annotator-hl-filtered',\n        active: 'annotator-hl-active'\n      }\n    };\n\n    Filter.prototype.html = {\n      element: \"<div class=\\\"annotator-filter\\\">\\n  <strong>\" + Annotator._t('Navigate:') + \"</strong>\\n<span class=\\\"annotator-filter-navigation\\\">\\n  <button class=\\\"annotator-filter-previous\\\">\" + Annotator._t('Previous') + \"</button>\\n<button class=\\\"annotator-filter-next\\\">\" + Annotator._t('Next') + \"</button>\\n</span>\\n<strong>\" + Annotator._t('Filter by:') + \"</strong>\\n</div>\",\n      filter: \"<span class=\\\"annotator-filter-property\\\">\\n  <label></label>\\n  <input/>\\n  <button class=\\\"annotator-filter-clear\\\">\" + Annotator._t('Clear') + \"</button>\\n</span>\"\n    };\n\n    Filter.prototype.options = {\n      appendTo: 'body',\n      filters: [],\n      addAnnotationFilter: true,\n      isFiltered: function(input, property) {\n        var keyword, _k, _len2, _ref4;\n        if (!(input && property)) {\n          return false;\n        }\n        _ref4 = input.split(/\\s+/);\n        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {\n          keyword = _ref4[_k];\n          if (property.indexOf(keyword) === -1) {\n            return false;\n          }\n        }\n        return true;\n      }\n    };\n\n    function Filter(element, options) {\n      this._onPreviousClick = __bind(this._onPreviousClick, this);\n      this._onNextClick = __bind(this._onNextClick, this);\n      this._onFilterKeyup = __bind(this._onFilterKeyup, this);\n      this._onFilterBlur = __bind(this._onFilterBlur, this);\n      this._onFilterFocus = __bind(this._onFilterFocus, this);\n      this.updateHighlights = __bind(this.updateHighlights, this);\n      var _base;\n      element = $(this.html.element).appendTo((options != null ? options.appendTo : void 0) || this.options.appendTo);\n      Filter.__super__.constructor.call(this, element, options);\n      (_base = this.options).filters || (_base.filters = []);\n      this.filter = $(this.html.filter);\n      this.filters = [];\n      this.current = 0;\n    }\n\n    Filter.prototype.pluginInit = function() {\n      var filter, _k, _len2, _ref4;\n      _ref4 = this.options.filters;\n      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {\n        filter = _ref4[_k];\n        this.addFilter(filter);\n      }\n      this.updateHighlights();\n      this._setupListeners()._insertSpacer();\n      if (this.options.addAnnotationFilter === true) {\n        return this.addFilter({\n          label: Annotator._t('Annotation'),\n          property: 'text'\n        });\n      }\n    };\n\n    Filter.prototype.destroy = function() {\n      var currentMargin, html;\n      Filter.__super__.destroy.apply(this, arguments);\n      html = $('html');\n      currentMargin = parseInt(html.css('padding-top'), 10) || 0;\n      html.css('padding-top', currentMargin - this.element.outerHeight());\n      return this.element.remove();\n    };\n\n    Filter.prototype._insertSpacer = function() {\n      var currentMargin, html;\n      html = $('html');\n      currentMargin = parseInt(html.css('padding-top'), 10) || 0;\n      html.css('padding-top', currentMargin + this.element.outerHeight());\n      return this;\n    };\n\n    Filter.prototype._setupListeners = function() {\n      var event, events, _k, _len2;\n      events = ['annotationsLoaded', 'annotationCreated', 'annotationUpdated', 'annotationDeleted'];\n      for (_k = 0, _len2 = events.length; _k < _len2; _k++) {\n        event = events[_k];\n        this.annotator.subscribe(event, this.updateHighlights);\n      }\n      return this;\n    };\n\n    Filter.prototype.addFilter = function(options) {\n      var f, filter;\n      filter = $.extend({\n        label: '',\n        property: '',\n        isFiltered: this.options.isFiltered\n      }, options);\n      if (!((function() {\n        var _k, _len2, _ref4, _results;\n        _ref4 = this.filters;\n        _results = [];\n        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {\n          f = _ref4[_k];\n          if (f.property === filter.property) {\n            _results.push(f);\n          }\n        }\n        return _results;\n      }).call(this)).length) {\n        filter.id = 'annotator-filter-' + filter.property;\n        filter.annotations = [];\n        filter.element = this.filter.clone().appendTo(this.element);\n        filter.element.find('label').html(filter.label).attr('for', filter.id);\n        filter.element.find('input').attr({\n          id: filter.id,\n          placeholder: Annotator._t('Filter by ') + filter.label + '\\u2026'\n        });\n        filter.element.find('button').hide();\n        filter.element.data('filter', filter);\n        this.filters.push(filter);\n      }\n      return this;\n    };\n\n    Filter.prototype.updateFilter = function(filter) {\n      var annotation, annotations, input, property, _k, _len2, _ref4;\n      filter.annotations = [];\n      this.updateHighlights();\n      this.resetHighlights();\n      input = $.trim(filter.element.find('input').val());\n      if (input) {\n        annotations = this.highlights.map(function() {\n          return $(this).data('annotation');\n        });\n        _ref4 = $.makeArray(annotations);\n        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {\n          annotation = _ref4[_k];\n          property = annotation[filter.property];\n          if (filter.isFiltered(input, property)) {\n            filter.annotations.push(annotation);\n          }\n        }\n        return this.filterHighlights();\n      }\n    };\n\n    Filter.prototype.updateHighlights = function() {\n      this.highlights = this.annotator.element.find('.annotator-hl:visible');\n      return this.filtered = this.highlights.not(this.classes.hl.hide);\n    };\n\n    Filter.prototype.filterHighlights = function() {\n      var activeFilters, annotation, annotations, filtered, highlights, index, uniques, _k, _len2, _ref4;\n      activeFilters = $.grep(this.filters, function(filter) {\n        return !!filter.annotations.length;\n      });\n      filtered = ((_ref4 = activeFilters[0]) != null ? _ref4.annotations : void 0) || [];\n      if (activeFilters.length > 1) {\n        annotations = [];\n        $.each(activeFilters, function() {\n          return $.merge(annotations, this.annotations);\n        });\n        uniques = [];\n        filtered = [];\n        $.each(annotations, function() {\n          if ($.inArray(this, uniques) === -1) {\n            return uniques.push(this);\n          } else {\n            return filtered.push(this);\n          }\n        });\n      }\n      highlights = this.highlights;\n      for (index = _k = 0, _len2 = filtered.length; _k < _len2; index = ++_k) {\n        annotation = filtered[index];\n        highlights = highlights.not(annotation.highlights);\n      }\n      highlights.addClass(this.classes.hl.hide);\n      this.filtered = this.highlights.not(this.classes.hl.hide);\n      return this;\n    };\n\n    Filter.prototype.resetHighlights = function() {\n      this.highlights.removeClass(this.classes.hl.hide);\n      this.filtered = this.highlights;\n      return this;\n    };\n\n    Filter.prototype._onFilterFocus = function(event) {\n      var input;\n      input = $(event.target);\n      input.parent().addClass(this.classes.active);\n      return input.next('button').show();\n    };\n\n    Filter.prototype._onFilterBlur = function(event) {\n      var input;\n      if (!event.target.value) {\n        input = $(event.target);\n        input.parent().removeClass(this.classes.active);\n        return input.next('button').hide();\n      }\n    };\n\n    Filter.prototype._onFilterKeyup = function(event) {\n      var filter;\n      filter = $(event.target).parent().data('filter');\n      if (filter) {\n        return this.updateFilter(filter);\n      }\n    };\n\n    Filter.prototype._findNextHighlight = function(previous) {\n      var active, annotation, current, index, next, offset, operator, resetOffset;\n      if (!this.highlights.length) {\n        return this;\n      }\n      offset = previous ? 0 : -1;\n      resetOffset = previous ? -1 : 0;\n      operator = previous ? 'lt' : 'gt';\n      active = this.highlights.not('.' + this.classes.hl.hide);\n      current = active.filter('.' + this.classes.hl.active);\n      if (!current.length) {\n        current = active.eq(offset);\n      }\n      annotation = current.data('annotation');\n      index = active.index(current[0]);\n      next = active.filter(\":\" + operator + \"(\" + index + \")\").not(annotation.highlights).eq(resetOffset);\n      if (!next.length) {\n        next = active.eq(resetOffset);\n      }\n      return this._scrollToHighlight(next.data('annotation').highlights);\n    };\n\n    Filter.prototype._onNextClick = function(event) {\n      return this._findNextHighlight();\n    };\n\n    Filter.prototype._onPreviousClick = function(event) {\n      return this._findNextHighlight(true);\n    };\n\n    Filter.prototype._scrollToHighlight = function(highlight) {\n      highlight = $(highlight);\n      this.highlights.removeClass(this.classes.hl.active);\n      highlight.addClass(this.classes.hl.active);\n      return $('html, body').animate({\n        scrollTop: highlight.offset().top - (this.element.height() + 20)\n      }, 150);\n    };\n\n    Filter.prototype._onClearClick = function(event) {\n      return $(event.target).prev('input').val('').keyup().blur();\n    };\n\n    return Filter;\n\n  })(Annotator.Plugin);\n\n  Annotator.Plugin.Markdown = (function(_super) {\n    __extends(Markdown, _super);\n\n    Markdown.prototype.events = {\n      'annotationViewerTextField': 'updateTextField'\n    };\n\n    function Markdown(element, options) {\n      this.updateTextField = __bind(this.updateTextField, this);\n      if ((typeof Showdown !== \"undefined\" && Showdown !== null ? Showdown.converter : void 0) != null) {\n        Markdown.__super__.constructor.apply(this, arguments);\n        this.converter = new Showdown.converter();\n      } else {\n        console.error(Annotator._t(\"To use the Markdown plugin, you must include Showdown into the page first.\"));\n      }\n    }\n\n    Markdown.prototype.updateTextField = function(field, annotation) {\n      var text;\n      text = Annotator.Util.escape(annotation.text || '');\n      return $(field).html(this.convert(text));\n    };\n\n    Markdown.prototype.convert = function(text) {\n      return this.converter.makeHtml(text);\n    };\n\n    return Markdown;\n\n  })(Annotator.Plugin);\n\n  Annotator.Plugin.Tags = (function(_super) {\n    __extends(Tags, _super);\n\n    function Tags() {\n      this.setAnnotationTags = __bind(this.setAnnotationTags, this);\n      this.updateField = __bind(this.updateField, this);\n      _ref4 = Tags.__super__.constructor.apply(this, arguments);\n      return _ref4;\n    }\n\n    Tags.prototype.options = {\n      parseTags: function(string) {\n        var tags;\n        string = $.trim(string);\n        tags = [];\n        if (string) {\n          tags = string.split(/\\s+/);\n        }\n        return tags;\n      },\n      stringifyTags: function(array) {\n        return array.join(\" \");\n      }\n    };\n\n    Tags.prototype.field = null;\n\n    Tags.prototype.input = null;\n\n    Tags.prototype.pluginInit = function() {\n      if (!Annotator.supported()) {\n        return;\n      }\n      this.field = this.annotator.editor.addField({\n        label: Annotator._t('Add some tags here') + '\\u2026',\n        load: this.updateField,\n        submit: this.setAnnotationTags\n      });\n      this.annotator.viewer.addField({\n        load: this.updateViewer\n      });\n      if (this.annotator.plugins.Filter) {\n        this.annotator.plugins.Filter.addFilter({\n          label: Annotator._t('Tag'),\n          property: 'tags',\n          isFiltered: Annotator.Plugin.Tags.filterCallback\n        });\n      }\n      return this.input = $(this.field).find(':input');\n    };\n\n    Tags.prototype.parseTags = function(string) {\n      return this.options.parseTags(string);\n    };\n\n    Tags.prototype.stringifyTags = function(array) {\n      return this.options.stringifyTags(array);\n    };\n\n    Tags.prototype.updateField = function(field, annotation) {\n      var value;\n      value = '';\n      if (annotation.tags) {\n        value = this.stringifyTags(annotation.tags);\n      }\n      return this.input.val(value);\n    };\n\n    Tags.prototype.setAnnotationTags = function(field, annotation) {\n      return annotation.tags = this.parseTags(this.input.val());\n    };\n\n    Tags.prototype.updateViewer = function(field, annotation) {\n      field = $(field);\n      if (annotation.tags && $.isArray(annotation.tags) && annotation.tags.length) {\n        return field.addClass('annotator-tags').html(function() {\n          var string;\n          return string = $.map(annotation.tags, function(tag) {\n            return '<span class=\"annotator-tag\">' + Annotator.Util.escape(tag) + '</span>';\n          }).join(' ');\n        });\n      } else {\n        return field.remove();\n      }\n    };\n\n    return Tags;\n\n  })(Annotator.Plugin);\n\n  Annotator.Plugin.Tags.filterCallback = function(input, tags) {\n    var keyword, keywords, matches, tag, _k, _l, _len2, _len3;\n    if (tags == null) {\n      tags = [];\n    }\n    matches = 0;\n    keywords = [];\n    if (input) {\n      keywords = input.split(/\\s+/g);\n      for (_k = 0, _len2 = keywords.length; _k < _len2; _k++) {\n        keyword = keywords[_k];\n        if (tags.length) {\n          for (_l = 0, _len3 = tags.length; _l < _len3; _l++) {\n            tag = tags[_l];\n            if (tag.indexOf(keyword) !== -1) {\n              matches += 1;\n            }\n          }\n        }\n      }\n    }\n    return matches === keywords.length;\n  };\n\n  Annotator.prototype.setupPlugins = function(config, options) {\n    var name, opts, pluginConfig, plugins, uri, win, _k, _len2, _results;\n    if (config == null) {\n      config = {};\n    }\n    if (options == null) {\n      options = {};\n    }\n    win = Annotator.Util.getGlobal();\n    plugins = ['Unsupported', 'Auth', 'Tags', 'Filter', 'Store', 'AnnotateItPermissions'];\n    if (win.Showdown) {\n      plugins.push('Markdown');\n    }\n    uri = win.location.href.split(/#|\\?/).shift() || '';\n    pluginConfig = {\n      Tags: {},\n      Filter: {\n        filters: [\n          {\n            label: Annotator._t('User'),\n            property: 'user'\n          }, {\n            label: Annotator._t('Tags'),\n            property: 'tags'\n          }\n        ]\n      },\n      Auth: {\n        tokenUrl: config.tokenUrl || 'http://annotateit.org/api/token'\n      },\n      Store: {\n        prefix: config.storeUrl || 'http://annotateit.org/api',\n        annotationData: {\n          uri: uri\n        },\n        loadFromSearch: {\n          uri: uri\n        }\n      }\n    };\n    for (name in options) {\n      if (!__hasProp.call(options, name)) continue;\n      opts = options[name];\n      if (__indexOf.call(plugins, name) < 0) {\n        plugins.push(name);\n      }\n    }\n    $.extend(true, pluginConfig, options);\n    _results = [];\n    for (_k = 0, _len2 = plugins.length; _k < _len2; _k++) {\n      name = plugins[_k];\n      if (!(name in pluginConfig) || pluginConfig[name]) {\n        _results.push(this.addPlugin(name, pluginConfig[name]));\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n}).call(this);\n\n//\n//# sourceMappingURL=annotator-full.map\n\n//# sourceURL=webpack:///./src/static/vendors/Annotator/annotator-full.js?");

/***/ }),

/***/ "./src/static/vendors/Annotator/annotator.css":
/*!****************************************************!*\
  !*** ./src/static/vendors/Annotator/annotator.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/vendors/Annotator/annotator.css?");

/***/ }),

/***/ "./src/static/vendors/Annotator/plugins/highlightTags-annotator.js":
/*!*************************************************************************!*\
  !*** ./src/static/vendors/Annotator/plugins/highlightTags-annotator.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function(Annotator) {/* \n HighlightTags Annotator Plugin v1.0 (https://github.com/lduarte1991/tags-annotator)\n Copyright (C) 2014 Luis F Duarte\n License: https://github.com/lduarte1991/tags-annotator/blob/master/LICENSE.rst\n \n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n  \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n*/\n__webpack_require__(/*! tokeninput */ \"./src/static/vendors/development/jquery.tokeninput.js\");\nAnnotator.Plugin.HighlightTags = function(element, options) {\n\t\n\t// extends the Plugin class from Annotator\n\tAnnotator.Plugin.apply(this, arguments);\n\n\tthis.field = null;\n\t//this.prototype.input = null;\n\tthis.colors = null;\n\t//this.prototype.isFirstTime = true;\n\treturn this;\n};\n\n// Set the plugin prototype. This gives us all of the Annotator.Plugin methods.\nAnnotator.Plugin.HighlightTags.prototype = new Annotator.Plugin();\nAnnotator.Plugin.HighlightTags.prototype.tokensavailable = [];\n\nAnnotator.Plugin.HighlightTags.prototype.pluginInit = function() {\n\t// Check that Annotator is working\n\tif (!Annotator.supported()) {\n\t\treturn;\n\t}\n\n\t// adds the field for them to enter tags in the editor\n\tvar self = Annotator._instances[0].plugins.HighlightTags;\n\tself.field = self.annotator.editor.addField({\n\t\ttype: 'input',\n\t\tlabel: 'Add tags...',\n\t\tload: self.updateField,\n\t\tsubmit: self.pluginSubmit,\n\t});\n\n\t$(self.field).html(\"<div><input placeholder =\\\"Add tags...\\\" type=\\\"text\\\" id=\\\"tag-input\\\" name=\\\"tags\\\" /></div>\");\n\n\t// predetermined instructor tags are stored\n\tvar tags = self.options.tag.split(\",\");\n\n\t// tags are given the structure that the dropdown/token function requires\n    tags.forEach(function(tagnames) {\n        lonename = tagnames.split(\":\");\n        self.tokensavailable.push({'id': lonename[0], 'name': lonename[0]});\n    });\n\n\t// now that #tag-input is in place, add the tokens to autocomplete\n    $('#tag-input').tokenInput(self.tokensavailable);\n\n    self.colors = self.getHighlightTags();\n\n    var newview = self.annotator.viewer.addField({\n        load: self.updateViewer,\n    });\n    // all of these need time for the annotations database to respond\n    this.annotator.subscribe('annotationsLoaded', function(){setTimeout(function(){self.colorize()}, 1000)});\n    self.annotator.subscribe('annotationUpdated', function(){setTimeout(function(){self.colorize()}, 1000)});\n    self.annotator.subscribe('flaggedAnnotation', self.updateViewer);\n    self.annotator.subscribe('annotationCreated', function(){setTimeout(function(){self.colorize()}, 1000)});\n    self.annotator.subscribe('externalCallToHighlightTags', function(){setTimeout(function(){self.externalCall()}, 1000)});\n    self.annotator.subscribe('colorEditorTags', self.colorizeEditorTags);\n};\n\nAnnotator.Plugin.HighlightTags.prototype.getHighlightTags = function(){\n\tvar self = Annotator._instances[0].plugins.HighlightTags;\n\n    if (typeof self.options.tag != 'undefined') {\n        var final = {};\n        var prelim = self.options.tag.split(\",\");\n        prelim.forEach(function(item){\n            var temp = item.split(\":\");\n            final[temp[0]] = self.getRGB(temp[1]);\n        });\n        return final;\n    }\n    return {};\n};\n\nAnnotator.Plugin.HighlightTags.prototype.getRGB = function(item){\n    function getColorValues( color ){\n\t    var values = { red:null, green:null, blue:null, alpha:null };\n\t    if( typeof color == 'string' ){\n\t        /* hex */\n\t        if( color.indexOf('#') === 0 ){\n\t            color = color.substr(1)\n\t            if( color.length == 3 )\n\t                values = {\n\t                    red:   parseInt( color[0]+color[0], 16 ),\n\t                    green: parseInt( color[1]+color[1], 16 ),\n\t                    blue:  parseInt( color[2]+color[2], 16 ),\n\t                    alpha: .3\n\t                }\n\t            else\n\t                values = {\n\t                    red:   parseInt( color.substr(0,2), 16 ),\n\t                    green: parseInt( color.substr(2,2), 16 ),\n\t                    blue:  parseInt( color.substr(4,2), 16 ),\n\t                    alpha: .3\n\t                }\n\t        /* rgb */\n\t        }else if( color.indexOf('rgb(') === 0 ){\n\t            var pars = color.indexOf(',');\n\t            values = {\n\t                red:   parseInt(color.substr(4,pars)),\n\t                green: parseInt(color.substr(pars+1,color.indexOf(',',pars))),\n\t                blue:  parseInt(color.substr(color.indexOf(',',pars+1)+1,color.indexOf(')'))),\n\t                alpha: .3\n\t            }\n\t        /* rgba */\n\t        }else if( color.indexOf('rgba(') === 0 ){\n\t            var pars = color.indexOf(','),\n\t                repars = color.indexOf(',',pars+1);\n\t            values = {\n\t                red:   parseInt(color.substr(5,pars)),\n\t                green: parseInt(color.substr(pars+1,repars)),\n\t                blue:  parseInt(color.substr(color.indexOf(',',pars+1)+1,color.indexOf(',',repars))),\n\t                alpha: parseFloat(color.substr(color.indexOf(',',repars+1)+1,color.indexOf(')')))\n\t            }\n\t        /* verbous */\n\t        }else{\n\t            var stdCol = { acqua:'#0ff',   teal:'#008080',   blue:'#00f',      navy:'#000080',\n\t                           yellow:'#ff0',  olive:'#808000',  lime:'#0f0',      green:'#008000',\n\t                           fuchsia:'#f0f', purple:'#800080', red:'#f00',       maroon:'#800000',\n\t                           white:'#fff',   gray:'#808080',   silver:'#c0c0c0', black:'#000' };\n\t            if( stdCol[color]!=undefined )\n\t                values = getColorValues(stdCol[color]);\n\t        }\n\t    }\n\t    return values;\n\t}\n    return getColorValues(item);\n};\n\nAnnotator.Plugin.HighlightTags.prototype.colorize = function() {\n\tvar self = Annotator._instances[0].plugins.HighlightTags;\n\tvar annotations = Array.prototype.slice.call($(\".annotator-hl\"));\n\tfor (annNum = 0; annNum < annotations.length; ++annNum) {\n\t    var anns = $.data(annotations[annNum],\"annotation\");\n\t    if (typeof anns.tags !== \"undefined\" && anns.tags.length == 0) {\n\t        \n\t        // image annotations should not change the background of the highlight\n\t        // only the border so as not to block the image behind it.\n\t        if (anns.media === \"text\") {\n\t            $(annotations[annNum]).css(\"background-color\", \"\");\n\t        } else if(anns.media === \"video\") {\n\t        \t$(annotations[annNum].firstChild).css(\"background-color\", \"\");\n\t        } else {\n\t            $(annotations[annNum]).css(\"border\", \"2px solid rgb(255, 255, 255)\");\n\t            $(annotations[annNum]).css(\"outline\", \"2px solid rgb(0, 0, 0)\");\n\t        }\n\t    }\n\n\t    if (typeof anns.tags !== \"undefined\" && self.colors !== {}) {\n\t        \n\t        for (var index = 0; index < anns.tags.length; ++index) {\n\t            if (anns.tags[index].indexOf(\"flagged-\") == -1) {\n\t                if (typeof self.colors[anns.tags[index]] !== \"undefined\") {\n\t                    var finalcolor = self.colors[anns.tags[index]];\n\t                    // if it's a text change the background\n\t                    if (anns.media === \"text\") {\n\t                        $(annotations[annNum]).css(\n\t                            \"background\", \n\t                            // last value, 0.3 is the standard highlight opacity for annotator\n\t                            \"rgba(\" + finalcolor.red + \", \" + finalcolor.green + \", \" + finalcolor.blue + \", 0.3)\"\n\t                        );\n\t                    } else if (anns.media === \"video\") {\n\t                    \t// following functions from http://stackoverflow.com/questions/20734317/create-linear-gradient-for-a-given-hex-value-in-javascript\n\t                    \tvar ratio = 1.24;\n\t                    \tfunction componentToHex(c) {\n\t\t\t\t\t\t\t\tvar hex = c.toString(16);\n\t\t\t\t\t\t\t\treturn hex.length == 1 ? \"0\" + hex : hex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfunction rgbToHex(r, g, b) {\n\t\t\t\t\t\t\t\treturn \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n\t\t\t\t\t\t\t}\n\t                    \tvar finalgradient = {\n\t                    \t\tred: Math.floor(finalcolor.red / ratio),\n\t                    \t\tgreen: Math.floor(finalcolor.green / ratio),\n\t                    \t\tblue: Math.floor(finalcolor.blue / ratio),\n\t                    \t}\n\t                        $(annotations[annNum].firstChild).css(\n\t                            \"background\", \n\t                            \"rgba(\" + finalcolor.red + \", \" + finalcolor.green + \", \" + finalcolor.blue + \", 0.9)\"\n\t                        );\n\t                        $(annotations[annNum].firstChild).css(\n\t                            \"background\",\n\t                            \"-webkit-linear-gradient(top, \" + rgbToHex(finalcolor.red, finalcolor.green, finalcolor.blue) + \", \" + rgbToHex(finalgradient.red, finalgradient.green, finalgradient.blue) + \")\"\n\t                        );\n\t                    } \n\t                    // if it's an image change the dark border/outline leave the white one as is\n\t                    else {\n\t                        $(annotations[annNum]).css(\n\t                            \"outline\",\n\t                            \"2px solid rgb(\" + finalcolor.red + \", \" + finalcolor.green + \", \" + finalcolor.blue + \")\"\n\t                        );\n\t                    }\n\t                } else {\n\t                    // if the last tag was not predetermined by instrutor background should go back to default\n\t                    if (anns.media === \"text\") {\n\t                        $(annotations[annNum]).css(\n\t                            \"background\", \n\t                            // returns the value to the inherited value without the above\n\t                            \"\"\n\t                        );\n\t                    } else if (anns.media === \"video\") {\n\t                        $(annotations[annNum].firstChild).css(\n\t                            \"background\", \n\t                            // returns the value to the inherited value without the above\n\t                            \"\"\n\t                        );\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        \n\t    } else {\n\t        // if there are no tags or predefined colors, keep the background at default\n\t        if (anns.media === \"text\") {\n\t           $(annotations[annNum]).css(\"background\",\"\");\n\t        } else if (anns.media === \"video\") {\n\t           $(annotations[annNum].firstChild).css(\"background\",\"\");\n\t        }\n\t    }\n\t}\n\tself.annotator.publish('colorizeCompleted');\n};\n\n// this function adds the appropriate color to the tag divs for each annotation\nAnnotator.Plugin.HighlightTags.prototype.colorizeEditorTags = function() {\n    var self = Annotator._instances[0].plugins.HighlightTags;;\n    $.each($('.annotator-editor .token-input-token'), function(key, tagdiv) {\n        // default colors are black for text and the original powder blue (already default)\n        var rgbColor = \"\";\n        var textColor = \"color:#000;\";\n        var par = $(tagdiv).find(\"p\");\n\n        // if the tag has a predetermined color attached to it, \n        // then it changes the background and turns text white\n        if (typeof self.colors[par.html()] !== \"undefined\") {\n            var finalcolor = self.colors[par.html()];\n            rgbColor = \"background-color:rgba(\" + finalcolor.red + \", \" + finalcolor.green + \", \" + finalcolor.blue + \", 0.5);\";\n            textColor = \"color:#fff;\";\n        }\n\n        // note that to change the text color you must change it in the paragraph tag, not the div\n        $(tagdiv).attr('style', rgbColor);\n        par.attr('style', textColor);\n    });    \n};\n\nAnnotator.Plugin.HighlightTags.prototype.updateField = function(field, annotation) {\n\tvar self = Annotator._instances[0].plugins.HighlightTags;\n\n    $('#tag-input').tokenInput('clear');\n    $('#token-input-tag-input').attr('placeholder', 'Add tags...');\n\n    // loops through the tags already in the annotation and \"add\" them to this annotation\n    if (typeof annotation.tags !== \"undefined\") {\n        for (tagnum = 0; tagnum < annotation.tags.length; tagnum++) {\n            var n = annotation.tags[tagnum];\n            if (typeof self.annotator.plugins[\"HighlightTags\"] !== 'undefined') {\n                // if there are flags, we must ignore them\n                if (annotation.tags[tagnum].indexOf(\"flagged-\") === -1 && annotation.tags[tagnum] !== \"\") {\n                    $('#tag-input').tokenInput('add',{'id':n,'name':n});\n                }\n            } else {\n                $('#tag-input').tokenInput('add', {'id': n, 'name': n});\n            }\n        }\n    }\n    self.colorizeEditorTags();\n};\n\nAnnotator.Plugin.HighlightTags.prototype.updateViewer = function(field, annotation) {\n\tvar self = Annotator._instances[0].plugins.HighlightTags;\n\tif (typeof annotation.tags !== \"undefined\") {\n\t\tif (annotation.tags.length === 0 || annotation.tags[0] === \"\") {\n\t\t\t$(field).remove();\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise we prepare to loop through them\n        var nonFlagTags = true;\n        var tokenList = \"<ul class=\\\"token-input-list\\\">\";\n\n        for (tagnum = 0; tagnum < annotation.tags.length; ++tagnum){\n        \tvar colorTags = function() {\n        \t\t  // once again, defaults are black for text and powder blue default from token function\n                var rgbColor = \"\";\n                var textColor = \"#000\";\n\n                // if there is a color associated with the tag, it will change the background\n                // and change the text to white\n                if (typeof self.colors[annotation.tags[tagnum]] !== \"undefined\") {\n                    var finalcolor = self.colors[annotation.tags[tagnum]];\n                    rgbColor = \"style=\\\"background-color:rgba(\" + finalcolor.red + \", \" + finalcolor.green + \", \" + finalcolor.blue + \", 0.5);\\\"\";\n                    textColor = \"#fff\";\n                }\n\n                // note: to change text color you need to do it in the paragrph tag not the div\n                tokenList += \"<li class=\\\"token-input-token\\\"\" + rgbColor + \"><p style=\\\"color: \" + textColor + \";\\\">\"+ annotation.tags[tagnum]+\"</p></span></li>\";\n                nonFlagTags = false;\n        \t}\n            if (typeof self.annotator.plugins[\"Flagging\"] !== 'undefined') {\n                // once again we ingore flags\n                if (annotation.tags[tagnum].indexOf(\"flagged-\") === -1) {\n                    colorTags();\n                }\n            } else {\n                colorTags();\n            }\n        }\n\n        // close off list from above\n        tokenList += \"</ul>\";\n        $(field).append(tokenList);\n\n        // the field for tags is removed also if all the tags ended up being flags\n        if (nonFlagTags) {\n        \t$(field.remove());\n        }\n\t} else {\n\t\t$(field).remove();\n\t}\n};\n\n// The following function is run when a person hits submit.\nAnnotator.Plugin.HighlightTags.prototype.pluginSubmit = function(field, annotation) {\n    var submitted_tags = $(field).find('input[name=tags]').val().split(',');\n    var submitted_tag, cleaned_tags = [];\n    for(var i = 0; i < submitted_tags.length; i++) {\n        submitted_tag = submitted_tags[i].trim();\n        if(submitted_tag !== \"\") {\n            cleaned_tags.push(submitted_tag);\n        }\n    }\n    annotation.tags = cleaned_tags;\n    //console.log(\"highlightTags::pluginSubmit()\", \"submitted:\", submitted_tags, \"cleaned:\", annotation.tags);\n};\n\n// The following will call the colorize function during an external call and then return\n// an event signaling completion.\nAnnotator.Plugin.HighlightTags.prototype.externalCall = function() {\n\tvar self = Annotator._instances[0].plugins.HighlightTags;\n    self.colorize();\n    self.annotator.publish('finishedExternalCallToHighlightTags');\n};\n\n})( true ? __webpack_require__(/*! annotator */ \"./src/static/vendors/Annotator/annotator-full.js\").Annotator : undefined);\n\n\n//# sourceURL=webpack:///./src/static/vendors/Annotator/plugins/highlightTags-annotator.js?");

/***/ }),

/***/ "./src/static/vendors/Annotator/plugins/localstore-annotator.js":
/*!**********************************************************************!*\
  !*** ./src/static/vendors/Annotator/plugins/localstore-annotator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(" (function(Annotator) {\n  var $, Annotator, Delegator, LinkParser, Range, Util, base64Decode, base64UrlDecode, createDateFromISO8601, findChild, fn, functions, g, getNodeName, getNodePosition, gettext, parseToken, simpleXPathJQuery, simpleXPathPure, _Annotator, _gettext, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _t,\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n Annotator.Plugin.LocalStore = (function(_super) {\n  var __extends = function(child, parent) { \n        for (var key in parent) { \n            if (__hasProp.call(parent, key)) \n                child[key] = parent[key]; \n        } \n        function ctor() { \n            this.constructor = child; \n        } \n\n        ctor.prototype = parent.prototype; \n        child.prototype = new ctor(); \n        child.__super__ = parent.prototype; \n        return child; \n    };\n    __extends(LocalStore, _super);\n\n    LocalStore.prototype.events = {\n      'annotationCreated': 'annotationCreated',\n      'annotationDeleted': 'annotationDeleted',\n      'annotationUpdated': 'annotationUpdated'\n    };\n\n    LocalStore.prototype.options = {\n      annotationData: {},\n      emulateHTTP: false,\n      loadFromSearch: false,\n      prefix: '/localStore',\n      urls: {\n        create: '/annotations',\n        read: '/annotations/:id',\n        update: '/annotations/:id',\n        destroy: '/annotations/:id',\n        search: '/search'\n      }\n    };\n\n    function LocalStore(element, options) {\n      this._onError = __bind(this._onError, this);\n      this._onLoadAnnotations = __bind(this._onLoadAnnotations, this);\n      this._getAnnotations = __bind(this._getAnnotations, this);\n      LocalStore.__super__.constructor.apply(this, arguments);\n      this.masterannotations = options.annotations;\n      this.annotations = [];\n    }\n\n    LocalStore.prototype.pluginInit = function() {\n      if (!Annotator.supported()) {\n        return;\n      }\n      return this._getAnnotations();\n    };\n\n    LocalStore.prototype._getAnnotations = function() {\n      return this.loadAnnotations();\n    };\n\n    LocalStore.prototype.registerAnnotation = function(annotation) {\n      return this.annotations.push(annotation);\n    };\n\n    LocalStore.prototype.updateAnnotation = function(annotation, data) {\n      if (__indexOf.call(this.annotations, annotation) < 0) {\n        console.error(Annotator._t(\"Trying to update unregistered annotation!\"));\n      } else {\n        jQuery.extend(annotation, data);\n      }\n      return jQuery(annotation.highlights).data('annotation', annotation);\n    };\n\n    LocalStore.prototype.unregisterAnnotation = function(annotation) {\n      return this.annotations.splice(this.annotations.indexOf(annotation), 1);\n    };\n\n    LocalStore.prototype.loadAnnotations = function() {\n      return this._onLoadAnnotations(this.masterannotations);\n    };\n\n    LocalStore.prototype._onLoadAnnotations = function(data) {\n      var a, annotation, annotationMap, newData, _k, _l, _len2, _len3, _ref3;\n      if (data == null) {\n        data = [];\n      }\n      annotationMap = {};\n      _ref3 = this.annotations;\n      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\n        a = _ref3[_k];\n        annotationMap[a.id] = a;\n      }\n      newData = [];\n      for (_l = 0, _len3 = data.length; _l < _len3; _l++) {\n        a = data[_l];\n        if (annotationMap[a.id]) {\n          annotation = annotationMap[a.id];\n          this.updateAnnotation(annotation, a);\n        } else {\n          newData.push(a);\n        }\n      }\n      this.annotations = this.annotations.concat(newData);\n      return this.annotator.loadAnnotations(newData.slice());\n    };\n\n    LocalStore.prototype.dumpAnnotations = function() {\n      var ann, _k, _len2, _ref3, _results;\n      _ref3 = this.annotations;\n      _results = [];\n      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\n        ann = _ref3[_k];\n        _results.push(JSON.parse(this._dataFor(ann)));\n      }\n      return _results;\n    };\n\n    LocalStore.prototype._dataFor = function(annotation) {\n      var data, highlights;\n      highlights = annotation.highlights;\n      delete annotation.highlights;\n      data = JSON.stringify(annotation, null, 4);\n      if (highlights) {\n        annotation.highlights = highlights;\n      }\n      return data;\n    };\n\n    LocalStore.prototype.annotationCreated = function(annotation) {\n      jQuery.extend(annotation, {\n        'media': jQuery('#media-type').html(),\n        'id': this.guid()\n      });\n      this.registerAnnotation(annotation);\n      console.log(annotation);\n    };\n\n    LocalStore.prototype.annotationDeleted = function(annotation) {\n      this.unregisterAnnotation(annotation);\n    };\n\n    LocalStore.prototype.annotationUpdated = function(annotation) {\n      this.updateAnnotation(annotation, annotation);\n    };\n\n    LocalStore.prototype.guid = function() {\n      function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000)\n          .toString(16)\n          .substring(1);\n      }\n      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n    }\n\n    return LocalStore;\n\n  })(Annotator.Plugin);\n\n})( true ? __webpack_require__(/*! annotator */ \"./src/static/vendors/Annotator/annotator-full.js\").Annotator : undefined);\n\n\n//# sourceURL=webpack:///./src/static/vendors/Annotator/plugins/localstore-annotator.js?");

/***/ }),

/***/ "./src/static/vendors/Annotator/plugins/summernote-richtext-annotator.css":
/*!********************************************************************************!*\
  !*** ./src/static/vendors/Annotator/plugins/summernote-richtext-annotator.css ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/vendors/Annotator/plugins/summernote-richtext-annotator.css?");

/***/ }),

/***/ "./src/static/vendors/Annotator/plugins/summernote-richtext-annotator.js":
/*!*******************************************************************************!*\
  !*** ./src/static/vendors/Annotator/plugins/summernote-richtext-annotator.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function(Annotator) {\n    Annotator.Plugin.SummernoteRichText = function(element, options) {\n\t\n\t// extends the Plugin class from Annotator\n\tAnnotator.Plugin.apply(this, arguments);\n\n\tthis.field = null;\n\tthis.options = {\n\t\theight: 100,\n\t\tfocus: true,\n\t\twidth: 400,\n\t};\n\n\treturn this;\n};\n\nAnnotator.Plugin.SummernoteRichText.prototype = new Annotator.Plugin();\n\nAnnotator.Plugin.SummernoteRichText.prototype.pluginInit = function() {\n\tif (!Annotator.supported()){\n\t\treturn;\n\t}\n\tvar self = Annotator._instances[0].plugins.SummernoteRichText;\n\tself.field = self.annotator.editor.addField({\n\t\ttype: 'input',\n\t\tload: self.updateEditor,\n\t\tsubmit: self.submitEditor,\n\t});\n\n\tself.viewer = self.annotator.viewer.addField({\n\t\tload: this.updateViewer,\n\t});\n\n\tself.annotator.subscribe(\"annotationEditorShown\", function() {\n\t\t// checks to make sure it can fit on screen\n\t\t$('#annotator-field-0').summernote(self.options);\n\t\tdelete $.summernote.options.keyMap.pc.TAB;\n\t\tdelete $.summernote.options.keyMap.mac.TAB;\n\t\tself.checkOrientation();\n\n\t\t// then it will restart summernote, otherwise it may cause all <li> to have Save\n\t\t// and cancel buttons.\n\t\t$('#annotator-field-0').destroy();\n\t\tsetTimeout(function(){$('#annotator-field-0').summernote(self.options)}, 100);\n\t});\n\n\tself.annotator.subscribe(\"annotationEditorHidden\", function() {\n\t\t$('#annotator-field-0').destroy();\n\t\t$('.fullscreen').toggleClass('fullscreen');\n\t});\n};\n\nAnnotator.Plugin.SummernoteRichText.prototype.checkOrientation = function() {\n      var current, offset, viewport, widget, window;\n      this.annotator.editor.element.removeClass('annotator-invert-x').removeClass('annotator-invert-y');\n      window = $(Annotator.Util.getGlobal());\n      widget = this.annotator.editor.element.children(\":first\");\n      offset = widget.offset();\n      viewport = {\n        top: window.scrollTop(),\n        right: window.width() + window.scrollLeft()\n      };\n      current = {\n        top: offset.top,\n        right: offset.left + widget.width()\n      };\n      if ((current.top - viewport.top) < 0) {\n        this.annotator.editor.element.addClass('annotator-invert-y');\n      }\n      if ((current.right - viewport.right) > 0) {\n        this.annotator.editor.element.addClass('annotator-invert-x');\n      }\n      return this;\n}\n\nAnnotator.Plugin.SummernoteRichText.prototype.updateEditor = function(field, annotation) {\n\tvar text = typeof annotation.text != 'undefined' ? annotation.text : '';\n\t$('#annotator-field-0').code(text);\n\t$(field).remove();\n};\n\nAnnotator.Plugin.SummernoteRichText.prototype.updateViewer = function(field, annotation) {\n\tvar textDiv = $(field.parentNode).find('div:first-of-type')[0];\n    textDiv.innerHTML = annotation.text;\n    $(field).remove();\n};\n\nAnnotator.Plugin.SummernoteRichText.prototype.submitEditor = function(field, annotation) {\n\tvar result = $('#annotator-field-0').code();\n\tif (result.indexOf('<script') >= 0) {\n        alert('Content contains JavaScript code that will be escaped and ignored.');\n        result = result.replace('<script', '&lt;script').replace('</script>', '&lt;/script&gt;').replace('>', '&gt;');\n    }\n    annotation.text = result;\n};\n})( true ? __webpack_require__(/*! annotator */ \"./src/static/vendors/Annotator/annotator-full.js\").Annotator : undefined);\n\n\n//# sourceURL=webpack:///./src/static/vendors/Annotator/plugins/summernote-richtext-annotator.js?");

/***/ }),

/***/ "./src/static/vendors/Annotator/plugins/timeRangeEditor-annotator.js":
/*!***************************************************************************!*\
  !*** ./src/static/vendors/Annotator/plugins/timeRangeEditor-annotator.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function(Annotator) {\nAnnotator.Plugin.TimeRangeEditor = function(element, options) {\n\t\n\t// extends the Plugin class from Annotator\n\tAnnotator.Plugin.apply(this, arguments);\n\n\tthis.field = null;\n\n\treturn this;\n};\n\nAnnotator.Plugin.TimeRangeEditor.prototype = new Annotator.Plugin();\n\nAnnotator.Plugin.TimeRangeEditor.prototype.pluginInit = function() {\n\tif (!Annotator.supported()){\n\t\treturn;\n\t}\n\tvar self = Annotator._instances[0].plugins.TimeRangeEditor;\n\tself.field = self.annotator.editor.addField({\n\t\ttype: 'input',\n\t\tload: self.updateEditor,\n\t});\n\n\tjQuery(self.field).html(\"<div class='timeRangeEditor' style='padding-left: 10px;padding-right:10px;'>Start: <input type='number' id='start' style='min-width: 30%!important;width: 30%!important;display:inline-block!important;'></input>seconds.<button role='button' style='padding:3px;margin-left:35px;margin-bottom:-30px;width:130px' id='preview' class='btn btn-default' aria-label='Select to preview range selected.'>Preview Video</button><br>End:&nbsp;&nbsp;&nbsp;<input type='number' id='end' style='min-width: 30%!important;width: 30%!important;display:inline-block!important;'></input>seconds.</div>\");\n\n};\n\nAnnotator.Plugin.TimeRangeEditor.prototype.updateEditor = function(field, annotation) {\n\tvar times = window.vid.rangeslider.getValues();\n\tvar startElement = jQuery(field).find('#start');\n\tvar endElement = jQuery(field).find('#end');\n\tstartElement.val(Math.floor(times.start));\n\tendElement.val(Math.floor(times.end));\n\t\n\tstartElement.on('change', function(e){\n\t\twindow.vid.rangeslider.setValue(0, startElement.val());\n\t});\n\n\tendElement.on('change', function(e){\n\t\twindow.vid.rangeslider.setValue(1, endElement.val());\n\t});\n\tvar self = Annotator._instances[0]\n\tjQuery('#preview').click(function(e) {\n\t\te.preventDefault();\n\t\twindow.vid.player().playBetween(startElement.val(), endElement.val());\n\t\t\n\t\tif (jQuery('#transcript').is(\":hidden\")){\n\t\t\tvar translate_editor = (jQuery(window).height() - (jQuery('#viewer').height() + 50)) * -1;\n        \twindow.annotation_tool.editor.element.css('transform', 'translateY('+translate_editor+'px)');\n        \tjQuery(\"#transcript\").show();\n\t        jQuery('#viewer').css('height', '80%');\n\t\t}\n\t\t\n\t});\n\n};\n})( true ? __webpack_require__(/*! annotator */ \"./src/static/vendors/Annotator/annotator-full.js\").Annotator : undefined);\n\n\n//# sourceURL=webpack:///./src/static/vendors/Annotator/plugins/timeRangeEditor-annotator.js?");

/***/ }),

/***/ "./src/static/vendors/Annotator/plugins/videojs-annotator.js":
/*!*******************************************************************!*\
  !*** ./src/static/vendors/Annotator/plugins/videojs-annotator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ----------------Plugin for Annotator to setup videojs---------------- //\nvar Annotator =  true ? __webpack_require__(/*! annotator */ \"./src/static/vendors/Annotator/annotator-full.js\").Annotator : undefined;\nvar _ref,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\nAnnotator.Plugin.VideoJS = (function(_super) {\n\n    // constructor\n    function VideoJS() {\n        this.pluginSubmit = __bind(this.pluginSubmit, this);\n        _ref = _super.apply(this, arguments);\n        this.__indexOf = [].indexOf || function(item) { \n            for (var i = 0, l = this.length; i < l; i++) { \n                if (i in this && this[i] === item) \n                    return i; \n            } \n            return -1; \n        };\n        return _ref;\n    };\n\n    VideoJS.prototype = new _super();\n\n    VideoJS.prototype.field = null;\n    VideoJS.prototype.input = null;\n\n    VideoJS.prototype.pluginInit = function() {\n        //console.log(\"VideoJS-pluginInit\");\n        // Check that annotator is working\n        if (!Annotator.supported()) {\n            return;\n        }\n        \n        // -- Editor\n        this.field = this.annotator.editor.addField({\n            id: 'vjs-input-rangeTime-annotations',\n            type: 'input', // options (textarea, input, select, checkbox)\n            submit: this.pluginSubmit,\n            EditVideoAn: this.EditVideoAn\n        });\n        \n        // Modify the element created with annotator to be an invisible span\n        var select = '<li><span id=\"vjs-input-rangeTime-annotations\"></span></li>';\n        var newfield = Annotator.$(select);\n        Annotator.$(this.field).replaceWith(newfield);\n        this.field = newfield[0];\n        \n        // -- Listener for Open Video Annotator\n        this.initListeners();\n        \n        return this.input = $(this.field).find(':input');\n    };\n    \n\n    // New JSON for the database\n    VideoJS.prototype.pluginSubmit = function(field, annotation) {\n        console.log(\"Plug-pluginSubmit\");\n        // Select the new JSON for the Object to save\n\n        if (this.EditVideoAn()) {\n            var annotator = this.annotator;\n            var index = annotator.editor.VideoJS;\n            var player = window.vid;//annotator.mplayer[index];\n            var rs = player.rangeslider;\n            var time = rs.getValues();\n            var isYoutube = (player && typeof player.techName !== 'undefined') ? (player.techName === 'Youtube') : false;\n            var isNew = typeof annotation.media === 'undefined';\n            var ext;\n            var type = player.options_.sources[0].type.split(\"/\") || \"\";\n            \n            if (isNew) \n                annotation.media = typeof type[0] !== 'undefined' ? type[0] : \"video\"; // - media (by default: video)\n            \n            annotation.target = annotation.target || {}; // - target\n            annotation.target.container = player.id_ || \"\"; // - target.container\n            annotation.target.src = player.options_.sources[0].src || \"\"; // - target.src (media source)\n            ext = (player.options_.sources[0].src.substring(player.options_.sources[0].src.lastIndexOf(\".\"))).toLowerCase(); \n            ext = isYoutube ? 'Youtube' : ext; // The extension for youtube\n            annotation.target.ext = ext || \"\"; // - target.ext (extension)\n            annotation.rangeTime =     annotation.rangeTime || {};    // - rangeTime\n            annotation.rangeTime.start = time.start || 0; // - rangeTime.start\n            annotation.rangeTime.end = time.end || 0; // - rangeTime.end\n            annotation.updated = new Date().toISOString(); // - updated\n            if (typeof annotation.created === 'undefined')\n                annotation.created = annotation.updated; // - created\n            \n            // show the new annotation\n            var eventAn = isNew ? \"annotationCreated\" : \"annotationUpdated\";\n            function afterFinish(){\n                player.annotations.showAnnotation(annotation);\n                annotator.unsubscribe(eventAn, afterFinish);\n            };\n            annotator.subscribe(eventAn, afterFinish); // show after the annotation is in the back-end\n        } else {\n            if (typeof annotation.media === 'undefined')\n                annotation.media = \"text\"; // - media\n            \n            annotation.updated = new Date().toISOString(); // - updated\n            \n            if (typeof annotation.created === 'undefined')\n                annotation.created = annotation.updated; // - created\n        }\n        return annotation.media;\n    };\n    \n    \n    // ------ Methods    ------ //\n    // Detect if we are creating or editing a video-js annotation\n    VideoJS.prototype.EditVideoAn =  function () {\n        var wrapper = $('.annotator-wrapper').parent()[0];\n        var annotator = window.annotator = $.data(wrapper, 'annotator');\n        var isOpenVideojs = (typeof window.vid !== 'undefined');\n        return (isOpenVideojs && typeof VideoJS !== 'undefined');\n    };\n    \n    \n    // Detect if the annotation is a video-js annotation\n    VideoJS.prototype.isVideoJS = function (an) {\n        var wrapper = $('.annotator-wrapper').parent()[0];\n        var annotator = window.annotator = $.data(wrapper, 'annotator');\n        var rt = an.rangeTime;\n        var isOpenVideojs = (typeof window.vid !== 'undefined');\n        var isVideo = (typeof an.media !== 'undefined' && (an.media === 'video' || an.media === 'audio'));\n        var isNumber = (typeof rt !== 'undefined' && !isNaN(parseFloat(rt.start)) && isFinite(rt.start) && !isNaN(parseFloat(rt.end)) && isFinite(rt.end));\n        return (isOpenVideojs && isVideo && isNumber);\n    };\n    \n    // Delete Video Annotation\n    VideoJS.prototype._deleteAnnotation = function(an) {\n        var target = an.target || {};\n        var container = target.container || {};\n        var player = window.vid;\n        \n        var annotator = this.annotator;\n        var annotations = annotator.plugins.Store.annotations;\n        var tot = typeof annotations !== 'undefined' ? annotations.length : 0;\n        var attempts = 0; // max 100\n            \n        // This is to watch the annotations object, to see when is deleted the annotation\n        var ischanged = function() {\n            var new_tot = annotator.plugins.Store.annotations.length;\n            if (attempts < 100)\n                setTimeout(function() {\n                    if (new_tot !== tot) {\n                        player.annotations.refreshDisplay(); // Reload the display of annotation\n                    } else {\n                        attempts++;\n                        ischanged();\n                    }\n                }, 100); // wait for the change in the annotations\n        };\n        ischanged();\n        \n        player.rangeslider.hide(); // Hide Range Slider\n    };\n    \n    \n    // --Listeners\n    VideoJS.prototype.initListeners = function () {\n        var wrapper = $('.annotator-wrapper').parent()[0];\n        var annotator = $.data(wrapper, 'annotator');\n        var EditVideoAn = this.EditVideoAn;\n        var isVideoJS = this.isVideoJS;\n        var self = this;\n            \n        // local functions\n        // -- Editor\n        function annotationEditorHidden(editor) {\n            if (EditVideoAn()){\n                window.vid.rangeslider.hide(); // Hide Range Slider\n                window.vid.annotations.refreshDisplay(); // Reload the display of annotations\n            }\n            annotator.unsubscribe(\"annotationEditorHidden\", annotationEditorHidden);\n        };\n        function annotationEditorShown(editor, annotation) {\n            window.vid.annotations.editAnnotation(annotation, editor);\n            annotator.subscribe(\"annotationEditorHidden\", annotationEditorHidden);\n        };\n        // -- Annotations\n        function annotationDeleted(annotation) {\n            \n            if (isVideoJS(annotation))\n                self._deleteAnnotation(annotation);\n        };\n        // -- Viewer\n        function hideViewer(){\n            window.vid.annotations.AnDisplay.onCloseViewer();\n            annotator.viewer.unsubscribe(\"hide\", hideViewer);\n        };\n        function annotationViewerShown(viewer, annotations) {\n            \n            var separation = viewer.element.hasClass(viewer.classes.invert.y) ? 5 : -5;\n            var newpos = {\n                top: parseFloat(viewer.element[0].style.top)+separation,\n                left: parseFloat(viewer.element[0].style.left)\n            };\n            viewer.element.css(newpos);\n            \n            // Remove the time to wait until disapear, to be more faster that annotator by default\n            viewer.element.find('.annotator-controls').removeClass(viewer.classes.showControls);\n            \n            annotator.viewer.subscribe(\"hide\", hideViewer);\n        };    \n        \n        // subscribe to Annotator\n        annotator.subscribe(\"annotationEditorShown\", annotationEditorShown)\n            .subscribe(\"annotationDeleted\", annotationDeleted)\n            .subscribe(\"annotationViewerShown\", annotationViewerShown);\n    };\n    return VideoJS;\n\n})(Annotator.Plugin);\n\n\n//# sourceURL=webpack:///./src/static/vendors/Annotator/plugins/videojs-annotator.js?");

/***/ }),

/***/ "./src/static/vendors/development/css/font-awesome.css":
/*!*************************************************************!*\
  !*** ./src/static/vendors/development/css/font-awesome.css ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/vendors/development/css/font-awesome.css?");

/***/ }),

/***/ "./src/static/vendors/development/css/ova.css":
/*!****************************************************!*\
  !*** ./src/static/vendors/development/css/ova.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/vendors/development/css/ova.css?");

/***/ }),

/***/ "./src/static/vendors/development/css/rangeslider.css":
/*!************************************************************!*\
  !*** ./src/static/vendors/development/css/rangeslider.css ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/vendors/development/css/rangeslider.css?");

/***/ }),

/***/ "./src/static/vendors/development/css/summernote.css":
/*!***********************************************************!*\
  !*** ./src/static/vendors/development/css/summernote.css ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/vendors/development/css/summernote.css?");

/***/ }),

/***/ "./src/static/vendors/development/css/token-input.css":
/*!************************************************************!*\
  !*** ./src/static/vendors/development/css/token-input.css ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/vendors/development/css/token-input.css?");

/***/ }),

/***/ "./src/static/vendors/development/css/video-js.min.css":
/*!*************************************************************!*\
  !*** ./src/static/vendors/development/css/video-js.min.css ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/vendors/development/css/video-js.min.css?");

/***/ }),

/***/ "./src/static/vendors/development/css/videojs-transcript.css":
/*!*******************************************************************!*\
  !*** ./src/static/vendors/development/css/videojs-transcript.css ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/static/vendors/development/css/videojs-transcript.css?");

/***/ }),

/***/ "./src/static/vendors/development/jQuery-Watch.js":
/*!********************************************************!*\
  !*** ./src/static/vendors/development/jQuery-Watch.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * jQuery Watch Plugin\n *\n * @author Darcy Clarke\n * @version 2.0\n *\n * Copyright (c) 2012 Darcy Clarke\n * Dual licensed under the MIT and GPL licenses.\n *\n * ADDS: \n *\n * - $.watch()\n *  \n * USES:\n *\n * - DOMAttrModified event\n * \n * FALLBACKS:\n * \n * - propertychange event\n * - setTimeout() with delay \n *\n * EXAMPLE:\n * \n * $('div').watch('width height', function(){\n *      console.log(this.style.width, this.style.height);\n * });\n *\n * $('div').animate({width:'100px',height:'200px'}, 500);\n *\n */\n\n(function($){\n    $.extend($.fn, {         \n        /**\n         * Watch Method\n         * \n         * @param {String} the name of the properties to watch\n         * @param {Object} options to overide defaults (only 'throttle' right now)\n         * @param {Function} callback function to be executed when attributes change\n         *\n         * @return {jQuery Object} returns the jQuery object for chainability\n         */   \n        watch : function(props, options, callback){\n            // Dummmy element\n            var element = document.createElement('div');\n\n            /**\n             * Checks Support for Event\n             * \n             * @param {String} the name of the event\n             * @param {Element Object} the element to test support against\n             *\n             * @return {Boolean} returns result of test (true/false)\n             */\n            var isEventSupported = function(eventName, el) {\n                eventName = 'on' + eventName;\n                var supported = (eventName in el);\n                if(!supported){\n                    el.setAttribute(eventName, 'return;');\n                    supported = typeof el[eventName] == 'function';\n                }\n                return supported;\n            };\n            // Type check options\n            if(typeof(options) == 'function'){\n                callback = options;\n                options = {};\n            }\n            // Type check callback\n            if(typeof(callback) != 'function')\n                callback = function(){};\n            // Map options over defaults\n            options = $.extend({}, { throttle : 10 }, options);\n            /**\n             * Checks if properties have changed\n             * \n             * @param {Element Object} the element to watch\n             *\n             */\n            var check = function(el) {\n                var data = el.data(),\n                    changed = false,\n                    temp;\n\n                // Loop through properties\n                var length = typeof data!='undefined' && typeof data.props!='undefined'?data.props.length:0;\n                for(var i=0;i < length; i++){\n                    temp = el.css(data.props[i]);\n                    if(data.vals[i] != temp){\n                        data.vals[i] = temp;\n                        changed = true;\n                        break;\n                    }\n                }\n                // Run callback if property has changed\n                if(changed && data.cb)\n                    data.cb.call(el, data);\n            };\n            return this.each(function(){\n                var el = $(this),\n                    cb = function(){ check.call(this, el) },\n                    data = { props:props.split(','), cb:callback, vals: [] };\n                $.each(data.props, function(i){ data.vals[i] = el.css(data.props[i]); });\n                el.data(data);\n                if(isEventSupported('DOMAttrModified', element)){\n                    el.on('DOMAttrModified', callback);\n                } else if(isEventSupported('propertychange', element)){\n                    el.on('propertychange', callback);\n                } else {\n                    setInterval(cb, options.throttle);\n                }\n            });\n        }\n    });\n})(jQuery);\n\n\n//# sourceURL=webpack:///./src/static/vendors/development/jQuery-Watch.js?");

/***/ }),

/***/ "./src/static/vendors/development/jquery.tokeninput.js":
/*!*************************************************************!*\
  !*** ./src/static/vendors/development/jquery.tokeninput.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n * jQuery Plugin: Tokenizing Autocomplete Text Entry\n * Version 1.6.0\n *\n * Copyright (c) 2009 James Smith (http://loopj.com)\n * Licensed jointly under the GPL and MIT licenses,\n * choose which one suits your project best!\n *\n */\n\n(function ($) {\n// Default settings\nvar DEFAULT_SETTINGS = {\n    // Search settings\n    method: \"GET\",\n    contentType: \"json\",\n    queryParam: \"q\",\n    searchDelay: 300,\n    minChars: 1,\n    propertyToSearch: \"name\",\n    jsonContainer: null,\n\n    // Display settings\n    hintText: \"Type in a search term\",\n    noResultsText: \"Not Found. Hit ENTER to add a personal tag.\",\n    searchingText: \"Searching...\",\n    deleteText: \"&times;\",\n    animateDropdown: true,\n\n    // Tokenization settings\n    tokenLimit: null,\n    tokenDelimiter: \",\",\n    preventDuplicates: true,\n\n    // Output settings\n    tokenValue: \"id\",\n\n    // Prepopulation settings\n    prePopulate: null,\n    processPrePopulate: false,\n\n    // Manipulation settings\n    idPrefix: \"token-input-\",\n\n    // Formatters\n    resultsFormatter: function(item){ return \"<li>\" + item[this.propertyToSearch]+ \"</li>\" },\n    tokenFormatter: function(item) { return \"<li><p>\" + item[this.propertyToSearch] + \"</p></li>\" },\n\n    // Callbacks\n    onResult: null,\n    onAdd: null,\n    onDelete: null,\n    onReady: null\n};\n\n// Default classes to use when theming\nvar DEFAULT_CLASSES = {\n    tokenList: \"token-input-list\",\n    token: \"token-input-token\",\n    tokenDelete: \"token-input-delete-token\",\n    selectedToken: \"token-input-selected-token\",\n    highlightedToken: \"token-input-highlighted-token\",\n    dropdown: \"token-input-dropdown\",\n    dropdownItem: \"token-input-dropdown-item\",\n    dropdownItem2: \"token-input-dropdown-item2\",\n    selectedDropdownItem: \"token-input-selected-dropdown-item\",\n    inputToken: \"token-input-input-token\"\n};\n\n// Input box position \"enum\"\nvar POSITION = {\n    BEFORE: 0,\n    AFTER: 1,\n    END: 2\n};\n\n// Keys \"enum\"\nvar KEY = {\n    BACKSPACE: 8,\n    TAB: 9,\n    ENTER: 13,\n    ESCAPE: 27,\n    SPACE: 32,\n    PAGE_UP: 33,\n    PAGE_DOWN: 34,\n    END: 35,\n    HOME: 36,\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    NUMPAD_ENTER: 108,\n    COMMA: 188\n};\n\n// Additional public (exposed) methods\nvar methods = {\n    init: function(url_or_data_or_function, options) {\n        var settings = $.extend({}, DEFAULT_SETTINGS, options || {});\n\n        return this.each(function () {\n            $(this).data(\"tokenInputObject\", new $.TokenList(this, url_or_data_or_function, settings));\n        });\n    },\n    clear: function() {\n        this.data(\"tokenInputObject\").clear();\n        return this;\n    },\n    add: function(item) {\n        this.data(\"tokenInputObject\").add(item);\n        return this;\n    },\n    remove: function(item) {\n        this.data(\"tokenInputObject\").remove(item);\n        return this;\n    },\n    get: function() {\n        return this.data(\"tokenInputObject\").getTokens();\n       }\n}\n\n// Expose the .tokenInput function to jQuery as a plugin\n$.fn.tokenInput = function (method) {\n    // Method calling and initialization logic\n    if(methods[method]) {\n        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else {\n        return methods.init.apply(this, arguments);\n    }\n};\n\n// TokenList class for each input\n$.TokenList = function (input, url_or_data, settings) {\n    //\n    // Initialization\n    //\n\n    // Configure the data source\n    if($.type(url_or_data) === \"string\" || $.type(url_or_data) === \"function\") {\n        // Set the url to query against\n        settings.url = url_or_data;\n        // If the URL is a function, evaluate it here to do our initalization work\n        var url = computeURL();\n\n        // Make a smart guess about cross-domain if it wasn't explicitly specified\n        if(settings.crossDomain === undefined) {\n            if(url.indexOf(\"://\") === -1) {\n                settings.crossDomain = false;\n            } else {\n                settings.crossDomain = (location.href.split(/\\/+/g)[1] !== url.split(/\\/+/g)[1]);\n            }\n        }\n    } else if(typeof(url_or_data) === \"object\") {\n        // Set the local data to search through\n        settings.local_data = url_or_data;\n    }\n\n    // Build class names\n    if(settings.classes) {\n        // Use custom class names\n        settings.classes = $.extend({}, DEFAULT_CLASSES, settings.classes);\n    } else if(settings.theme) {\n        // Use theme-suffixed default class names\n        settings.classes = {};\n        $.each(DEFAULT_CLASSES, function(key, value) {\n            settings.classes[key] = value + \"-\" + settings.theme;\n        });\n    } else {\n        settings.classes = DEFAULT_CLASSES;\n    }\n\n\n    // Save the tokens\n    var saved_tokens = [];\n\n    // Keep track of the number of tokens in the list\n    var token_count = 0;\n\n    // Basic cache to save on db hits\n    var cache = new $.TokenList.Cache();\n\n    // Keep track of the timeout, old vals\n    var timeout;\n    var input_val;\n\n    // Create a new text input an attach keyup events\n    var input_box = $(\"<input type=\\\"text\\\"  autocomplete=\\\"off\\\">\")\n        .css({\n            outline: \"none\"\n        })\n        .attr(\"id\", settings.idPrefix + input.id)\n        .focus(function () {\n            if (settings.tokenLimit === null || settings.tokenLimit !== token_count) {\n                show_dropdown_hint();\n            }\n        })\n        .blur(function () {\n            hide_dropdown();\n            $(this).val(\"\");\n        })\n        .bind(\"keyup keydown blur update\", resize_input)\n        .keydown(function (event) {\n            var previous_token;\n            var next_token;\n\n            switch(event.keyCode) {\n                case KEY.LEFT:\n                case KEY.RIGHT:\n                case KEY.UP:\n                case KEY.DOWN:\n                    if(!$(this).val()) {\n                        previous_token = input_token.prev();\n                        next_token = input_token.next();\n\n                        if((previous_token.length && previous_token.get(0) === selected_token) || (next_token.length && next_token.get(0) === selected_token)) {\n                            // Check if there is a previous/next token and it is selected\n                            if(event.keyCode === KEY.LEFT || event.keyCode === KEY.UP) {\n                                deselect_token($(selected_token), POSITION.BEFORE);\n                            } else {\n                                deselect_token($(selected_token), POSITION.AFTER);\n                            }\n                        } else if((event.keyCode === KEY.LEFT || event.keyCode === KEY.UP) && previous_token.length) {\n                            // We are moving left, select the previous token if it exists\n                            select_token($(previous_token.get(0)));\n                        } else if((event.keyCode === KEY.RIGHT || event.keyCode === KEY.DOWN) && next_token.length) {\n                            // We are moving right, select the next token if it exists\n                            select_token($(next_token.get(0)));\n                        }\n                    } else {\n                        var dropdown_item = null;\n\n                        if(event.keyCode === KEY.DOWN || event.keyCode === KEY.RIGHT) {\n                            dropdown_item = $(selected_dropdown_item).next();\n                        } else {\n                            dropdown_item = $(selected_dropdown_item).prev();\n                        }\n\n                        if(dropdown_item.length) {\n                            select_dropdown_item(dropdown_item);\n                        }\n                        return false;\n                    }\n                    break;\n\n                case KEY.BACKSPACE:\n                    previous_token = input_token.prev();\n\n                    if(!$(this).val().length) {\n                        if(selected_token) {\n                            delete_token($(selected_token));\n                            hidden_input.change();\n                        } else if(previous_token.length) {\n                            select_token($(previous_token.get(0)));\n                        }\n\n                        return false;\n                    } else if($(this).val().length === 1) {\n                        hide_dropdown();\n                    } else {\n                        // set a timeout just long enough to let this function finish.\n                        setTimeout(function(){do_search();}, 5);\n                    }\n                    break;\n\n                case KEY.TAB:\n                case KEY.ENTER:\n                case KEY.NUMPAD_ENTER:\n                case KEY.COMMA:\n                case KEY.SPACE:\n                  if(selected_dropdown_item) {\n                    add_token($(selected_dropdown_item).data(\"tokeninput\"));\n                    // this allows for tags to be color-coded based on instructor set-up\n                    if (typeof Annotator !== \"undefined\") {\n                        Annotator._instances[0].publish(\"colorEditorTags\");\n                    } else {\n                        window.AController.targetObjectController.colorizeEditor();\n                    }\n                    hidden_input.change();\n                    return false;\n                  } else{\n                    add_token({id:$(input_box).val(), name:$(input_box).val()});\n                    hidden_input.change();\n                  } \n                  break;\n\n                case KEY.ESCAPE:\n                  hide_dropdown();\n                  return true;\n\n                default:\n                    if(String.fromCharCode(event.which)) {\n                        // set a timeout just long enough to let this function finish.\n                        setTimeout(function(){do_search();}, 5);\n                    }\n                    break;\n            }\n        });\n\n    // Keep a reference to the original input box\n    var hidden_input = $(input)\n                           .hide()\n                           .val(\"\")\n                           .focus(function () {\n                               input_box.focus();\n                           })\n                           .blur(function () {\n                               input_box.blur();\n                           });\n\n    // Keep a reference to the selected token and dropdown item\n    var selected_token = null;\n    var selected_token_index = 0;\n    var selected_dropdown_item = null;\n\n    // The list to store the token items in\n    var token_list = $(\"<ol />\")\n        .addClass(settings.classes.tokenList)\n        .click(function (event) {\n            var li = $(event.target).closest(\"li\");\n            if(li && li.get(0) && $.data(li.get(0), \"tokeninput\")) {\n                toggle_select_token(li);\n            } else {\n                // Deselect selected token\n                if(selected_token) {\n                    deselect_token($(selected_token), POSITION.END);\n                }\n\n                // Focus input box\n                input_box.focus();\n            }\n        })\n        .mouseover(function (event) {\n            var li = $(event.target).closest(\"li\");\n            if(li && selected_token !== this) {\n                li.addClass(settings.classes.highlightedToken);\n            }\n        })\n        .mouseout(function (event) {\n            var li = $(event.target).closest(\"li\");\n            if(li && selected_token !== this) {\n                li.removeClass(settings.classes.highlightedToken);\n            }\n        })\n        .insertBefore(hidden_input);\n\n    // The token holding the input box\n    var input_token = $(\"<li />\")\n        .addClass(settings.classes.inputToken)\n        .appendTo(token_list)\n        .append(input_box);\n\n    // The list to store the dropdown items in\n    var dropdown = $(\"<div>\")\n        .addClass(settings.classes.dropdown)\n        .appendTo(\"body\")\n        .hide();\n\n    // Magic element to help us resize the text input\n    var input_resizer = $(\"<tester/>\")\n        .insertAfter(input_box)\n        .css({\n            position: \"absolute\",\n            top: -9999,\n            left: -9999,\n            width: \"auto\",\n            fontSize: input_box.css(\"fontSize\"),\n            fontFamily: input_box.css(\"fontFamily\"),\n            fontWeight: input_box.css(\"fontWeight\"),\n            letterSpacing: input_box.css(\"letterSpacing\"),\n            whiteSpace: \"nowrap\"\n        });\n\n    // Pre-populate list if items exist\n    hidden_input.val(\"\");\n    var li_data = settings.prePopulate || hidden_input.data(\"pre\");\n    if(settings.processPrePopulate && $.isFunction(settings.onResult)) {\n        li_data = settings.onResult.call(hidden_input, li_data);\n    }\n    if(li_data && li_data.length) {\n        $.each(li_data, function (index, value) {\n            insert_token(value);\n            checkTokenLimit();\n        });\n    }\n\n    // Initialization is done\n    if($.isFunction(settings.onReady)) {\n        settings.onReady.call();\n    }\n\n    //\n    // Public functions\n    //\n\n    this.clear = function() {\n        token_list.children(\"li\").each(function() {\n            if ($(this).children(\"input\").length === 0) {\n                delete_token($(this));\n            }\n        });\n    }\n\n    this.add = function(item) {\n        add_token(item);\n    }\n\n    this.remove = function(item) {\n        token_list.children(\"li\").each(function() {\n            if ($(this).children(\"input\").length === 0) {\n                var currToken = $(this).data(\"tokeninput\");\n                var match = true;\n                for (var prop in item) {\n                    if (item[prop] !== currToken[prop]) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) {\n                    delete_token($(this));\n                }\n            }\n        });\n    }\n    \n    this.getTokens = function() {\n           return saved_tokens;\n       }\n\n    //\n    // Private functions\n    //\n\n    function checkTokenLimit() {\n        if(settings.tokenLimit !== null && token_count >= settings.tokenLimit) {\n            input_box.hide();\n            hide_dropdown();\n            return;\n        }\n    }\n\n    function resize_input() {\n        if(input_val === (input_val = input_box.val())) {return;}\n\n        // Enter new content into resizer and resize input accordingly\n        var escaped = input_val.replace(/&/g, '&amp;').replace(/\\s/g,' ').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n        input_resizer.html(escaped);\n        input_box.width(input_resizer.width() + 30);\n    }\n\n    function is_printable_character(keycode) {\n        return ((keycode >= 48 && keycode <= 90) ||     // 0-1a-z\n                (keycode >= 96 && keycode <= 111) ||    // numpad 0-9 + - / * .\n                (keycode >= 186 && keycode <= 192) ||   // ; = , - . / ^\n                (keycode >= 219 && keycode <= 222));    // ( \\ ) '\n    }\n\n    // Inner function to a token to the list\n    function insert_token(item) {\n        var this_token = settings.tokenFormatter(item);\n        this_token = $(this_token)\n          .addClass(settings.classes.token)\n          .insertBefore(input_token);\n\n        // The 'delete token' button\n        $(\"<span>\" + settings.deleteText + \"</span>\")\n            .addClass(settings.classes.tokenDelete)\n            .appendTo(this_token)\n            .click(function () {\n                delete_token($(this).parent());\n                hidden_input.change();\n                return false;\n            });\n\n        // Store data on the token\n        var token_data = {\"id\": item.id, \"name\": item.id};\n        token_data[settings.propertyToSearch] = item[settings.propertyToSearch];\n        $.data(this_token.get(0), \"tokeninput\", item);\n\n        // Save this token for duplicate checking\n        saved_tokens = saved_tokens.slice(0,selected_token_index).concat([token_data]).concat(saved_tokens.slice(selected_token_index));\n        selected_token_index++;\n\n        // Update the hidden input\n        update_hidden_input(saved_tokens, hidden_input);\n\n        token_count += 1;\n\n        // Check the token limit\n        if(settings.tokenLimit !== null && token_count >= settings.tokenLimit) {\n            input_box.hide();\n            hide_dropdown();\n        }\n\n        return this_token;\n    }\n\n    // Add a token to the token list based on user input\n    function add_token (item) {\n        var callback = settings.onAdd;\n\n        // See if the token already exists and select it if we don't want duplicates\n        if(token_count > 0 && settings.preventDuplicates) {\n            var found_existing_token = null;\n            token_list.children().each(function () {\n                var existing_token = $(this);\n                var existing_data = $.data(existing_token.get(0), \"tokeninput\");\n                if(existing_data && existing_data.id === item.id) {\n                    found_existing_token = existing_token;\n                    return false;\n                }\n            });\n\n            if(found_existing_token) {\n                select_token(found_existing_token);\n                //input_token.insertAfter(found_existing_token);\n                input_box.focus();\n                return;\n            }\n        }\n\n        // Insert the new tokens\n        if(settings.tokenLimit == null || token_count < settings.tokenLimit) {\n            insert_token(item);\n            checkTokenLimit();\n        }\n\n        // Clear input box\n        input_box.val(\"\");\n\n        // Don't show the help dropdown, they've got the idea\n        hide_dropdown();\n\n        // Execute the onAdd callback if defined\n        if($.isFunction(callback)) {\n            callback.call(hidden_input,item);\n        }\n    }\n\n    // Select a token in the token list\n    function select_token (token) {\n        token.addClass(settings.classes.selectedToken);\n        selected_token = token.get(0);\n\n        // Hide input box\n        input_box.val(\"\");\n\n        // Hide dropdown if it is visible (eg if we clicked to select token)\n        hide_dropdown();\n    }\n\n    // Deselect a token in the token list\n    function deselect_token (token, position) {\n        token.removeClass(settings.classes.selectedToken);\n        selected_token = null;\n\n        if(position === POSITION.BEFORE) {\n            input_token.insertBefore(token);\n            selected_token_index--;\n        } else if(position === POSITION.AFTER) {\n            //input_token.insertAfter(token);\n            selected_token_index++;\n        } else {\n            input_token.appendTo(token_list);\n            selected_token_index = token_count;\n        }\n\n        // Show the input box and give it focus again\n        input_box.focus();\n    }\n\n    // Toggle selection of a token in the token list\n    function toggle_select_token(token) {\n        var previous_selected_token = selected_token;\n\n        if(selected_token) {\n            deselect_token($(selected_token), POSITION.END);\n        }\n\n        if(previous_selected_token === token.get(0)) {\n            deselect_token(token, POSITION.END);\n        } else {\n            select_token(token);\n        }\n    }\n\n    // Delete a token from the token list\n    function delete_token (token) {\n        // Remove the id from the saved list\n        var token_data = $.data(token.get(0), \"tokeninput\");\n        var callback = settings.onDelete;\n\n        var index = token.prevAll().length;\n        if(index > selected_token_index) index--;\n\n        // Delete the token\n        token.remove();\n        selected_token = null;\n\n        // Show the input box and give it focus again\n        input_box.focus();\n\n        // Remove this token from the saved list\n        saved_tokens = saved_tokens.slice(0,index).concat(saved_tokens.slice(index+1));\n        if(index < selected_token_index) selected_token_index--;\n\n        // Update the hidden input\n        update_hidden_input(saved_tokens, hidden_input);\n\n        token_count -= 1;\n\n        if(settings.tokenLimit !== null) {\n            input_box\n                .show()\n                .val(\"\")\n                .focus();\n        }\n\n        // Execute the onDelete callback if defined\n        if($.isFunction(callback)) {\n            callback.call(hidden_input,token_data);\n        }\n    }\n\n    // Update the hidden input box value\n    function update_hidden_input(saved_tokens, hidden_input) {\n        var token_values = $.map(saved_tokens, function (el) {\n            return el[settings.tokenValue];\n        });\n        hidden_input.val(token_values.join(settings.tokenDelimiter));\n\n    }\n\n    // Hide and clear the results dropdown\n    function hide_dropdown () {\n        dropdown.hide().empty();\n        selected_dropdown_item = null;\n    }\n\n    function show_dropdown() {\n        dropdown\n            .css({\n                position: \"absolute\",\n                top: $(token_list).offset().top + $(token_list).outerHeight(),\n                left: $(token_list).offset().left,\n                zindex: 999\n            })\n            .show();\n    }\n\n    function show_dropdown_searching () {\n        if(settings.searchingText) {\n            dropdown.html(\"<p>\"+settings.searchingText+\"</p>\");\n            show_dropdown();\n        }\n    }\n\n    function show_dropdown_hint () {\n        if(settings.hintText) {\n            dropdown.html(\"<p>\"+settings.hintText+\"</p>\");\n            show_dropdown();\n        }\n    }\n\n    // Highlight the query part of the search term\n    function highlight_term(value, term) {\n        return value.replace(new RegExp(\"(?![^&;]+;)(?!<[^<>]*)(\" + term + \")(?![^<>]*>)(?![^&;]+;)\", \"gi\"), \"<b>$1</b>\");\n    }\n    \n    function find_value_and_highlight_term(template, value, term) {\n        return template.replace(new RegExp(\"(?![^&;]+;)(?!<[^<>]*)(\" + value + \")(?![^<>]*>)(?![^&;]+;)\", \"g\"), highlight_term(value, term));\n    }\n\n    // Populate the results dropdown with some results\n    function populate_dropdown (query, results) {\n        if(results && results.length) {\n            dropdown.empty();\n            var dropdown_ul = $(\"<ul>\")\n                .appendTo(dropdown)\n                .mouseover(function (event) {\n                    select_dropdown_item($(event.target).closest(\"li\"));\n                })\n                .mousedown(function (event) {\n                    add_token($(event.target).closest(\"li\").data(\"tokeninput\"));\n                    hidden_input.change();\n                    return false;\n                })\n                .hide();\n\n            $.each(results, function(index, value) {\n                var this_li = settings.resultsFormatter(value);\n                \n                this_li = find_value_and_highlight_term(this_li ,value[settings.propertyToSearch], query);            \n                \n                this_li = $(this_li).appendTo(dropdown_ul);\n                \n                if(index % 2) {\n                    this_li.addClass(settings.classes.dropdownItem);\n                } else {\n                    this_li.addClass(settings.classes.dropdownItem2);\n                }\n\n                if(index === 0) {\n                    select_dropdown_item(this_li);\n                }\n\n                $.data(this_li.get(0), \"tokeninput\", value);\n            });\n\n            show_dropdown();\n\n            if(settings.animateDropdown) {\n                dropdown_ul.slideDown(\"fast\");\n            } else {\n                dropdown_ul.show();\n            }\n        } else {\n            if(settings.noResultsText) {\n                dropdown.html(\"<p>\"+settings.noResultsText+\"</p>\");\n                show_dropdown();\n            }\n        }\n    }\n\n    // Highlight an item in the results dropdown\n    function select_dropdown_item (item) {\n        if(item) {\n            if(selected_dropdown_item) {\n                deselect_dropdown_item($(selected_dropdown_item));\n            }\n\n            item.addClass(settings.classes.selectedDropdownItem);\n            selected_dropdown_item = item.get(0);\n        }\n    }\n\n    // Remove highlighting from an item in the results dropdown\n    function deselect_dropdown_item (item) {\n        item.removeClass(settings.classes.selectedDropdownItem);\n        selected_dropdown_item = null;\n    }\n\n    // Do a search and show the \"searching\" dropdown if the input is longer\n    // than settings.minChars\n    function do_search() {\n        var query = input_box.val().toLowerCase();\n        if(query && query.length) {\n            if(selected_token) {\n                deselect_token($(selected_token), POSITION.AFTER);\n            }\n\n            if(query.length >= settings.minChars) {\n                show_dropdown_searching();\n                clearTimeout(timeout);\n\n                timeout = setTimeout(function(){\n                    run_search(query);\n                }, settings.searchDelay);\n            } else {\n                hide_dropdown();\n            }\n        }\n    }\n\n    // Do the actual search\n    function run_search(query) {\n        var cache_key = query + computeURL();\n        var cached_results = cache.get(cache_key);\n        if(cached_results) {\n            populate_dropdown(query, cached_results);\n        } else {\n            // Are we doing an ajax search or local data search?\n            if(settings.url && !(typeof settings.url === \"undefined\") ) {\n                var url = computeURL();\n                // Extract exisiting get params\n                var ajax_params = {};\n                ajax_params.data = {};\n                if(url.indexOf(\"?\") > -1) {\n                    var parts = url.split(\"?\");\n                    ajax_params.url = parts[0];\n\n                    var param_array = parts[1].split(\"&\");\n                    $.each(param_array, function (index, value) {\n                        var kv = value.split(\"=\");\n                        ajax_params.data[kv[0]] = kv[1];\n                    });\n                } else {\n                    ajax_params.url = url;\n                }\n\n                // Prepare the request\n                ajax_params.data[settings.queryParam] = query;\n                ajax_params.type = settings.method;\n                ajax_params.dataType = settings.contentType;\n                if(settings.crossDomain) {\n                    ajax_params.dataType = \"jsonp\";\n                }\n\n                // Attach the success callback\n                ajax_params.success = function(results) {\n                  if($.isFunction(settings.onResult)) {\n                      results = settings.onResult.call(hidden_input, results);\n                  }\n                  cache.add(cache_key, settings.jsonContainer ? results[settings.jsonContainer] : results);\n\n                  // only populate the dropdown if the results are associated with the active search query\n                  if(input_box.val().toLowerCase() === query) {\n                      populate_dropdown(query, settings.jsonContainer ? results[settings.jsonContainer] : results);\n                  }\n                };\n\n                // Make the request\n                $.ajax(ajax_params);\n            } else if(settings.local_data) {\n                // Do the search through local data\n                var results = $.grep(settings.local_data, function (row) {\n                    return row[settings.propertyToSearch].toLowerCase().indexOf(query.toLowerCase()) > -1;\n                });\n\n                if($.isFunction(settings.onResult)) {\n                    results = settings.onResult.call(hidden_input, results);\n                }\n                cache.add(cache_key, results);\n                populate_dropdown(query, results);\n            }\n        }\n    }\n\n    // compute the dynamic URL\n    function computeURL() {\n        var url = settings.url;\n        if(typeof settings.url == 'function') {\n            url = settings.url.call();\n        }\n        return url;\n    }\n};\n\n// Really basic cache for the results\n$.TokenList.Cache = function (options) {\n    var settings = $.extend({\n        max_size: 500\n    }, options);\n\n    var data = {};\n    var size = 0;\n\n    var flush = function () {\n        data = {};\n        size = 0;\n    };\n\n    this.add = function (query, results) {\n        if(size > settings.max_size) {\n            flush();\n        }\n\n        if(!data[query]) {\n            size += 1;\n        }\n\n        data[query] = results;\n    };\n\n    this.get = function (query) {\n        return data[query];\n    };\n};\n}(jQuery));\n\n//# sourceURL=webpack:///./src/static/vendors/development/jquery.tokeninput.js?");

/***/ }),

/***/ "./src/static/vendors/development/json2.js":
/*!*************************************************!*\
  !*** ./src/static/vendors/development/json2.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n    json2.js\n    2015-05-03\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    See http://www.JSON.org/js.html\n\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n\n\n    This file creates a global JSON object containing two methods: stringify\n    and parse. This file is provides the ES5 JSON capability to ES3 systems.\n    If a project might run on IE8 or earlier, then this file should be included.\n    This file does nothing on ES5 systems.\n\n        JSON.stringify(value, replacer, space)\n            value       any JavaScript value, usually an object or array.\n\n            replacer    an optional parameter that determines how object\n                        values are stringified for objects. It can be a\n                        function or an array of strings.\n\n            space       an optional parameter that specifies the indentation\n                        of nested structures. If it is omitted, the text will\n                        be packed without extra whitespace. If it is a number,\n                        it will specify the number of spaces to indent at each\n                        level. If it is a string (such as '\\t' or '&nbsp;'),\n                        it contains the characters used to indent at each level.\n\n            This method produces a JSON text from a JavaScript value.\n\n            When an object value is found, if the object contains a toJSON\n            method, its toJSON method will be called and the result will be\n            stringified. A toJSON method does not serialize: it returns the\n            value represented by the name/value pair that should be serialized,\n            or undefined if nothing should be serialized. The toJSON method\n            will be passed the key associated with the value, and this will be\n            bound to the value\n\n            For example, this would serialize Dates as ISO strings.\n\n                Date.prototype.toJSON = function (key) {\n                    function f(n) {\n                        // Format integers to have at least two digits.\n                        return n < 10 \n                            ? '0' + n \n                            : n;\n                    }\n\n                    return this.getUTCFullYear()   + '-' +\n                         f(this.getUTCMonth() + 1) + '-' +\n                         f(this.getUTCDate())      + 'T' +\n                         f(this.getUTCHours())     + ':' +\n                         f(this.getUTCMinutes())   + ':' +\n                         f(this.getUTCSeconds())   + 'Z';\n                };\n\n            You can provide an optional replacer method. It will be passed the\n            key and value of each member, with this bound to the containing\n            object. The value that is returned from your method will be\n            serialized. If your method returns undefined, then the member will\n            be excluded from the serialization.\n\n            If the replacer parameter is an array of strings, then it will be\n            used to select the members to be serialized. It filters the results\n            such that only members with keys listed in the replacer array are\n            stringified.\n\n            Values that do not have JSON representations, such as undefined or\n            functions, will not be serialized. Such values in objects will be\n            dropped; in arrays they will be replaced with null. You can use\n            a replacer function to replace those with JSON values.\n            JSON.stringify(undefined) returns undefined.\n\n            The optional space parameter produces a stringification of the\n            value that is filled with line breaks and indentation to make it\n            easier to read.\n\n            If the space parameter is a non-empty string, then that string will\n            be used for indentation. If the space parameter is a number, then\n            the indentation will be that many spaces.\n\n            Example:\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}]);\n            // text is '[\"e\",{\"pluribus\":\"unum\"}]'\n\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\\t');\n            // text is '[\\n\\t\"e\",\\n\\t{\\n\\t\\t\"pluribus\": \"unum\"\\n\\t}\\n]'\n\n            text = JSON.stringify([new Date()], function (key, value) {\n                return this[key] instanceof Date \n                    ? 'Date(' + this[key] + ')' \n                    : value;\n            });\n            // text is '[\"Date(---current time---)\"]'\n\n\n        JSON.parse(text, reviver)\n            This method parses a JSON text to produce an object or array.\n            It can throw a SyntaxError exception.\n\n            The optional reviver parameter is a function that can filter and\n            transform the results. It receives each of the keys and values,\n            and its return value is used instead of the original value.\n            If it returns what it received, then the structure is not modified.\n            If it returns undefined then the member is deleted.\n\n            Example:\n\n            // Parse the text. Values that look like ISO date strings will\n            // be converted to Date objects.\n\n            myData = JSON.parse(text, function (key, value) {\n                var a;\n                if (typeof value === 'string') {\n                    a =\n/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n                    if (a) {\n                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n                            +a[5], +a[6]));\n                    }\n                }\n                return value;\n            });\n\n            myData = JSON.parse('[\"Date(09/09/2001)\"]', function (key, value) {\n                var d;\n                if (typeof value === 'string' &&\n                        value.slice(0, 5) === 'Date(' &&\n                        value.slice(-1) === ')') {\n                    d = new Date(value.slice(5, -1));\n                    if (d) {\n                        return d;\n                    }\n                }\n                return value;\n            });\n\n\n    This is a reference implementation. You are free to copy, modify, or\n    redistribute.\n*/\n\n/*jslint \n    eval, for, this \n*/\n\n/*property\n    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\n    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\n    lastIndex, length, parse, prototype, push, replace, slice, stringify,\n    test, toJSON, toString, valueOf\n*/\n\n\n// Create a JSON object only if one does not already exist. We create the\n// methods in a closure to avoid creating global variables.\n\nif (typeof JSON !== 'object') {\n    JSON = {};\n}\n\n(function () {\n    'use strict';\n    \n    var rx_one = /^[\\],:{}\\s]*$/,\n        rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\n        rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\n        rx_four = /(?:^|:|,)(?:\\s*\\[)+/g,\n        rx_escapable = /[\\\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\n    function f(n) {\n        // Format integers to have at least two digits.\n        return n < 10 \n            ? '0' + n \n            : n;\n    }\n    \n    function this_value() {\n        return this.valueOf();\n    }\n\n    if (typeof Date.prototype.toJSON !== 'function') {\n\n        Date.prototype.toJSON = function () {\n\n            return isFinite(this.valueOf())\n                ? this.getUTCFullYear() + '-' +\n                        f(this.getUTCMonth() + 1) + '-' +\n                        f(this.getUTCDate()) + 'T' +\n                        f(this.getUTCHours()) + ':' +\n                        f(this.getUTCMinutes()) + ':' +\n                        f(this.getUTCSeconds()) + 'Z'\n                : null;\n        };\n\n        Boolean.prototype.toJSON = this_value;\n        Number.prototype.toJSON = this_value;\n        String.prototype.toJSON = this_value;\n    }\n\n    var gap,\n        indent,\n        meta,\n        rep;\n\n\n    function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n        rx_escapable.lastIndex = 0;\n        return rx_escapable.test(string) \n            ? '\"' + string.replace(rx_escapable, function (a) {\n                var c = meta[a];\n                return typeof c === 'string'\n                    ? c\n                    : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n            }) + '\"' \n            : '\"' + string + '\"';\n    }\n\n\n    function str(key, holder) {\n\n// Produce a string from holder[key].\n\n        var i,          // The loop counter.\n            k,          // The member key.\n            v,          // The member value.\n            length,\n            mind = gap,\n            partial,\n            value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n        if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n            value = value.toJSON(key);\n        }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n        if (typeof rep === 'function') {\n            value = rep.call(holder, key, value);\n        }\n\n// What happens next depends on the value's type.\n\n        switch (typeof value) {\n        case 'string':\n            return quote(value);\n\n        case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n            return isFinite(value) \n                ? String(value) \n                : 'null';\n\n        case 'boolean':\n        case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n            return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n        case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n            if (!value) {\n                return 'null';\n            }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n            gap += indent;\n            partial = [];\n\n// Is the value an array?\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n                v = partial.length === 0\n                    ? '[]'\n                    : gap\n                        ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']'\n                        : '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    if (typeof rep[i] === 'string') {\n                        k = rep[i];\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (\n                                gap \n                                    ? ': ' \n                                    : ':'\n                            ) + v);\n                        }\n                    }\n                }\n            } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (\n                                gap \n                                    ? ': ' \n                                    : ':'\n                            ) + v);\n                        }\n                    }\n                }\n            }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n            v = partial.length === 0\n                ? '{}'\n                : gap\n                    ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}'\n                    : '{' + partial.join(',') + '}';\n            gap = mind;\n            return v;\n        }\n    }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n    if (typeof JSON.stringify !== 'function') {\n        meta = {    // table of character substitutions\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\"': '\\\\\"',\n            '\\\\': '\\\\\\\\'\n        };\n        JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n            var i;\n            gap = '';\n            indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n            if (typeof space === 'number') {\n                for (i = 0; i < space; i += 1) {\n                    indent += ' ';\n                }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n            } else if (typeof space === 'string') {\n                indent = space;\n            }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n            rep = replacer;\n            if (replacer && typeof replacer !== 'function' &&\n                    (typeof replacer !== 'object' ||\n                    typeof replacer.length !== 'number')) {\n                throw new Error('JSON.stringify');\n            }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n            return str('', {'': value});\n        };\n    }\n\n\n// If the JSON object does not yet have a parse method, give it one.\n\n    if (typeof JSON.parse !== 'function') {\n        JSON.parse = function (text, reviver) {\n\n// The parse method takes a text and an optional reviver function, and returns\n// a JavaScript value if the text is a valid JSON text.\n\n            var j;\n\n            function walk(holder, key) {\n\n// The walk method is used to recursively walk the resulting structure so\n// that modifications can be made.\n\n                var k, v, value = holder[key];\n                if (value && typeof value === 'object') {\n                    for (k in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, k)) {\n                            v = walk(value, k);\n                            if (v !== undefined) {\n                                value[k] = v;\n                            } else {\n                                delete value[k];\n                            }\n                        }\n                    }\n                }\n                return reviver.call(holder, key, value);\n            }\n\n\n// Parsing happens in four stages. In the first stage, we replace certain\n// Unicode characters with escape sequences. JavaScript handles many characters\n// incorrectly, either silently deleting them, or treating them as line endings.\n\n            text = String(text);\n            rx_dangerous.lastIndex = 0;\n            if (rx_dangerous.test(text)) {\n                text = text.replace(rx_dangerous, function (a) {\n                    return '\\\\u' +\n                            ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                });\n            }\n\n// In the second stage, we run the text against regular expressions that look\n// for non-JSON patterns. We are especially concerned with '()' and 'new'\n// because they can cause invocation, and '=' because it can cause mutation.\n// But just to be safe, we want to reject all unexpected forms.\n\n// We split the second stage into 4 regexp operations in order to work around\n// crippling inefficiencies in IE's and Safari's regexp engines. First we\n// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n// replace all simple value tokens with ']' characters. Third, we delete all\n// open brackets that follow a colon or comma or that begin the text. Finally,\n// we look to see that the remaining characters are only whitespace or ']' or\n// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n            if (\n                rx_one.test(\n                    text\n                        .replace(rx_two, '@')\n                        .replace(rx_three, ']')\n                        .replace(rx_four, '')\n                )\n            ) {\n\n// In the third stage we use the eval function to compile the text into a\n// JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n// in JavaScript: it can begin a block or an object literal. We wrap the text\n// in parens to eliminate the ambiguity.\n\n                j = eval('(' + text + ')');\n\n// In the optional fourth stage, we recursively walk the new structure, passing\n// each name/value pair to a reviver function for possible transformation.\n\n                return typeof reviver === 'function'\n                    ? walk({'': j}, '')\n                    : j;\n            }\n\n// If the text is not JSON parseable, then a SyntaxError is thrown.\n\n            throw new SyntaxError('JSON.parse');\n        };\n    }\n}());\n\n\n//# sourceURL=webpack:///./src/static/vendors/development/json2.js?");

/***/ }),

/***/ "./src/static/vendors/development/rangeslider.js":
/*!*******************************************************!*\
  !*** ./src/static/vendors/development/rangeslider.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(videojs) {/* \nRangeSlider v1.0 (https://github.com/danielcebrian/rangeslider-videojs)\nCopyright (C) 2014 Daniel Cebrian Robles\nLicense: https://github.com/danielcebrian/rangeslider-videojs/blob/master/License.rst\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n*/\n//----------------Load Plugin----------------//\n(function (){\n//-- Load RangeSlider plugin in videojs\nfunction RangeSlider_(options){\n\tvar player = this;\n\t\n\tplayer.rangeslider=new RangeSlider(player, options);\n\t\n\t//When the DOM and the video media is loaded\n\tfunction initialVideoFinished(event) {\n\t\tvar plugin = player.rangeslider;\n\t\t//All components will be initialize after they have been loaded by videojs\n\t\tfor (var index in plugin.components) {\n\t\t\tplugin.components[index].init_();\n\t\t}\n\t\t\n\t\tif (plugin.options.hidden)\n\t\t\tplugin.hide(); //Hide the Range Slider\n\t\t\t\n\t\tif(plugin.options.locked) \n\t\t\tplugin.lock(); //Lock the Range Slider\n\t\t\t\n\t\tif(plugin.options.panel==false) \n\t\t\tplugin.hidePanel(); //Hide the second Panel\n\t\t\t\n\t\tif(plugin.options.controlTime==false) \n\t\t\tplugin.hidecontrolTime(); //Hide the control time panel\n\n\t\tplugin._reset();\n\t\tplayer.trigger('loadedRangeSlider'); //Let know if the Range Slider DOM is ready\n\t}\n\tif (player.techName == 'Youtube'){\n\t\t//Detect youtube problems\n\t\tplayer.one('error', function(e){\n\t\t\tswitch (player.error) {\n\t\t\t\tcase 2:\n\t\t\t\t\talert(\"The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.\");\n\t\t\t\tcase 5:\n\t\t\t\t\talert(\"The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.\");\n\t\t\t\tcase 100:\n\t\t\t\t\talert(\"The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 101:\n\t\t\t\t\talert(\"The owner of the requested video does not allow it to be played in embedded players.\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 150:\n\t\t\t\t\talert(\"The owner of the requested video does not allow it to be played in embedded players.\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\talert(\"Unknown Error\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\tplayer.on('firstplay', initialVideoFinished);\n\t}else{\n\t\tplayer.one('playing', initialVideoFinished);\n\t}\n\t\n\t\n\t//console.log(\"Loaded Plugin RangeSlider\");\n}\nvideojs.plugin('rangeslider', RangeSlider_);\n\n\n\n//-- Plugin\nfunction RangeSlider(player,options){\n\tvar player = player || this;\n\t\n\tthis.player = player;\n\t\n\tthis.components = {}; // holds any custom components we add to the player\n\n\toptions = options || {}; // plugin options\n\t\n\tif(!options.hasOwnProperty('locked')) \n\t\toptions.locked = false; // lock slider handles\n\t\t\n\tif(!options.hasOwnProperty('hidden')) \n\t\toptions.hidden = true; // hide slider handles\n\t\t\n\tif(!options.hasOwnProperty('panel')) \n\t\toptions.panel = true; // Show Second Panel\n\t\t\n\tif(!options.hasOwnProperty('controlTime')) \n\t\toptions.controlTime = true; // Show Control Time to set the arrows in the edition\n\t\n\tthis.options = options;\n\t\n\tthis.init();\n}\n\n//-- Methods\nRangeSlider.prototype = {\n\t/*Constructor*/\n\tinit:function(){\n\t\tvar player = this.player || {};\n\t\t\n\t\tthis.updatePrecision = 3;\n\t\t\n\t\t//position in second of the arrows\n\t\tthis.start = 0;\n\t\tthis.end = 0;\n\t\t\n\t\t//components of the plugin\n\t\tvar controlBar = player.controlBar;\n\t\tvar seekBar = controlBar.progressControl.seekBar;\n\t\tthis.components.RSTimeBar = seekBar.RSTimeBar;\n\t\tthis.components.ControlTimePanel = controlBar.ControlTimePanel;\n\t\t\n\t\t//Save local component \n\t\tthis.rstb = this.components.RSTimeBar;\n\t\tthis.box = this.components.SeekRSBar = this.rstb.SeekRSBar;\n\t\tthis.bar = this.components.SelectionBar = this.box.SelectionBar;\n\t\tthis.left = this.components.SelectionBarLeft = this.box.SelectionBarLeft;\n\t\tthis.right = this.components.SelectionBarRight = this.box.SelectionBarRight;\n\t\tthis.tp = this.components.TimePanel = this.box.TimePanel;\n\t\tthis.tpl = this.components.TimePanelLeft = this.tp.TimePanelLeft;\n\t\tthis.tpr = this.components.TimePanelRight = this.tp.TimePanelRight;\n\t\tthis.ctp = this.components.ControlTimePanel;\n\t\tthis.ctpl = this.components.ControlTimePanelLeft = this.ctp.ControlTimePanelLeft;\n\t\tthis.ctpr = this.components.ControlTimePanelRight = this.ctp.ControlTimePanelRight;\n\t\t\n\t},\n\tlock: function() {\n\t\tthis.options.locked = true;\n\t\tthis.ctp.enable(false);\n\t\tif (typeof this.box != 'undefined')\n\t\t\tvideojs.addClass(this.box.el_, 'locked');\n\t},\n\tunlock: function() {\n\t\tthis.options.locked = false;\n\t\tthis.ctp.enable();\n\t\tif (typeof this.box !='undefined')\n\t\t\tvideojs.removeClass(this.box.el_, 'locked');\n\t},\n\tshow:function(){\n\t\tthis.options.hidden = false;\n\t\tif (typeof this.rstb !='undefined'){\n\t\t\tthis.rstb.show();\n\t\t\tif (this.options.controlTime)\n\t\t\t\tthis.showcontrolTime();\n\t\t}\n\t},\n\thide:function(){\n\t\tthis.options.hidden = true;\n\t\tif (typeof this.rstb !='undefined'){\n\t\t\tthis.rstb.hide();\n\t\t\tthis.ctp.hide();\n\t\t}\n\t},\n\tshowPanel:function(){\n\t\tthis.options.panel = true;\n\t\tif (typeof this.tp !='undefined')\n\t\t\tvideojs.removeClass(this.tp.el_, 'disable');\t\t\t\n\t},\n\thidePanel:function(){\n\t\tthis.options.panel = false;\n\t\tif (typeof this.tp !='undefined')\n\t\t\tvideojs.addClass(this.tp.el_, 'disable');\t\n\t},\n\tshowcontrolTime:function(){\n\t\tthis.options.controlTime = true;\n\t\tif (typeof this.ctp !='undefined')\n\t\t\tthis.ctp.show();\n\t},\n\thidecontrolTime:function(){\n\t\tthis.options.controlTime = false;\n\t\tif (typeof this.ctp !='undefined')\n\t\t\tthis.ctp.hide();\n\t},\n\tsetValue: function(index, seconds, writeControlTime) {\n\t\t//index = 0 for the left Arrow and 1 for the right Arrow. Value in seconds\n\t\tvar writeControlTime = typeof writeControlTime!='undefined'?writeControlTime:true;\n\t\t\n\t\tvar percent = this._percent(seconds);\n\t\tvar isValidIndex = (index === 0 || index === 1);\n\t\tvar isChangeable = !this.locked;\n\t\tif(isChangeable && isValidIndex)\n\t\t\tthis.box.setPosition(index,percent,writeControlTime);\n\t},\n\tsetValues: function(start, end, writeControlTime) {\n\t\t//index = 0 for the left Arrow and 1 for the right Arrow. Value in seconds\n\t\tvar writeControlTime = typeof writeControlTime!='undefined'?writeControlTime:true;\n\t\t\n\t\tthis._reset();\n\t\t\n\t\tthis._setValuesLocked(start,end,writeControlTime);\n\t},\n\tgetValues: function() { //get values in seconds\n\t\tvar values = {}, start, end;\n\t\tstart = this.start || this._getArrowValue(0);\n\t\tend = this.end || this._getArrowValue(1);\n\t\treturn {start:start, end:end};\n\t},\n\tplayBetween: function(start, end,showRS) {\n\t\tshowRS = typeof showRS == 'undefined'?true:showRS;\n\t\tthis.player.currentTime(start);\n\t\tthis.player.play();\n\t\tif (showRS){\n\t\t\tthis.show();\n\t\t\tthis._reset();\n\t\t}else{\n\t\t\tthis.hide();\n\t\t}\n\t\tthis._setValuesLocked(start,end);\n\t\t\n\t\tthis.bar.activatePlay(start,end);\n\t},\n    loop: function (start, end, show) {\n        var player = this.player;\n\n        if (player) {\n            player.on(\"pause\", videojs.bind(this, function () {\n                this.looping = false;\n            }));\n\n            show = typeof show === 'undefined' ? true : show;\n\n            if (show) {\n                this.show();\n                this._reset();\n            }\n            else {\n                this.hide();\n            }\n            this._setValuesLocked(start, end);\n\n            this.timeStart = start;\n            this.timeEnd = end;\n            this.looping = true;\n\n            this.player.currentTime(start);\n            this.player.play();\n\n            this.player.on(\"timeupdate\", videojs.bind(this, this.bar.process_loop));\n        }\n    },\n\t_getArrowValue: function(index) {\n\t\tvar index = index || 0;\n\t\tvar duration = this.player.duration();\n\t\t\n\t\tduration = typeof duration == 'undefined'? 0 : duration;\n\t\t\n\t\tvar percentage = this[index === 0? \"left\" : \"right\"].el_.style.left.replace(\"%\",\"\");\n\t\tif (percentage == \"\")\n\t\t\tpercentage = index === 0? 0 : 100;\n\t\t\t\n\t\treturn videojs.round(this._seconds(percentage / 100),this.updatePrecision-1);\n\t},\n\t_percent: function(seconds) {\n\t\tvar duration = this.player.duration();\n\t\tif(isNaN(duration)) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn Math.min(1, Math.max(0, seconds / duration));\n\t},\n\t_seconds: function(percent) { \n\t\tvar duration = this.player.duration();\n\t\tif(isNaN(duration)) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn Math.min(duration, Math.max(0, percent * duration));\n\t},\n\t_reset: function() {\n\t\tvar duration = this.player.duration();\n\t\tthis.tpl.el_.style.left = '0%';\n\t\tthis.tpr.el_.style.left = '100%';\n\t\tthis._setValuesLocked(0,duration);\n\t},\n\t_setValuesLocked: function(start,end, writeControlTime){\n\t\tvar triggerSliderChange = typeof writeControlTime!='undefined';\n\t\tvar writeControlTime = typeof writeControlTime!='undefined'?writeControlTime:true;\n\t\tif(this.options.locked) {\n\t\t\tthis.unlock();//It is unlocked to change the bar position. In the end it will return the value.\n\t\t\tthis.setValue(0,start,writeControlTime);\n\t\t\tthis.setValue(1,end,writeControlTime);\n\t\t\tthis.lock();\n\t\t}else{\n\t\t\tthis.setValue(0,start,writeControlTime);\n\t\t\tthis.setValue(1,end,writeControlTime);\n\t\t}\n\t\t\n\t\t// Trigger slider change\n\t\tif (triggerSliderChange) {\n\t\t\tthis._triggerSliderChange();\n\t\t}\n\t},\n\t_checkControlTime: function(index,TextInput,timeOld){\n\t\tvar h = TextInput[0],\n\t\t\tm = TextInput[1],\n\t\t\ts = TextInput[2],\n\t\t\tnewHour = h.value,\n\t\t\tnewMin = m.value,\n\t\t\tnewSec = s.value,\n\t\t\tobj, objNew, objOld;\n\t\tindex = index || 0;\n\t\t\n\t\tif (newHour != timeOld[0]){\n\t\t\tobj = h;\n\t\t\tobjNew = newHour;\n\t\t\tobjOld = timeOld[0];\n\t\t}else if (newMin != timeOld[1]){\n\t\t\tobj = m;\n\t\t\tobjNew = newMin;\n\t\t\tobjOld = timeOld[1];\n\t\t}else if(newSec != timeOld[2]){\n\t\t\tobj = s;\n\t\t\tobjNew = newSec;\n\t\t\tobjOld = timeOld[2];\n\t\t}else{\t\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar duration = this.player.duration() || 0,\n\t\t\tdurationSel;\n\t\t\n\t\tvar intRegex = /^\\d+$/;//check if the objNew is an integer\n\t\tif(!intRegex.test(objNew) || objNew>60){\n\t\t\tobjNew = objNew ==\"\"?\"\":objOld;\n\t\t}\n\t\n\t\tnewHour = newHour == \"\"?0:newHour;\n\t\tnewMin = newMin == \"\"?0:newMin;\n\t\tnewSec = newSec == \"\"?0:newSec;\n\t\n\t\tdurationSel = videojs.TextTrack.prototype.parseCueTime(newHour+\":\"+newMin+\":\"+newSec);\n\t\tif (durationSel > duration){\n\t\t\tobj.value = objOld;\n\t\t\tobj.style.border = \"1px solid red\";\n\t\t}else{\n\t\t\tobj.value = objNew;\n\t\t\th.style.border = m.style.border = s.style.border = \"1px solid transparent\";\n\t\t\tthis.setValue(index,durationSel,false);\n\t\t\t\n\t\t\t// Trigger slider change\n\t\t\tthis._triggerSliderChange();\n\t\t}\n\t\tif (index===1){\n\t\t\tvar oldTimeLeft = this.ctpl.el_.children,\n\t\t\t\tdurationSelLeft = videojs.TextTrack.prototype.parseCueTime(oldTimeLeft[0].value+\":\"+oldTimeLeft[1].value+\":\"+oldTimeLeft[2].value);\n\t\t\tif (durationSel < durationSelLeft){\n\t\t\t\tobj.style.border = \"1px solid red\";\n\t\t\t}\n\t\t}else{\n\t\t\t\n\t\t\tvar oldTimeRight = this.ctpr.el_.children,\n\t\t\t\tdurationSelRight = videojs.TextTrack.prototype.parseCueTime(oldTimeRight[0].value+\":\"+oldTimeRight[1].value+\":\"+oldTimeRight[2].value);\n\t\t\tif (durationSel > durationSelRight){\n\t\t\t\tobj.style.border = \"1px solid red\";\n\t\t\t}\n\t\t}\n\t},\n\t_triggerSliderChange: function(){\n\t\tthis.player.trigger(\"sliderchange\");\n\t}\n};\n\n\n//----------------Public Functions----------------//\n\n//-- Public Functions added to video-js\n\n//Lock the Slider bar and it will not be possible to change the arrow positions\nvideojs.Player.prototype.lockSlider = function(){\n\treturn this.rangeslider.lock();\n};\n\n//Unlock the Slider bar and it will be possible to change the arrow positions\nvideojs.Player.prototype.unlockSlider = function(){\n\treturn this.rangeslider.unlock();\n};\n\n//Show the Slider Bar Component\nvideojs.Player.prototype.showSlider = function(){\n\treturn this.rangeslider.show();\n};\n\n//Hide the Slider Bar Component\nvideojs.Player.prototype.hideSlider = function(){\n\treturn this.rangeslider.hide();\n};\n\n//Show the Panel with the seconds of the selection\nvideojs.Player.prototype.showSliderPanel = function(){\n\treturn this.rangeslider.showPanel();\n};\n\n//Hide the Panel with the seconds of the selection\nvideojs.Player.prototype.hideSliderPanel = function(){\n\treturn this.rangeslider.hidePanel();\n};\n\n\n//Show the control Time to edit the position of the arrows\nvideojs.Player.prototype.showControlTime = function(){\n\treturn this.rangeslider.showcontrolTime();\n};\n\n//Hide the control Time to edit the position of the arrows\nvideojs.Player.prototype.hideControlTime = function(){\n\treturn this.rangeslider.hidecontrolTime();\n};\n\n//Set a Value in second for both arrows\nvideojs.Player.prototype.setValueSlider = function(start, end){\n\treturn this.rangeslider.setValues(start, end);\n};\n\n//The video will be played in a selected section\nvideojs.Player.prototype.playBetween = function(start, end){\n\treturn this.rangeslider.playBetween(start, end);\n};\n\n//The video will loop between to values\nvideojs.Player.prototype.loopBetween = function (start, end) {\n    return this.rangeslider.loop(start, end);\n};\n\n//Set a Value in second for the arrows\nvideojs.Player.prototype.getValueSlider = function(){\n\treturn this.rangeslider.getValues();\n};\n\n\n\n//----------------Create new Components----------------//\n\n//--Charge the new Component into videojs\nvideojs.SeekBar.prototype.options_.children.RSTimeBar={}; //Range Slider Time Bar\nvideojs.ControlBar.prototype.options_.children.ControlTimePanel={}; //Panel with the time of the range slider\n\n\n\n//-- Design the new components\n\n/**\n * Range Slider Time Bar\n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.RSTimeBar = videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t}\n});\n\nvideojs.RSTimeBar.prototype.init_ = function(){\n    \tthis.rs = this.player_.rangeslider;\n};\n\nvideojs.RSTimeBar.prototype.options_ = {\n\tchildren: {\n\t\t'SeekRSBar': {}\n\t}\n};\n\nvideojs.RSTimeBar.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-timebar-RS',\n\t\tinnerHTML: ''\n\t});\n};\n\n\n\n/**\n * Seek Range Slider Bar and holder for the selection bars\n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.SeekRSBar = videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t\tthis.on('mousedown', this.onMouseDown);\n\t}\n});\n\nvideojs.SeekRSBar.prototype.init_ =function(){\n    \tthis.rs = this.player_.rangeslider;\n};\n\nvideojs.SeekRSBar.prototype.options_ = {\n\tchildren: {\n\t\t'SelectionBar': {},\n\t\t'SelectionBarLeft': {},\n\t\t'SelectionBarRight': {},\n\t\t'TimePanel': {},\n\t}\n};\n\nvideojs.SeekRSBar.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-rangeslider-holder'\n\t});\n};\n\n\nvideojs.SeekRSBar.prototype.onMouseDown = function(event) {\n\tevent.preventDefault();\n\tvideojs.blockTextSelection();\n\t\n\tif(!this.rs.options.locked) {\n\t\tvideojs.on(document, \"mousemove\", videojs.bind(this,this.onMouseMove));\n\t\tvideojs.on(document, \"mouseup\", videojs.bind(this,this.onMouseUp));\n\t}\n};\n\nvideojs.SeekRSBar.prototype.onMouseUp = function(event) {\n\tvideojs.off(document, \"mousemove\", this.onMouseMove, false);\n\tvideojs.off(document, \"mouseup\", this.onMouseUp, false);\n};\n\nvideojs.SeekRSBar.prototype.onMouseMove = function(event) {\n\tvar left = this.calculateDistance(event);\n\t\n\tif (this.rs.left.pressed)\n\t\tthis.setPosition(0,left);\n\telse if (this.rs.right.pressed)\n\t\tthis.setPosition(1,left);\n\t\t\n\t//Fix a problem with the presition in the display time\n\tvar currentTimeDisplay = this.player_.controlBar.currentTimeDisplay.content;\n\tcurrentTimeDisplay.innerHTML = '<span class=\"vjs-control-text\">Current Time </span>'+vjs.formatTime(this.rs._seconds(left), this.player_.duration());\n\t\n\t// Trigger slider change\n\tif (this.rs.left.pressed||this.rs.right.pressed) {\n\t\tthis.rs._triggerSliderChange();\n\t}\n};\n\nvideojs.SeekRSBar.prototype.setPosition = function(index,left,writeControlTime) {\n\tvar writeControlTime = typeof writeControlTime!='undefined'?writeControlTime:true;\n\t//index = 0 for left side, index = 1 for right side\n\tvar index = index || 0;\n\t\n\t// Position shouldn't change when handle is locked\n\tif(this.rs.options.locked)\n\t\treturn false;\n\n\t// Check for invalid position\n\tif(isNaN(left)) \n\t\treturn false;\n\t\n\t// Check index between 0 and 1\n\tif(!(index === 0 || index === 1))\n\t\treturn false;\n\t\t\n\t// Alias\n\tvar ObjLeft = this.rs.left.el_,\n\t\tObjRight = this.rs.right.el_,\n\t\tObj = this.rs[index === 0 ? 'left' : 'right'].el_,\n\t\ttpr = this.rs.tpr.el_,\n\t\ttpl = this.rs.tpl.el_,\n\t\tbar = this.rs.bar,\n\t\tctp = this.rs[index === 0 ? 'ctpl' : 'ctpr'].el_;\n\t\n\t//Check if left arrow is passing the right arrow\n\tif ((index === 0 ?bar.updateLeft(left):bar.updateRight(left))){\n\t\tObj.style.left = (left * 100) + '%';\n\t\tindex === 0 ?bar.updateLeft(left):bar.updateRight(left);\n\t\t\n\t\tthis.rs[index === 0 ? 'start' : 'end'] = this.rs._seconds(left);\n\t\n\t\t//Fix the problem  when you press the button and the two arrow are underhand\n\t\t//left.zIndex = 10 and right.zIndex=20. This is always less in this case:\n\t\tif (index === 0){\n\t\t\tif((left) >= 0.9)\n\t\t\t\tObjLeft.style.zIndex = 25;\n\t\t\telse\n\t\t\t\tObjLeft.style.zIndex = 10;\n\t\t}\n\t\t\n\t\t//-- Panel\n\t\tvar TimeText = videojs.formatTime(this.rs._seconds(left)),\n\t\t\ttplTextLegth = tpl.children[0].innerHTML.length;\n\t\tvar MaxP,MinP,MaxDisP;\n\t\tif (tplTextLegth<=4) //0:00\n\t\t\tMaxDisP = this.player_.isFullScreen?3.25:6.5;\n\t\telse if(tplTextLegth<=5)//00:00\n\t\t\tMaxDisP = this.player_.isFullScreen?4:8;\n\t\telse//0:00:00\n\t\t\tMaxDisP = this.player_.isFullScreen?5:10;\n\t\tif(TimeText.length<=4){ //0:00\n\t\t\tMaxP = this.player_.isFullScreen?97:93;\n\t\t\tMinP = this.player_.isFullScreen?0.1:0.5;\n\t\t}else if(TimeText.length<=5){//00:00\n\t\t\tMaxP = this.player_.isFullScreen?96:92;\n\t\t\tMinP = this.player_.isFullScreen?0.1:0.5;\n\t\t}else{//0:00:00\n\t\t\tMaxP = this.player_.isFullScreen?95:91;\n\t\t\tMinP = this.player_.isFullScreen?0.1:0.5;\n\t\t}\n\t\t\n\t\tif (index===0){\n\t\t\ttpl.style.left = Math.max(MinP,Math.min(MaxP,(left * 100 - MaxDisP/2))) + '%';\n\t\t\t\n\t\t\tif ((tpr.style.left.replace(\"%\",\"\") - tpl.style.left.replace(\"%\",\"\"))<=MaxDisP)\n\t\t\t\ttpl.style.left = Math.max(MinP,Math.min(MaxP,tpr.style.left.replace(\"%\",\"\")-MaxDisP)) + '%';\n\t\t\ttpl.children[0].innerHTML = TimeText;\n\t\t}else{\n\t\t\ttpr.style.left = Math.max(MinP,Math.min(MaxP,(left * 100 - MaxDisP/2))) + '%';\n\t\t\t\n\t\t\tif (((tpr.style.left.replace(\"%\",\"\")||100) - tpl.style.left.replace(\"%\",\"\"))<=MaxDisP)\n\t\t\t\ttpr.style.left = Math.max(MinP,Math.min(MaxP,tpl.style.left.replace(\"%\",\"\")-0+MaxDisP)) + '%';\n\t\t\ttpr.children[0].innerHTML = TimeText;\n\t\t}\n\t\t//-- Control Time\n\t\tif(writeControlTime){\n\t\t\tvar time = TimeText.split(\":\"),\n\t\t\t\th,m,s;\n\t\t\tif(time.length == 2){\n\t\t\t\th = 00;\n\t\t\t\tm = time[0];\n\t\t\t\ts = time[1];\n\t\t\t}else{\n\t\t\t\th = time[0];\n\t\t\t\tm = time[1];\n\t\t\t\ts = time[2];\n\t\t\t}\n\t\t\tctp.children[0].value = h;\n\t\t\tctp.children[1].value = m;\n\t\t\tctp.children[2].value = s;\n\t\t}\n\t}\n\treturn true;\n};\n\nvideojs.SeekRSBar.prototype.calculateDistance = function(event){\n\tvar rstbX = this.getRSTBX();\n\tvar rstbW = this.getRSTBWidth();\n\tvar handleW = this.getWidth();\n\n\t// Adjusted X and Width, so handle doesn't go outside the bar\n\trstbX = rstbX + (handleW / 2);\n\trstbW = rstbW - handleW;\n\n\t// Percent that the click is through the adjusted area\n\treturn Math.max(0, Math.min(1, (event.pageX - rstbX) / rstbW));\n};\n\nvideojs.SeekRSBar.prototype.getRSTBWidth = function() {\n\treturn this.el_.offsetWidth;\n};\nvideojs.SeekRSBar.prototype.getRSTBX = function() {\n\treturn videojs.findPosition(this.el_).left;\n};\nvideojs.SeekRSBar.prototype.getWidth = function() {\n\treturn this.rs.left.el_.offsetWidth;//does not matter left or right\n};\n\n\n\n/**\n * This is the bar with the selection of the RangeSlider\n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.SelectionBar = videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t\tthis.on('mouseup', this.onMouseUp);\n\t\tthis.fired = false;\n\t}\n});\n\nvideojs.SelectionBar.prototype.init_ = function(){\n    \tthis.rs = this.player_.rangeslider;\n};\n\nvideojs.SelectionBar.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-selectionbar-RS'\n\t});\n};\n\nvideojs.SelectionBar.prototype.onMouseUp = function(){\n\tvar start = this.rs.left.el_.style.left.replace(\"%\",\"\"),\n\t\tend = this.rs.right.el_.style.left.replace(\"%\",\"\"),\n\t\tduration = this.player_.duration(),\n\t\tprecision = this.rs.updatePrecision,\n\t\tsegStart = videojs.round(start * duration/100, precision),\n\t\tsegEnd = videojs.round(end * duration/100, precision);\n\tthis.player_.currentTime(segStart);\n\tthis.player_.play();\n\tthis.rs.bar.activatePlay(segStart,segEnd);\n};\n\nvideojs.SelectionBar.prototype.updateLeft = function(left) {\n\tvar rightVal = this.rs.right.el_.style.left!=''?this.rs.right.el_.style.left:100;\n\tvar right = parseFloat(rightVal) / 100;\n\t\n\tvar width = videojs.round((right - left),this.rs.updatePrecision); //round necessary for not get 0.6e-7 for example that it's not able for the html css width\n\t\n\t//(right+0.00001) is to fix the precision of the css in html\n\tif(left <= (right+0.00001)) {\n\t\t\tthis.rs.bar.el_.style.left = (left * 100) + '%';\n\t\t\tthis.rs.bar.el_.style.width = (width * 100) + '%';\n\t\t\treturn true;\n\t}\n\treturn false;\n};\n\t\t\nvideojs.SelectionBar.prototype.updateRight = function(right) {\n\tvar leftVal = this.rs.left.el_.style.left!=''?this.rs.left.el_.style.left:0;\n\tvar left = parseFloat(leftVal) / 100;\n\t\n\tvar width = videojs.round((right - left),this.rs.updatePrecision);//round necessary for not get 0.6e-7 for example that it's not able for the html css width\n\t\n\t//(right+0.00001) is to fix the precision of the css in html\n\tif((right+0.00001) >= left) {\n\t\tthis.rs.bar.el_.style.width = (width * 100) + '%';\n\t\tthis.rs.bar.el_.style.left = ((right  - width) * 100) + '%';\n\t\treturn true;\n\t}\n\treturn false;\n};\n\nvideojs.SelectionBar.prototype.activatePlay = function(start,end){\n\tthis.timeStart = start;\n\tthis.timeEnd = end;\n\t\n\tthis.suspendPlay();\n\t\n\tthis.player_.on(\"timeupdate\", videojs.bind(this,this._processPlay));\n};\n\nvideojs.SelectionBar.prototype.suspendPlay = function(){\n\tthis.fired = false;\n\tthis.player_.off(\"timeupdate\", videojs.bind(this,this._processPlay));\n};\n\nvideojs.SelectionBar.prototype._processPlay = function (){\n\t//Check if current time is between start and end\n    if(this.player_.currentTime() >= this.timeStart && (this.timeEnd < 0 || this.player_.currentTime() < this.timeEnd)){\n        if(this.fired){ //Do nothing if start has already been called\n            return;\n        }\n        this.fired = true; //Set fired flag to true\n    }else{\n        if(!this.fired){ //Do nothing if end has already been called\n            return;\n        }\n        this.fired = false; //Set fired flat to false\n        this.player_.pause(); //Call end function\n        this.player_.currentTime(this.timeEnd);\n        this.suspendPlay();\n    }\n};\n\nvideojs.SelectionBar.prototype.process_loop = function () {\n    var player = this.player;\n\n    if (player && this.looping) {\n        var current_time = player.currentTime();\n\n        if (current_time < this.timeStart || this.timeEnd > 0 &&  this.timeEnd < current_time) {\n            player.currentTime(this.timeStart);\n        }\n    }\n};\n\n/**\n * This is the left arrow to select the RangeSlider\n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.SelectionBarLeft = videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t\tthis.on('mousedown', this.onMouseDown);\n\t\tthis.pressed = false;\n\t}\n});\n\nvideojs.SelectionBarLeft.prototype.init_ = function(){\n    \tthis.rs = this.player_.rangeslider;\n};\n\nvideojs.SelectionBarLeft.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-rangeslider-handle vjs-selectionbar-left-RS',\n\t\tinnerHTML: '<div class=\"vjs-selectionbar-arrow-RS\"></div><div class=\"vjs-selectionbar-line-RS\"></div>'\n\t});\n};\n\nvideojs.SelectionBarLeft.prototype.onMouseDown = function(event) {\n\tevent.preventDefault();\n\tvideojs.blockTextSelection();\n\tif(!this.rs.options.locked) {\n\t\tthis.pressed = true;\n\t\tvideojs.on(document, \"mouseup\", videojs.bind(this,this.onMouseUp));\n\t\tvideojs.addClass(this.el_, 'active');\n\t}\n};\n\nvideojs.SelectionBarLeft.prototype.onMouseUp = function(event) {\n\tvideojs.off(document, \"mouseup\", this.onMouseUp, false);\n\tvideojs.removeClass(this.el_, 'active');\n\tif(!this.rs.options.locked) {\n\t\tthis.pressed = false;\n\t}\n};\n\n\n\n/**\n * This is the right arrow to select the RangeSlider\n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.SelectionBarRight = videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t\tthis.on('mousedown', this.onMouseDown);\n\t\tthis.pressed = false;\n\t}\n});\n\nvideojs.SelectionBarRight.prototype.init_ = function(){\n    \tthis.rs = this.player_.rangeslider;\n};\n\nvideojs.SelectionBarRight.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-rangeslider-handle vjs-selectionbar-right-RS',\n\t\tinnerHTML: '<div class=\"vjs-selectionbar-arrow-RS\"></div><div class=\"vjs-selectionbar-line-RS\"></div>'\n\t});\n};\n\n\nvideojs.SelectionBarRight.prototype.onMouseDown = function(event) {\n\tevent.preventDefault();\n\tvideojs.blockTextSelection();\n\tif(!this.rs.options.locked) {\n\t\tthis.pressed = true;\n\t\tvideojs.on(document, \"mouseup\", videojs.bind(this,this.onMouseUp));\n\t\tvideojs.addClass(this.el_, 'active');\n\t}\n};\n\nvideojs.SelectionBarRight.prototype.onMouseUp = function(event) {\n\tvideojs.off(document, \"mouseup\", this.onMouseUp, false);\n\tvideojs.removeClass(this.el_, 'active');\n\tif(!this.rs.options.locked) {\n\t\tthis.pressed = false;\n\t}\n};\n\n\n/**\n * This is the time panel\n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.TimePanel = videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t}\n});\n\nvideojs.TimePanel.prototype.init_ = function(){\n    \tthis.rs = this.player_.rangeslider;\n};\n\nvideojs.TimePanel.prototype.options_ = {\n\tchildren: {\n\t\t'TimePanelLeft': {},\n\t\t'TimePanelRight': {},\n\t}\n};\n\nvideojs.TimePanel.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-timepanel-RS'\n\t});\n};\n\n\n/**\n * This is the left time panel \n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.TimePanelLeft = videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t}\n});\n\nvideojs.TimePanelLeft.prototype.init_ = function(){\n    \tthis.rs = this.player_.rangeslider;\n};\n\nvideojs.TimePanelLeft.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-timepanel-left-RS',\n\t\tinnerHTML: '<span class=\"vjs-time-text\">00:00</span>'\n\t});\n};\n\n\n/**\n * This is the right time panel \n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.TimePanelRight = videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t}\n});\n\nvideojs.TimePanelRight.prototype.init_ = function(){\n    \tthis.rs = this.player_.rangeslider;\n};\n\nvideojs.TimePanelRight.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-timepanel-right-RS',\n\t\tinnerHTML: '<span class=\"vjs-time-text\">00:00</span>'\n\t});\n};\n\n\n/**\n * This is the control time panel\n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.ControlTimePanel= videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t}\n});\n\nvideojs.ControlTimePanel.prototype.init_ = function(){\n    \tthis.rs = this.player_.rangeslider;\n};\n\n\nvideojs.ControlTimePanel.prototype.options_ = {\n\tchildren: {\n\t\t'ControlTimePanelLeft': {},\n\t\t'ControlTimePanelRight': {},\n\t}\n};\n\nvideojs.ControlTimePanel.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-controltimepanel-RS vjs-control',\n\t});\n};\n\nvideojs.ControlTimePanel.prototype.enable = function(enable){\n\tvar enable = typeof enable != 'undefined'? enable:true;\n\tthis.rs.ctpl.el_.children[0].disabled = enable?\"\":\"disabled\";\n\tthis.rs.ctpl.el_.children[1].disabled = enable?\"\":\"disabled\";\n\tthis.rs.ctpl.el_.children[2].disabled = enable?\"\":\"disabled\";\n\tthis.rs.ctpr.el_.children[0].disabled = enable?\"\":\"disabled\";\n\tthis.rs.ctpr.el_.children[1].disabled = enable?\"\":\"disabled\";\n\tthis.rs.ctpr.el_.children[2].disabled = enable?\"\":\"disabled\";\n};\n\n\n/**\n * This is the control left time panel \n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.ControlTimePanelLeft = videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t\tthis.on('keyup', this.onKeyUp);\n\t\tthis.on('keydown', this.onKeyDown);\n\t}\n});\n\nvideojs.ControlTimePanelLeft.prototype.init_ = function(){\n    this.rs = this.player_.rangeslider;\n\tthis.timeOld = {};\n};\n\nvideojs.ControlTimePanelLeft.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-controltimepanel-left-RS',\n\t\tinnerHTML: 'Start: <input type=\"text\" id=\"controltimepanel\" maxlength=\"2\" value=\"00\"/>:<input type=\"text\" id=\"controltimepanel\" maxlength=\"2\" value=\"00\"/>:<input type=\"text\" id=\"controltimepanel\" maxlength=\"2\" value=\"00\"/>'\n\t});\n};\n\nvideojs.ControlTimePanelLeft.prototype.onKeyDown = function(event) {\n\tthis.timeOld[0] = this.el_.children[0].value;\n\tthis.timeOld[1] = this.el_.children[1].value;\n\tthis.timeOld[2] = this.el_.children[2].value;\n};\n\nvideojs.ControlTimePanelLeft.prototype.onKeyUp = function(event) {\n\tthis.rs._checkControlTime(0,this.el_.children,this.timeOld);\n};\n\n\n\n/**\n * This is the control right time panel \n * @param {videojs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvideojs.ControlTimePanelRight = videojs.Component.extend({\n  /** @constructor */\n\tinit: function(player, options){\n\t\tvideojs.Component.call(this, player, options);\n\t\tthis.on('keyup', this.onKeyUp);\n\t\tthis.on('keydown', this.onKeyDown);\n\t}\n});\n\nvideojs.ControlTimePanelRight.prototype.init_ = function(){\n    \tthis.rs = this.player_.rangeslider;\n    \tthis.timeOld = {};\n};\n\nvideojs.ControlTimePanelRight.prototype.createEl = function(){\n\treturn videojs.Component.prototype.createEl.call(this, 'div', {\n\t\tclassName: 'vjs-controltimepanel-right-RS',\n\t\tinnerHTML: 'End: <input type=\"text\" id=\"controltimepanel\" maxlength=\"2\" value=\"00\"/>:<input type=\"text\" id=\"controltimepanel\" maxlength=\"2\" value=\"00\"/>:<input type=\"text\" id=\"controltimepanel\" maxlength=\"2\" value=\"00\"/>'\n\t});\n};\n\nvideojs.ControlTimePanelRight.prototype.onKeyDown = function(event) {\n\tthis.timeOld[0] = this.el_.children[0].value;\n\tthis.timeOld[1] = this.el_.children[1].value;\n\tthis.timeOld[2] = this.el_.children[2].value;\n};\n\nvideojs.ControlTimePanelRight.prototype.onKeyUp = function(event) {\n\tthis.rs._checkControlTime(1,this.el_.children,this.timeOld);\n};\n})();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/static/vendors/development/video.dev.js */ \"./src/static/vendors/development/video.dev.js\")))\n\n//# sourceURL=webpack:///./src/static/vendors/development/rangeslider.js?");

/***/ }),

/***/ "./src/static/vendors/development/video-speed.js":
/*!*******************************************************!*\
  !*** ./src/static/vendors/development/video-speed.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(videojs) {// videojs-speed-plugin\n\nvideojs.plugin('speed', function(options) {\n    var player = this,\n        items = [],\n        selectedItem;\n\n    function changeSpeed(item) {\n        var opt = item.options();\n        item.selected(true);\n        player.playbackRate(opt.rate);\n\n        var nodes = player.controlBar.speedButton.el().firstChild.children;\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            if (nodes[i].className == 'vjs-current-speed') {\n                nodes[i].innerHTML = opt.label;\n            }\n        }\n    }\n\n    videojs.SpeedMenuItem = videojs.MenuItem.extend({\n        init: function(player, options) {\n            videojs.MenuItem.call(this, player, options);\n            this.on('click', this.onClick);\n        }\n    });\n    videojs.SpeedMenuItem.prototype.onClick = function(e) {\n        for (var i = 0, l = items.length; i < l; i++) {\n            items[i].selected(false);\n        }\n        changeSpeed(this);\n    }\n\n    videojs.SpeedButton = videojs.MenuButton.extend({\n        init: function(player, options){\n            videojs.MenuButton.call(this, player, options);\n        }\n    });\n    videojs.SpeedButton.prototype.createItems = function() {\n        var item;\n        options.forEach(function(opt) {\n            item = new videojs.SpeedMenuItem(player, { label: opt.text, rate: opt.rate });\n            if (opt.selected) {\n                selectedItem = item;\n            }\n            items.push(item);\n        });\n        return items;\n    }\n\n    player.ready(function() {\n        var button = new videojs.SpeedButton(player, {\n            el: videojs.Component.prototype.createEl(null, {\n                className: 'vjs-res-button vjs-menu-button vjs-control',\n                innerHTML: '<div class=\"vjs-control-content\" style=\"font-size: 11px; line-height: 28px;\"><span class=\"vjs-current-speed\"></span></div>',\n                role: 'button'\n            })\n        });\n        player.controlBar.speedButton = player.controlBar.addChild(button);\n        changeSpeed(selectedItem);\n        \n        try {\n            if (player.c.P.id.indexOf('html5') == -1) { // FIXME player.c.P\n                button.hide();\n            }\n        } catch (err) {\n            console.log(\"can't detect tech.\");\n        }\n    });\n});\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/static/vendors/development/video.dev.js */ \"./src/static/vendors/development/video.dev.js\")))\n\n//# sourceURL=webpack:///./src/static/vendors/development/video-speed.js?");

/***/ }),

/***/ "./src/static/vendors/development/video.dev.js":
/*!*****************************************************!*\
  !*** ./src/static/vendors/development/video.dev.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_videojs) {/*** IMPORTS FROM imports-loader ***/\nvar define = false;\nvar require = false;\n\n/**\n * @fileoverview Main function src.\n */\n\n// HTML5 Shiv. Must be in <head> to support older browsers.\ndocument.createElement('video');\ndocument.createElement('audio');\ndocument.createElement('track');\n\n/**\n * Doubles as the main function for users to create a player instance and also\n * the main library object.\n *\n * @param  {String|Element} id      Video element or video element ID\n * @param  {Object=} options        Optional options object for config/settings\n * @param  {Function=} ready        Optional ready callback\n * @return {vjs.Player}             A player instance\n */\nvar vjs = function(id, options, ready){\n  var tag; // Element of ID\n\n  // Allow for element or ID to be passed in\n  // String ID\n  if (typeof id === 'string') {\n\n    // Adjust for jQuery ID syntax\n    if (id.indexOf('#') === 0) {\n      id = id.slice(1);\n    }\n\n    // If a player instance has already been created for this ID return it.\n    if (vjs.players[id]) {\n      return vjs.players[id];\n\n    // Otherwise get element for ID\n    } else {\n      tag = vjs.el(id);\n    }\n\n  // ID is a media element\n  } else {\n    tag = id;\n  }\n\n  // Check for a useable element\n  if (!tag || !tag.nodeName) { // re: nodeName, could be a box div also\n    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns\n  }\n\n  // Element may have a player attr referring to an already created player instance.\n  // If not, set up a new player and return the instance.\n  return tag['player'] || new vjs.Player(tag, options, ready);\n};\n\n// Extended name, also available externally, window.videojs\nvar videojs = vjs;\n__webpack_provided_window_dot_videojs = window.vjs = vjs;\n\n// CDN Version. Used to target right flash swf.\nvjs.CDN_VERSION = '4.2';\nvjs.ACCESS_PROTOCOL = ('https:' == document.location.protocol ? 'https://' : 'http://');\n\n/**\n * Global Player instance options, surfaced from vjs.Player.prototype.options_\n * vjs.options = vjs.Player.prototype.options_\n * All options should use string keys so they avoid\n * renaming by closure compiler\n * @type {Object}\n */\nvjs.options = {\n  // Default order of fallback technology\n  'techOrder': ['html5','flash','youtube'],\n  // techOrder: ['flash','html5'],\n\n  'html5': {},\n  'flash': {},\n\n  // Default of web browser is 300x150. Should rely on source width/height.\n  'width': 300,\n  'height': 150,\n  // defaultVolume: 0.85,\n  'defaultVolume': 0.00, // The freakin seaguls are driving me crazy!\n\n  // default playback rates\n  'playbackRates': [],\n  // Add playback rate selection by adding rates\n  // 'playbackRates': [0.5, 1, 1.5, 2],\n\n  // Included control sets\n  'children': {\n    'mediaLoader': {},\n    'posterImage': {},\n    'textTrackDisplay': {},\n    'loadingSpinner': {},\n    'bigPlayButton': {},\n    'controlBar': {}\n  },\n\n  // Default message to show when a video cannot be played.\n  'notSupportedMessage': 'Sorry, no compatible source and playback ' +\n      'technology were found for this video. Try using another browser ' +\n      'like <a href=\"http://bit.ly/ccMUEC\">Chrome</a> or download the ' +\n      'latest <a href=\"http://adobe.ly/mwfN1\">Adobe Flash Player</a>.'\n};\n\n// Set CDN Version of swf\n// The added (+) blocks the replace from changing this 4.2 string\nif (vjs.CDN_VERSION !== 'GENERATED'+'_CDN_VSN') {\n  videojs.options['flash']['swf'] = vjs.ACCESS_PROTOCOL + 'vjs.zencdn.net/'+vjs.CDN_VERSION+'/video-js.swf';\n}\n\n/**\n * Global player list\n * @type {Object}\n */\nvjs.players = {};\n/**\n * Core Object/Class for objects that use inheritance + contstructors\n * @constructor\n */\nvjs.CoreObject = vjs['CoreObject'] = function(){};\n// Manually exporting vjs['CoreObject'] here for Closure Compiler\n// because of the use of the extend/create class methods\n// If we didn't do this, those functions would get flattend to something like\n// `a = ...` and `this.prototype` would refer to the global object instead of\n// CoreObject\n\n/**\n * Create a new object that inherits from this Object\n * @param {Object} props Functions and properties to be applied to the\n *                       new object's prototype\n * @return {vjs.CoreObject} Returns an object that inherits from CoreObject\n * @this {*}\n */\nvjs.CoreObject.extend = function(props){\n  var init, subObj;\n\n  props = props || {};\n  // Set up the constructor using the supplied init method\n  // or using the init of the parent object\n  // Make sure to check the unobfuscated version for external libs\n  init = props['init'] || props.init || this.prototype['init'] || this.prototype.init || function(){};\n  // In Resig's simple class inheritance (previously used) the constructor\n  //  is a function that calls `this.init.apply(arguments)`\n  // However that would prevent us from using `ParentObject.call(this);`\n  //  in a Child constuctor because the `this` in `this.init`\n  //  would still refer to the Child and cause an inifinite loop.\n  // We would instead have to do\n  //    `ParentObject.prototype.init.apply(this, argumnents);`\n  //  Bleh. We're not creating a _super() function, so it's good to keep\n  //  the parent constructor reference simple.\n  subObj = function(){\n    init.apply(this, arguments);\n  };\n\n  // Inherit from this object's prototype\n  subObj.prototype = vjs.obj.create(this.prototype);\n  // Reset the constructor property for subObj otherwise\n  // instances of subObj would have the constructor of the parent Object\n  subObj.prototype.constructor = subObj;\n\n  // Make the class extendable\n  subObj.extend = vjs.CoreObject.extend;\n  // Make a function for creating instances\n  subObj.create = vjs.CoreObject.create;\n\n  // Extend subObj's prototype with functions and other properties from props\n  for (var name in props) {\n    if (props.hasOwnProperty(name)) {\n      subObj.prototype[name] = props[name];\n    }\n  }\n\n  return subObj;\n};\n\n/**\n * Create a new instace of this Object class\n * @return {vjs.CoreObject} Returns an instance of a CoreObject subclass\n * @this {*}\n */\nvjs.CoreObject.create = function(){\n  // Create a new object that inherits from this object's prototype\n  var inst = vjs.obj.create(this.prototype);\n\n  // Apply this constructor function to the new object\n  this.apply(inst, arguments);\n\n  // Return the new object\n  return inst;\n};\n/**\n * @fileoverview Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n */\n\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n * @param  {Element|Object}   elem Element or object to bind listeners to\n * @param  {String}   type Type of event to bind to.\n * @param  {Function} fn   Event listener.\n */\nvjs.on = function(elem, type, fn){\n  var data = vjs.getData(elem);\n\n  // We need a place to store all our handler data\n  if (!data.handlers) data.handlers = {};\n\n  if (!data.handlers[type]) data.handlers[type] = [];\n\n  if (!fn.guid) fn.guid = vjs.guid++;\n\n  data.handlers[type].push(fn);\n\n  if (!data.dispatcher) {\n    data.disabled = false;\n\n    data.dispatcher = function (event){\n\n      if (data.disabled) return;\n      event = vjs.fixEvent(event);\n\n      var handlers = data.handlers[event.type];\n\n      if (handlers) {\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n        var handlersCopy = handlers.slice(0);\n\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\n          if (event.isImmediatePropagationStopped()) {\n            break;\n          } else {\n            handlersCopy[m].call(elem, event);\n          }\n        }\n      }\n    };\n  }\n\n  if (data.handlers[type].length == 1) {\n    if (document.addEventListener) {\n      elem.addEventListener(type, data.dispatcher, false);\n    } else if (document.attachEvent) {\n      elem.attachEvent('on' + type, data.dispatcher);\n    }\n  }\n};\n\n/**\n * Removes event listeners from an element\n * @param  {Element|Object}   elem Object to remove listeners from\n * @param  {String=}   type Type of listener to remove. Don't include to remove all events from element.\n * @param  {Function} fn   Specific listener to remove. Don't incldue to remove listeners for an event type.\n */\nvjs.off = function(elem, type, fn) {\n  // Don't want to add a cache object through getData if not needed\n  if (!vjs.hasData(elem)) return;\n\n  var data = vjs.getData(elem);\n\n  // If no events exist, nothing to unbind\n  if (!data.handlers) { return; }\n\n  // Utility function\n  var removeType = function(t){\n     data.handlers[t] = [];\n     vjs.cleanUpEvents(elem,t);\n  };\n\n  // Are we removing all bound events?\n  if (!type) {\n    for (var t in data.handlers) removeType(t);\n    return;\n  }\n\n  var handlers = data.handlers[type];\n\n  // If no handlers exist, nothing to unbind\n  if (!handlers) return;\n\n  // If no listener was provided, remove all listeners for type\n  if (!fn) {\n    removeType(type);\n    return;\n  }\n\n  // We're only removing a single handler\n  if (fn.guid) {\n    for (var n = 0; n < handlers.length; n++) {\n      if (handlers[n].guid === fn.guid) {\n        handlers.splice(n--, 1);\n      }\n    }\n  }\n\n  vjs.cleanUpEvents(elem, type);\n};\n\n/**\n * Clean up the listener cache and dispatchers\n * @param  {Element|Object} elem Element to clean up\n * @param  {String} type Type of event to clean up\n */\nvjs.cleanUpEvents = function(elem, type) {\n  var data = vjs.getData(elem);\n\n  // Remove the events of a particular type if there are none left\n  if (data.handlers[type].length === 0) {\n    delete data.handlers[type];\n    // data.handlers[type] = null;\n    // Setting to null was causing an error with data.handlers\n\n    // Remove the meta-handler from the element\n    if (document.removeEventListener) {\n      elem.removeEventListener(type, data.dispatcher, false);\n    } else if (document.detachEvent) {\n      elem.detachEvent('on' + type, data.dispatcher);\n    }\n  }\n\n  // Remove the events object if there are no types left\n  if (vjs.isEmpty(data.handlers)) {\n    delete data.handlers;\n    delete data.dispatcher;\n    delete data.disabled;\n\n    // data.handlers = null;\n    // data.dispatcher = null;\n    // data.disabled = null;\n  }\n\n  // Finally remove the expando if there is no data left\n  if (vjs.isEmpty(data)) {\n    vjs.removeData(elem);\n  }\n};\n\n/**\n * Fix a native event to have standard property values\n * @param  {Object} event Event object to fix\n * @return {Object}\n */\nvjs.fixEvent = function(event) {\n\n  function returnTrue() { return true; }\n  function returnFalse() { return false; }\n\n  // Test if fixing up is needed\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\n  // But native events return true for stopPropagation, but don't have\n  // other expected methods like isPropagationStopped. Seems to be a problem\n  // with the Javascript Ninja code. So we're just overriding all events now.\n  if (!event || !event.isPropagationStopped) {\n    var old = event || window.event;\n\n    event = {};\n    // Clone the old object so that we can modify the values event = {};\n    // IE8 Doesn't like when you mess with native event properties\n    // Firefox returns false for event.hasOwnProperty('type') and other props\n    //  which makes copying more difficult.\n    // TODO: Probably best to create a whitelist of event props\n    for (var key in old) {\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n      if (key !== 'layerX' && key !== 'layerY') {\n        event[key] = old[key];\n      }\n    }\n\n    // The event occurred on this element\n    if (!event.target) {\n      event.target = event.srcElement || document;\n    }\n\n    // Handle which other element the event is related to\n    event.relatedTarget = event.fromElement === event.target ?\n      event.toElement :\n      event.fromElement;\n\n    // Stop the default browser action\n    event.preventDefault = function () {\n      if (old.preventDefault) {\n        old.preventDefault();\n      }\n      event.returnValue = false;\n      event.isDefaultPrevented = returnTrue;\n    };\n\n    event.isDefaultPrevented = returnFalse;\n\n    // Stop the event from bubbling\n    event.stopPropagation = function () {\n      if (old.stopPropagation) {\n        old.stopPropagation();\n      }\n      event.cancelBubble = true;\n      event.isPropagationStopped = returnTrue;\n    };\n\n    event.isPropagationStopped = returnFalse;\n\n    // Stop the event from bubbling and executing other handlers\n    event.stopImmediatePropagation = function () {\n      if (old.stopImmediatePropagation) {\n        old.stopImmediatePropagation();\n      }\n      event.isImmediatePropagationStopped = returnTrue;\n      event.stopPropagation();\n    };\n\n    event.isImmediatePropagationStopped = returnFalse;\n\n    // Handle mouse position\n    if (event.clientX != null) {\n      var doc = document.documentElement, body = document.body;\n\n      event.pageX = event.clientX +\n        (doc && doc.scrollLeft || body && body.scrollLeft || 0) -\n        (doc && doc.clientLeft || body && body.clientLeft || 0);\n      event.pageY = event.clientY +\n        (doc && doc.scrollTop || body && body.scrollTop || 0) -\n        (doc && doc.clientTop || body && body.clientTop || 0);\n    }\n\n    // Handle key presses\n    event.which = event.charCode || event.keyCode;\n\n    // Fix button for mouse clicks:\n    // 0 == left; 1 == middle; 2 == right\n    if (event.button != null) {\n      event.button = (event.button & 1 ? 0 :\n        (event.button & 4 ? 1 :\n          (event.button & 2 ? 2 : 0)));\n    }\n  }\n\n  // Returns fixed-up instance\n  return event;\n};\n\n/**\n * Trigger an event for an element\n * @param  {Element|Object} elem  Element to trigger an event on\n * @param  {String} event Type of event to trigger\n */\nvjs.trigger = function(elem, event) {\n  // Fetches element data and a reference to the parent (for bubbling).\n  // Don't want to add a data object to cache for every parent,\n  // so checking hasData first.\n  var elemData = (vjs.hasData(elem)) ? vjs.getData(elem) : {};\n  var parent = elem.parentNode || elem.ownerDocument;\n      // type = event.type || event,\n      // handler;\n\n  // If an event name was passed as a string, creates an event out of it\n  if (typeof event === 'string') {\n    event = { type:event, target:elem };\n  }\n  // Normalizes the event properties.\n  event = vjs.fixEvent(event);\n\n  // If the passed element has a dispatcher, executes the established handlers.\n  if (elemData.dispatcher) {\n    elemData.dispatcher.call(elem, event);\n  }\n\n  // Unless explicitly stopped or the event does not bubble (e.g. media events)\n    // recursively calls this function to bubble the event up the DOM.\n    if (parent && !event.isPropagationStopped() && event.bubbles !== false) {\n    vjs.trigger(parent, event);\n\n  // If at the top of the DOM, triggers the default action unless disabled.\n  } else if (!parent && !event.isDefaultPrevented()) {\n    var targetData = vjs.getData(event.target);\n\n    // Checks if the target has a default action for this event.\n    if (event.target[event.type]) {\n      // Temporarily disables event dispatching on the target as we have already executed the handler.\n      targetData.disabled = true;\n      // Executes the default action.\n      if (typeof event.target[event.type] === 'function') {\n        event.target[event.type]();\n      }\n      // Re-enables event dispatching.\n      targetData.disabled = false;\n    }\n  }\n\n  // Inform the triggerer if the default was prevented by returning false\n  return !event.isDefaultPrevented();\n  /* Original version of js ninja events wasn't complete.\n   * We've since updated to the latest version, but keeping this around\n   * for now just in case.\n   */\n  // // Added in attion to book. Book code was broke.\n  // event = typeof event === 'object' ?\n  //   event[vjs.expando] ?\n  //     event :\n  //     new vjs.Event(type, event) :\n  //   new vjs.Event(type);\n\n  // event.type = type;\n  // if (handler) {\n  //   handler.call(elem, event);\n  // }\n\n  // // Clean up the event in case it is being reused\n  // event.result = undefined;\n  // event.target = elem;\n};\n\n/**\n * Trigger a listener only once for an event\n * @param  {Element|Object}   elem Element or object to\n * @param  {[type]}   type [description]\n * @param  {Function} fn   [description]\n * @return {[type]}\n */\nvjs.one = function(elem, type, fn) {\n  var func = function(){\n    vjs.off(elem, type, func);\n    fn.apply(this, arguments);\n  };\n  func.guid = fn.guid = fn.guid || vjs.guid++;\n  vjs.on(elem, type, func);\n};\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\n/**\n * Creates an element and applies properties.\n * @param  {String=} tagName    Name of tag to be created.\n * @param  {Object=} properties Element properties to be applied.\n * @return {Element}\n */\nvjs.createEl = function(tagName, properties){\n  var el, propName;\n\n  el = document.createElement(tagName || 'div');\n\n  for (propName in properties){\n    if (hasOwnProp.call(properties, propName)) {\n      //el[propName] = properties[propName];\n      // Not remembering why we were checking for dash\n      // but using setAttribute means you have to use getAttribute\n\n      // The check for dash checks for the aria-* attributes, like aria-label, aria-valuemin.\n      // The additional check for \"role\" is because the default method for adding attributes does not\n      // add the attribute \"role\". My guess is because it's not a valid attribute in some namespaces, although\n      // browsers handle the attribute just fine. The W3C allows for aria-* attributes to be used in pre-HTML5 docs.\n      // http://www.w3.org/TR/wai-aria-primer/#ariahtml. Using setAttribute gets around this problem.\n\n       if (propName.indexOf('aria-') !== -1 || propName=='role') {\n         el.setAttribute(propName, properties[propName]);\n       } else {\n         el[propName] = properties[propName];\n       }\n    }\n  }\n  return el;\n};\n\n/**\n * Uppercase the first letter of a string\n * @param  {String} string String to be uppercased\n * @return {String}\n */\nvjs.capitalize = function(string){\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n/**\n * Object functions container\n * @type {Object}\n */\nvjs.obj = {};\n\n/**\n * Object.create shim for prototypal inheritance.\n * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\n * @param  {Object}   obj Object to use as prototype\n */\n vjs.obj.create = Object.create || function(obj){\n  //Create a new function called 'F' which is just an empty object.\n  function F() {}\n\n  //the prototype of the 'F' function should point to the\n  //parameter of the anonymous function.\n  F.prototype = obj;\n\n  //create a new constructor function based off of the 'F' function.\n  return new F();\n};\n\n/**\n * Loop through each property in an object and call a function\n * whose arguments are (key,value)\n * @param  {Object}   obj Object of properties\n * @param  {Function} fn  Function to be called on each property.\n * @this {*}\n */\nvjs.obj.each = function(obj, fn, context){\n  for (var key in obj) {\n    if (hasOwnProp.call(obj, key)) {\n      fn.call(context || this, key, obj[key]);\n    }\n  }\n};\n\n/**\n * Merge two objects together and return the original.\n * @param  {Object} obj1\n * @param  {Object} obj2\n * @return {Object}\n */\nvjs.obj.merge = function(obj1, obj2){\n  if (!obj2) { return obj1; }\n  for (var key in obj2){\n    if (hasOwnProp.call(obj2, key)) {\n      obj1[key] = obj2[key];\n    }\n  }\n  return obj1;\n};\n\n/**\n * Merge two objects, and merge any properties that are objects\n * instead of just overwriting one. Uses to merge options hashes\n * where deeper default settings are important.\n * @param  {Object} obj1 Object to override\n * @param  {Object} obj2 Overriding object\n * @return {Object}      New object. Obj1 and Obj2 will be untouched.\n */\nvjs.obj.deepMerge = function(obj1, obj2){\n  var key, val1, val2;\n\n  // make a copy of obj1 so we're not ovewriting original values.\n  // like prototype.options_ and all sub options objects\n  obj1 = vjs.obj.copy(obj1);\n\n  for (key in obj2){\n    if (hasOwnProp.call(obj2, key)) {\n      val1 = obj1[key];\n      val2 = obj2[key];\n\n      // Check if both properties are pure objects and do a deep merge if so\n      if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {\n        obj1[key] = vjs.obj.deepMerge(val1, val2);\n      } else {\n        obj1[key] = obj2[key];\n      }\n    }\n  }\n  return obj1;\n};\n\n/**\n * Make a copy of the supplied object\n * @param  {Object} obj Object to copy\n * @return {Object}     Copy of object\n */\nvjs.obj.copy = function(obj){\n  return vjs.obj.merge({}, obj);\n};\n\n/**\n * Check if an object is plain, and not a dom node or any object sub-instance\n * @param  {Object} obj Object to check\n * @return {Boolean}     True if plain, false otherwise\n */\nvjs.obj.isPlain = function(obj){\n  return !!obj\n    && typeof obj === 'object'\n    && obj.toString() === '[object Object]'\n    && obj.constructor === Object;\n};\n\n/**\n * Bind (a.k.a proxy or Context). A simple method for changing the context of a function\n   It also stores a unique id on the function so it can be easily removed from events\n * @param  {*}   context The object to bind as scope\n * @param  {Function} fn      The function to be bound to a scope\n * @param  {Number=}   uid     An optional unique ID for the function to be set\n * @return {Function}\n */\nvjs.bind = function(context, fn, uid) {\n  // Make sure the function has a unique ID\n  if (!fn.guid) { fn.guid = vjs.guid++; }\n\n  // Create the new function that changes the context\n  var ret = function() {\n    return fn.apply(context, arguments);\n  };\n\n  // Allow for the ability to individualize this function\n  // Needed in the case where multiple objects might share the same prototype\n  // IF both items add an event listener with the same function, then you try to remove just one\n  // it will remove both because they both have the same guid.\n  // when using this, you need to use the bind method when you remove the listener as well.\n  // currently used in text tracks\n  ret.guid = (uid) ? uid + '_' + fn.guid : fn.guid;\n\n  return ret;\n};\n\n/**\n * Element Data Store. Allows for binding data to an element without putting it directly on the element.\n * Ex. Event listneres are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n * @type {Object}\n */\nvjs.cache = {};\n\n/**\n * Unique ID for an element or function\n * @type {Number}\n */\nvjs.guid = 1;\n\n/**\n * Unique attribute name to store an element's guid in\n * @type {String}\n * @constant\n */\nvjs.expando = 'vdata' + (new Date()).getTime();\n\n/**\n * Returns the cache object where data for an element is stored\n * @param  {Element} el Element to store data for.\n * @return {Object}\n */\nvjs.getData = function(el){\n  var id = el[vjs.expando];\n  if (!id) {\n    id = el[vjs.expando] = vjs.guid++;\n    vjs.cache[id] = {};\n  }\n  return vjs.cache[id];\n};\n\n/**\n * Returns the cache object where data for an element is stored\n * @param  {Element} el Element to store data for.\n * @return {Object}\n */\nvjs.hasData = function(el){\n  var id = el[vjs.expando];\n  return !(!id || vjs.isEmpty(vjs.cache[id]));\n};\n\n/**\n * Delete data for the element from the cache and the guid attr from getElementById\n * @param  {Element} el Remove data for an element\n */\nvjs.removeData = function(el){\n  var id = el[vjs.expando];\n  if (!id) { return; }\n  // Remove all stored data\n  // Changed to = null\n  // http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/\n  // vjs.cache[id] = null;\n  delete vjs.cache[id];\n\n  // Remove the expando property from the DOM node\n  try {\n    delete el[vjs.expando];\n  } catch(e) {\n    if (el.removeAttribute) {\n      el.removeAttribute(vjs.expando);\n    } else {\n      // IE doesn't appear to support removeAttribute on the document element\n      el[vjs.expando] = null;\n    }\n  }\n};\n\nvjs.isEmpty = function(obj) {\n  for (var prop in obj) {\n    // Inlude null properties as empty.\n    if (obj[prop] !== null) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Add a CSS class name to an element\n * @param {Element} element    Element to add class name to\n * @param {String} classToAdd Classname to add\n */\nvjs.addClass = function(element, classToAdd){\n  if ((' '+element.className+' ').indexOf(' '+classToAdd+' ') == -1) {\n    element.className = element.className === '' ? classToAdd : element.className + ' ' + classToAdd;\n  }\n};\n\n/**\n * Remove a CSS class name from an element\n * @param {Element} element    Element to remove from class name\n * @param {String} classToAdd Classname to remove\n */\nvjs.removeClass = function(element, classToRemove){\n  var classNames, i;\n\n  if (element.className.indexOf(classToRemove) == -1) { return; }\n\n  classNames = element.className.split(' ');\n\n  // no arr.indexOf in ie8, and we don't want to add a big shim\n  for (i = classNames.length - 1; i >= 0; i--) {\n    if (classNames[i] === classToRemove) {\n      classNames.splice(i,1);\n    }\n  }\n\n  element.className = classNames.join(' ');\n};\n\n/**\n * Element for testing browser HTML5 video capabilities\n * @type {Element}\n * @constant\n */\nvjs.TEST_VID = vjs.createEl('video');\n\n/**\n * Useragent for browser testing.\n * @type {String}\n * @constant\n */\nvjs.USER_AGENT = navigator.userAgent;\n\n/**\n * Device is an iPhone\n * @type {Boolean}\n * @constant\n */\nvjs.IS_IPHONE = (/iPhone/i).test(vjs.USER_AGENT);\nvjs.IS_IPAD = (/iPad/i).test(vjs.USER_AGENT);\nvjs.IS_IPOD = (/iPod/i).test(vjs.USER_AGENT);\nvjs.IS_IOS = vjs.IS_IPHONE || vjs.IS_IPAD || vjs.IS_IPOD;\n\nvjs.IOS_VERSION = (function(){\n  var match = vjs.USER_AGENT.match(/OS (\\d+)_/i);\n  if (match && match[1]) { return match[1]; }\n})();\n\nvjs.IS_ANDROID = (/Android/i).test(vjs.USER_AGENT);\nvjs.ANDROID_VERSION = (function() {\n  // This matches Android Major.Minor.Patch versions\n  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\n  var match = vjs.USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i),\n    major,\n    minor;\n\n  if (!match) {\n    return null;\n  }\n\n  major = match[1] && parseFloat(match[1]);\n  minor = match[2] && parseFloat(match[2]);\n\n  if (major && minor) {\n    return parseFloat(match[1] + '.' + match[2]);\n  } else if (major) {\n    return major;\n  } else {\n    return null;\n  }\n})();\n// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser\nvjs.IS_OLD_ANDROID = vjs.IS_ANDROID && (/webkit/i).test(vjs.USER_AGENT) && vjs.ANDROID_VERSION < 2.3;\n\nvjs.IS_FIREFOX = (/Firefox/i).test(vjs.USER_AGENT);\nvjs.IS_CHROME = (/Chrome/i).test(vjs.USER_AGENT);\n\nvjs.TOUCH_ENABLED = ('ontouchstart' in window);\n\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributs are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n * @param  {Element} tag Element from which to get tag attributes\n * @return {Object}\n */\nvjs.getAttributeValues = function(tag){\n  var obj, knownBooleans, attrs, attrName, attrVal;\n\n  obj = {};\n\n  // known boolean attributes\n  // we can check for matching boolean properties, but older browsers\n  // won't know about HTML5 boolean attributes that we still read from\n  knownBooleans = ','+'autoplay,controls,loop,muted,default'+',';\n\n  if (tag && tag.attributes && tag.attributes.length > 0) {\n    attrs = tag.attributes;\n\n    for (var i = attrs.length - 1; i >= 0; i--) {\n      attrName = attrs[i].name;\n      attrVal = attrs[i].value;\n\n      // check for known booleans\n      // the matching element property will return a value for typeof\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(','+attrName+',') !== -1) {\n        // the value of an included boolean attribute is typically an empty\n        // string ('') which would equal false if we just check for a false value.\n        // we also don't want support bad code like autoplay='false'\n        attrVal = (attrVal !== null) ? true : false;\n      }\n\n      obj[attrName] = attrVal;\n    }\n  }\n\n  return obj;\n};\n\n/**\n * Get the computed style value for an element\n * From http://robertnyman.com/2006/04/24/get-the-rendered-style-of-an-element/\n * @param  {Element} el        Element to get style value for\n * @param  {String} strCssRule Style name\n * @return {String}            Style value\n */\nvjs.getComputedDimension = function(el, strCssRule){\n  var strValue = '';\n  if(document.defaultView && document.defaultView.getComputedStyle){\n    strValue = document.defaultView.getComputedStyle(el, '').getPropertyValue(strCssRule);\n\n  } else if(el.currentStyle){\n    // IE8 Width/Height support\n    strValue = el['client'+strCssRule.substr(0,1).toUpperCase() + strCssRule.substr(1)] + 'px';\n  }\n  return strValue;\n};\n\n/**\n * Insert an element as the first child node of another\n * @param  {Element} child   Element to insert\n * @param  {[type]} parent Element to insert child into\n */\nvjs.insertFirst = function(child, parent){\n  if (parent.firstChild) {\n    parent.insertBefore(child, parent.firstChild);\n  } else {\n    parent.appendChild(child);\n  }\n};\n\n/**\n * Object to hold browser support information\n * @type {Object}\n */\nvjs.support = {};\n\n/**\n * Shorthand for document.getElementById()\n * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.\n * @param  {String} id  Element ID\n * @return {Element}    Element with supplied ID\n */\nvjs.el = function(id){\n  if (id.indexOf('#') === 0) {\n    id = id.slice(1);\n  }\n\n  return document.getElementById(id);\n};\n\n/**\n * Format seconds as a time string, H:MM:SS or M:SS\n * Supplying a guide (in seconds) will force a number of leading zeros\n * to cover the length of the guide\n * @param  {Number} seconds Number of seconds to be turned into a string\n * @param  {Number} guide   Number (in seconds) to model the string after\n * @return {String}         Time formatted as H:MM:SS or M:SS\n */\nvjs.formatTime = function(seconds, guide) {\n  // Default to using seconds as guide\n  guide = guide || seconds;\n  var s = Math.floor(seconds % 60),\n      m = Math.floor(seconds / 60 % 60),\n      h = Math.floor(seconds / 3600),\n      gm = Math.floor(guide / 60 % 60),\n      gh = Math.floor(guide / 3600);\n\n  // handle invalid times\n  if (isNaN(seconds) || seconds === Infinity) {\n    // '-' is false for all relational operators (e.g. <, >=) so this setting\n    // will add the minimum number of fields specified by the guide\n    h = m = s = '-';\n  }\n\n  // Check if we need to show hours\n  h = (h > 0 || gh > 0) ? h + ':' : '';\n\n  // If hours are showing, we may need to add a leading zero.\n  // Always show at least one digit of minutes.\n  m = (((h || gm >= 10) && m < 10) ? '0' + m : m) + ':';\n\n  // Check if leading zero is need for seconds\n  s = (s < 10) ? '0' + s : s;\n\n  return h + m + s;\n};\n\n// Attempt to block the ability to select text while dragging controls\nvjs.blockTextSelection = function(){\n  document.body.focus();\n  document.onselectstart = function () { return false; };\n};\n// Turn off text selection blocking\nvjs.unblockTextSelection = function(){ document.onselectstart = function () { return true; }; };\n\n/**\n * Trim whitespace from the ends of a string.\n * @param  {String} string String to trim\n * @return {String}        Trimmed string\n */\nvjs.trim = function(str){\n  return (str+'').replace(/^\\s+|\\s+$/g, '');\n};\n\n/**\n * Should round off a number to a decimal place\n * @param  {Number} num Number to round\n * @param  {Number} dec Number of decimal places to round to\n * @return {Number}     Rounded number\n */\nvjs.round = function(num, dec) {\n  if (!dec) { dec = 0; }\n  return Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);\n};\n\n/**\n * Should create a fake TimeRange object\n * Mimics an HTML5 time range instance, which has functions that\n * return the start and end times for a range\n * TimeRanges are returned by the buffered() method\n * @param  {Number} start Start time in seconds\n * @param  {Number} end   End time in seconds\n * @return {Object}       Fake TimeRange object\n */\nvjs.createTimeRange = function(start, end){\n  return {\n    length: 1,\n    start: function() { return start; },\n    end: function() { return end; }\n  };\n};\n\n/**\n * Simple http request for retrieving external files (e.g. text tracks)\n * @param  {String} url           URL of resource\n * @param  {Function=} onSuccess  Success callback\n * @param  {Function=} onError    Error callback\n */\nvjs.get = function(url, onSuccess, onError){\n  var local, request;\n\n  if (typeof XMLHttpRequest === 'undefined') {\n    window.XMLHttpRequest = function () {\n      try { return new window.ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch (e) {}\n      try { return new window.ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch (f) {}\n      try { return new window.ActiveXObject('Msxml2.XMLHTTP'); } catch (g) {}\n      throw new Error('This browser does not support XMLHttpRequest.');\n    };\n  }\n\n  request = new XMLHttpRequest();\n  try {\n    request.open('GET', url);\n  } catch(e) {\n    onError(e);\n  }\n\n  local = (url.indexOf('file:') === 0 || (window.location.href.indexOf('file:') === 0 && url.indexOf('http') === -1));\n\n  request.onreadystatechange = function() {\n    if (request.readyState === 4) {\n      if (request.status === 200 || local && request.status === 0) {\n        onSuccess(request.responseText);\n      } else {\n        if (onError) {\n          onError();\n        }\n      }\n    }\n  };\n\n  try {\n    request.send();\n  } catch(e) {\n    if (onError) {\n      onError(e);\n    }\n  }\n};\n\n/* Local Storage\n================================================================================ */\nvjs.setLocalStorage = function(key, value){\n  try {\n    // IE was throwing errors referencing the var anywhere without this\n    var localStorage = window.localStorage || false;\n    if (!localStorage) { return; }\n    localStorage[key] = value;\n  } catch(e) {\n    if (e.code == 22 || e.code == 1014) { // Webkit == 22 / Firefox == 1014\n      vjs.log('LocalStorage Full (VideoJS)', e);\n    } else {\n      if (e.code == 18) {\n        vjs.log('LocalStorage not allowed (VideoJS)', e);\n      } else {\n        vjs.log('LocalStorage Error (VideoJS)', e);\n      }\n    }\n  }\n};\n\n/**\n * Get abosolute version of relative URL. Used to tell flash correct URL.\n * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n * @param  {String} url URL to make absolute\n * @return {String}     Absolute URL\n */\nvjs.getAbsoluteURL = function(url){\n\n  // Check if absolute URL\n  if (!url.match(/^https?:\\/\\//)) {\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\n    url = vjs.createEl('div', {\n      innerHTML: '<a href=\"'+url+'\">x</a>'\n    }).firstChild.href;\n  }\n\n  return url;\n};\n\n// usage: log('inside coolFunc',this,arguments);\n// http://paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/\nvjs.log = function(){\n  vjs.log.history = vjs.log.history || [];   // store logs to an array for reference\n  vjs.log.history.push(arguments);\n  if(window.console){\n    window.console.log(Array.prototype.slice.call(arguments));\n  }\n};\n\n// Offset Left\n// getBoundingClientRect technique from John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/\nvjs.findPosition = function(el) {\n    var box, docEl, body, clientLeft, scrollLeft, left, clientTop, scrollTop, top;\n\n    if (el.getBoundingClientRect && el.parentNode) {\n      box = el.getBoundingClientRect();\n    }\n\n    if (!box) {\n      return {\n        left: 0,\n        top: 0\n      };\n    }\n\n    docEl = document.documentElement;\n    body = document.body;\n\n    clientLeft = docEl.clientLeft || body.clientLeft || 0;\n    scrollLeft = window.pageXOffset || body.scrollLeft;\n    left = box.left + scrollLeft - clientLeft;\n\n    clientTop = docEl.clientTop || body.clientTop || 0;\n    scrollTop = window.pageYOffset || body.scrollTop;\n    top = box.top + scrollTop - clientTop;\n\n    return {\n      left: left,\n      top: top\n    };\n};\n/**\n * @fileoverview Player Component - Base class for all UI objects\n *\n */\n\n/**\n * Base UI Component class\n * @param {Object} player  Main Player\n * @param {Object=} options\n * @constructor\n */\nvjs.Component = vjs.CoreObject.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    this.player_ = player;\n\n    // Make a copy of prototype.options_ to protect against overriding global defaults\n    this.options_ = vjs.obj.copy(this.options_);\n\n    // Updated options with supplied options\n    options = this.options(options);\n\n    // Get ID from options, element, or create using player ID and unique ID\n    this.id_ = options['id'] || ((options['el'] && options['el']['id']) ? options['el']['id'] : player.id() + '_component_' + vjs.guid++ );\n\n    this.name_ = options['name'] || null;\n\n    // Create element if one wasn't provided in options\n    this.el_ = options['el'] || this.createEl();\n\n    this.children_ = [];\n    this.childIndex_ = {};\n    this.childNameIndex_ = {};\n\n    // Add any child components in options\n    this.initChildren();\n\n    this.ready(ready);\n    // Don't want to trigger ready here or it will before init is actually\n    // finished for all children that run this constructor\n  }\n});\n\n/**\n * Dispose of the component and all child components.\n */\nvjs.Component.prototype.dispose = function(){\n  this.trigger('dispose');\n\n  // Dispose all children.\n  if (this.children_) {\n    for (var i = this.children_.length - 1; i >= 0; i--) {\n      if (this.children_[i].dispose) {\n        this.children_[i].dispose();\n      }\n    }\n  }\n\n  // Delete child references\n  this.children_ = null;\n  this.childIndex_ = null;\n  this.childNameIndex_ = null;\n\n  // Remove all event listeners.\n  this.off();\n\n  // Remove element from DOM\n  if (this.el_.parentNode) {\n    this.el_.parentNode.removeChild(this.el_);\n  }\n\n  vjs.removeData(this.el_);\n  this.el_ = null;\n};\n\n/**\n * Reference to main player instance.\n * @type {vjs.Player}\n * @private\n */\nvjs.Component.prototype.player_;\n\n/**\n * Return the component's player.\n * @return {vjs.Player}\n */\nvjs.Component.prototype.player = function(){\n  return this.player_;\n};\n\n/**\n * Component options object.\n * @type {Object}\n * @private\n */\nvjs.Component.prototype.options_;\n\n/**\n * Deep merge of options objects\n * Whenever a property is an object on both options objects\n * the two properties will be merged using vjs.obj.deepMerge.\n *\n * This is used for merging options for child components. We\n * want it to be easy to override individual options on a child\n * component without having to rewrite all the other default options.\n *\n * Parent.prototype.options_ = {\n *   children: {\n *     'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },\n *     'childTwo': {},\n *     'childThree': {}\n *   }\n * }\n * newOptions = {\n *   children: {\n *     'childOne': { 'foo': 'baz', 'abc': '123' }\n *     'childTwo': null,\n *     'childFour': {}\n *   }\n * }\n *\n * this.options(newOptions);\n *\n * RESULT\n *\n * {\n *   children: {\n *     'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },\n *     'childTwo': null, // Disabled. Won't be initialized.\n *     'childThree': {},\n *     'childFour': {}\n *   }\n * }\n *\n * @param  {Object} obj Object whose values will be overwritten\n * @return {Object}      NEW merged object. Does not return obj1.\n */\nvjs.Component.prototype.options = function(obj){\n  if (obj === undefined) return this.options_;\n\n  return this.options_ = vjs.obj.deepMerge(this.options_, obj);\n};\n\n/**\n * The DOM element for the component.\n * @type {Element}\n * @private\n */\nvjs.Component.prototype.el_;\n\n/**\n * Create the component's DOM element.\n * @param  {String=} tagName  Element's node type. e.g. 'div'\n * @param  {Object=} attributes An object of element attributes that should be set on the element.\n * @return {Element}\n */\nvjs.Component.prototype.createEl = function(tagName, attributes){\n  return vjs.createEl(tagName, attributes);\n};\n\n/**\n * Return the component's DOM element.\n * @return {Element}\n */\nvjs.Component.prototype.el = function(){\n  return this.el_;\n};\n\n/**\n * An optional element where, if defined, children will be inserted\n *   instead of directly in el_\n * @type {Element}\n * @private\n */\nvjs.Component.prototype.contentEl_;\n\n/**\n * Return the component's DOM element for embedding content.\n *   will either be el_ or a new element defined in createEl\n * @return {Element}\n */\nvjs.Component.prototype.contentEl = function(){\n  return this.contentEl_ || this.el_;\n};\n\n/**\n * The ID for the component.\n * @type {String}\n * @private\n */\nvjs.Component.prototype.id_;\n\n/**\n * Return the component's ID.\n * @return {String}\n */\nvjs.Component.prototype.id = function(){\n  return this.id_;\n};\n\n/**\n * The name for the component. Often used to reference the component.\n * @type {String}\n * @private\n */\nvjs.Component.prototype.name_;\n\n/**\n * Return the component's ID.\n * @return {String}\n */\nvjs.Component.prototype.name = function(){\n  return this.name_;\n};\n\n/**\n * Array of child components\n * @type {Array}\n * @private\n */\nvjs.Component.prototype.children_;\n\n/**\n * Returns array of all child components.\n * @return {Array}\n */\nvjs.Component.prototype.children = function(){\n  return this.children_;\n};\n\n/**\n * Object of child components by ID\n * @type {Object}\n * @private\n */\nvjs.Component.prototype.childIndex_;\n\n/**\n * Returns a child component with the provided ID.\n * @return {Array}\n */\nvjs.Component.prototype.getChildById = function(id){\n  return this.childIndex_[id];\n};\n\n/**\n * Object of child components by Name\n * @type {Object}\n * @private\n */\nvjs.Component.prototype.childNameIndex_;\n\n/**\n * Returns a child component with the provided ID.\n * @return {Array}\n */\nvjs.Component.prototype.getChild = function(name){\n  return this.childNameIndex_[name];\n};\n\n/**\n * Adds a child component inside this component.\n * @param {String|vjs.Component} child The class name or instance of a child to add.\n * @param {Object=} options Optional options, including options to be passed to\n *  children of the child.\n * @return {vjs.Component} The child component, because it might be created in this process.\n * @suppress {accessControls|checkRegExp|checkTypes|checkVars|const|constantProperty|deprecated|duplicate|es5Strict|fileoverviewTags|globalThis|invalidCasts|missingProperties|nonStandardJsDocs|strictModuleDepCheck|undefinedNames|undefinedVars|unknownDefines|uselessCode|visibility}\n */\nvjs.Component.prototype.addChild = function(child, options){\n  var component, componentClass, componentName, componentId;\n\n  // If string, create new component with options\n  if (typeof child === 'string') {\n\n    componentName = child;\n\n    // Make sure options is at least an empty object to protect against errors\n    options = options || {};\n\n    // Assume name of set is a lowercased name of the UI Class (PlayButton, etc.)\n    componentClass = options['componentClass'] || vjs.capitalize(componentName);\n\n    // Set name through options\n    options['name'] = componentName;\n\n    // Create a new object & element for this controls set\n    // If there's no .player_, this is a player\n    // Closure Compiler throws an 'incomplete alias' warning if we use the vjs variable directly.\n    // Every class should be exported, so this should never be a problem here.\n    component = new __webpack_provided_window_dot_videojs[componentClass](this.player_ || this, options);\n\n  // child is a component instance\n  } else {\n    component = child;\n  }\n\n  this.children_.push(component);\n\n  if (typeof component.id === 'function') {\n    this.childIndex_[component.id()] = component;\n  }\n\n  // If a name wasn't used to create the component, check if we can use the\n  // name function of the component\n  componentName = componentName || (component.name && component.name());\n\n  if (componentName) {\n    this.childNameIndex_[componentName] = component;\n  }\n\n  // Add the UI object's element to the container div (box)\n  // Having an element is not required\n  if (typeof component['el'] === 'function' && component['el']()) {\n    this.contentEl().appendChild(component['el']());\n  }\n\n  // Return so it can stored on parent object if desired.\n  return component;\n};\n\nvjs.Component.prototype.removeChild = function(component){\n  if (typeof component === 'string') {\n    component = this.getChild(component);\n  }\n\n  if (!component || !this.children_) return;\n\n  var childFound = false;\n  for (var i = this.children_.length - 1; i >= 0; i--) {\n    if (this.children_[i] === component) {\n      childFound = true;\n      this.children_.splice(i,1);\n      break;\n    }\n  }\n\n  if (!childFound) return;\n\n  this.childIndex_[component.id] = null;\n  this.childNameIndex_[component.name] = null;\n\n  var compEl = component.el();\n  if (compEl && compEl.parentNode === this.contentEl()) {\n    this.contentEl().removeChild(component.el());\n  }\n};\n\n/**\n * Initialize default child components from options\n */\nvjs.Component.prototype.initChildren = function(){\n  var options = this.options_;\n\n  if (options && options['children']) {\n    var self = this;\n\n    // Loop through components and add them to the player\n    vjs.obj.each(options['children'], function(name, opts){\n      // Allow for disabling default components\n      // e.g. vjs.options['children']['posterImage'] = false\n      if (opts === false) return;\n\n      // Allow waiting to add components until a specific event is called\n      var tempAdd = function(){\n        // Set property name on player. Could cause conflicts with other prop names, but it's worth making refs easy.\n        self[name] = self.addChild(name, opts);\n      };\n\n      if (opts['loadEvent']) {\n        // this.one(opts.loadEvent, tempAdd)\n      } else {\n        tempAdd();\n      }\n    });\n  }\n};\n\nvjs.Component.prototype.buildCSSClass = function(){\n    // Child classes can include a function that does:\n    // return 'CLASS NAME' + this._super();\n    return '';\n};\n\n/* Events\n============================================================================= */\n\n/**\n * Add an event listener to this component's element. Context will be the component.\n * @param  {String}   type Event type e.g. 'click'\n * @param  {Function} fn   Event listener\n * @return {vjs.Component}\n */\nvjs.Component.prototype.on = function(type, fn){\n  vjs.on(this.el_, type, vjs.bind(this, fn));\n  return this;\n};\n\n/**\n * Remove an event listener from the component's element\n * @param  {String=}   type Optional event type. Without type it will remove all listeners.\n * @param  {Function=} fn   Optional event listener. Without fn it will remove all listeners for a type.\n * @return {vjs.Component}\n */\nvjs.Component.prototype.off = function(type, fn){\n  vjs.off(this.el_, type, fn);\n  return this;\n};\n\n/**\n * Add an event listener to be triggered only once and then removed\n * @param  {String}   type Event type\n * @param  {Function} fn   Event listener\n * @return {vjs.Component}\n */\nvjs.Component.prototype.one = function(type, fn) {\n  vjs.one(this.el_, type, vjs.bind(this, fn));\n  return this;\n};\n\n/**\n * Trigger an event on an element\n * @param  {String} type  Event type to trigger\n * @param  {Event|Object} event Event object to be passed to the listener\n * @return {vjs.Component}\n */\nvjs.Component.prototype.trigger = function(type, event){\n  vjs.trigger(this.el_, type, event);\n  return this;\n};\n\n/* Ready\n================================================================================ */\n/**\n * Is the component loaded.\n * @type {Boolean}\n * @private\n */\nvjs.Component.prototype.isReady_;\n\n/**\n * Trigger ready as soon as initialization is finished.\n *   Allows for delaying ready. Override on a sub class prototype.\n *   If you set this.isReadyOnInitFinish_ it will affect all components.\n *   Specially used when waiting for the Flash player to asynchrnously load.\n *   @type {Boolean}\n *   @private\n */\nvjs.Component.prototype.isReadyOnInitFinish_ = true;\n\n/**\n * List of ready listeners\n * @type {Array}\n * @private\n */\nvjs.Component.prototype.readyQueue_;\n\n/**\n * Bind a listener to the component's ready state.\n *   Different from event listeners in that if the ready event has already happend\n *   it will trigger the function immediately.\n * @param  {Function} fn Ready listener\n * @return {vjs.Component}\n */\nvjs.Component.prototype.ready = function(fn){\n  if (fn) {\n    if (this.isReady_) {\n      fn.call(this);\n    } else {\n      if (this.readyQueue_ === undefined) {\n        this.readyQueue_ = [];\n      }\n      this.readyQueue_.push(fn);\n    }\n  }\n  return this;\n};\n\n/**\n * Trigger the ready listeners\n * @return {vjs.Component}\n */\nvjs.Component.prototype.triggerReady = function(){\n  this.isReady_ = true;\n\n  var readyQueue = this.readyQueue_;\n\n  if (readyQueue && readyQueue.length > 0) {\n    var stack = new Error().stack;\n    for (var i = 0, j = readyQueue.length; i < j; i++) {\n      readyQueue[i].call(this);\n    }\n\n    // Reset Ready Queue\n    this.readyQueue_ = [];\n\n    // Allow for using event listeners also, in case you want to do something everytime a source is ready.\n    this.trigger('ready');\n  }\n};\n\n/* Display\n============================================================================= */\n\n/**\n * Add a CSS class name to the component's element\n * @param {String} classToAdd Classname to add\n * @return {vjs.Component}\n */\nvjs.Component.prototype.addClass = function(classToAdd){\n  vjs.addClass(this.el_, classToAdd);\n  return this;\n};\n\n/**\n * Remove a CSS class name from the component's element\n * @param {String} classToRemove Classname to remove\n * @return {vjs.Component}\n */\nvjs.Component.prototype.removeClass = function(classToRemove){\n  vjs.removeClass(this.el_, classToRemove);\n  return this;\n};\n\n/**\n * Show the component element if hidden\n * @return {vjs.Component}\n */\nvjs.Component.prototype.show = function(){\n  this.el_.style.display = 'block';\n  return this;\n};\n\n/**\n * Hide the component element if hidden\n * @return {vjs.Component}\n */\nvjs.Component.prototype.hide = function(){\n  this.el_.style.display = 'none';\n  return this;\n};\n\n/**\n * Lock an item in its visible state. To be used with fadeIn/fadeOut.\n * @return {vjs.Component}\n */\nvjs.Component.prototype.lockShowing = function(){\n  this.addClass('vjs-lock-showing');\n  return this;\n};\n\n/**\n * Unlock an item to be hidden. To be used with fadeIn/fadeOut.\n * @return {vjs.Component}\n */\nvjs.Component.prototype.unlockShowing = function(){\n  this.removeClass('vjs-lock-showing');\n  return this;\n};\n\n/**\n * Disable component by making it unshowable\n */\nvjs.Component.prototype.disable = function(){\n  this.hide();\n  this.show = function(){};\n};\n\n/**\n * If a value is provided it will change the width of the player to that value\n * otherwise the width is returned\n * http://dev.w3.org/html5/spec/dimension-attributes.html#attr-dim-height\n * Video tag width/height only work in pixels. No percents.\n * But allowing limited percents use. e.g. width() will return number+%, not computed width\n * @param  {Number|String=} num   Optional width number\n * @param  {[type]} skipListeners Skip the 'resize' event trigger\n * @return {vjs.Component|Number|String} Returns 'this' if dimension was set.\n *   Otherwise it returns the dimension.\n */\nvjs.Component.prototype.width = function(num, skipListeners){\n  return this.dimension('width', num, skipListeners);\n};\n\n/**\n * Get or set the height of the player\n * @param  {Number|String=} num     Optional new player height\n * @param  {Boolean=} skipListeners Optional skip resize event trigger\n * @return {vjs.Component|Number|String} The player, or the dimension\n */\nvjs.Component.prototype.height = function(num, skipListeners){\n  return this.dimension('height', num, skipListeners);\n};\n\n/**\n * Set both width and height at the same time.\n * @param  {Number|String} width\n * @param  {Number|String} height\n * @return {vjs.Component}   The player.\n */\nvjs.Component.prototype.dimensions = function(width, height){\n  // Skip resize listeners on width for optimization\n  return this.width(width, true).height(height);\n};\n\n/**\n * Get or set width or height.\n * All for an integer, integer + 'px' or integer + '%';\n * Known issue: hidden elements. Hidden elements officially have a width of 0.\n * So we're defaulting to the style.width value and falling back to computedStyle\n * which has the hidden element issue.\n * Info, but probably not an efficient fix:\n * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/\n * @param  {String=} widthOrHeight 'width' or 'height'\n * @param  {Number|String=} num           New dimension\n * @param  {Boolean=} skipListeners Skip resize event trigger\n * @return {vjs.Component|Number|String} Return the player if setting a dimension.\n *                                         Otherwise it returns the dimension.\n */\nvjs.Component.prototype.dimension = function(widthOrHeight, num, skipListeners){\n  if (num !== undefined) {\n\n    // Check if using css width/height (% or px) and adjust\n    if ((''+num).indexOf('%') !== -1 || (''+num).indexOf('px') !== -1) {\n      this.el_.style[widthOrHeight] = num;\n    } else if (num === 'auto') {\n      this.el_.style[widthOrHeight] = '';\n    } else {\n      this.el_.style[widthOrHeight] = num+'px';\n    }\n\n    // skipListeners allows us to avoid triggering the resize event when setting both width and height\n    if (!skipListeners) { this.trigger('resize'); }\n\n    // Return component\n    return this;\n  }\n\n  // Not setting a value, so getting it\n  // Make sure element exists\n  if (!this.el_) return 0;\n\n  // Get dimension value from style\n  var val = this.el_.style[widthOrHeight];\n  var pxIndex = val.indexOf('px');\n  if (pxIndex !== -1) {\n    // Return the pixel value with no 'px'\n    return parseInt(val.slice(0,pxIndex), 10);\n\n  // No px so using % or no style was set, so falling back to offsetWidth/height\n  // If component has display:none, offset will return 0\n  // TODO: handle display:none and no dimension style using px\n  } else {\n\n    return parseInt(this.el_['offset'+vjs.capitalize(widthOrHeight)], 10);\n\n    // ComputedStyle version.\n    // Only difference is if the element is hidden it will return\n    // the percent value (e.g. '100%'')\n    // instead of zero like offsetWidth returns.\n    // var val = vjs.getComputedStyleValue(this.el_, widthOrHeight);\n    // var pxIndex = val.indexOf('px');\n\n    // if (pxIndex !== -1) {\n    //   return val.slice(0, pxIndex);\n    // } else {\n    //   return val;\n    // }\n  }\n};\n\n/**\n * Emit 'tap' events when touch events are supported. We're requireing them to\n * be enabled because otherwise every component would have this extra overhead\n * unnecessarily, on mobile devices where extra overhead is especially bad.\n *\n * This is being implemented so we can support taps on the video element\n * toggling the controls.\n */\nvjs.Component.prototype.emitTapEvents = function(){\n  var touchStart, touchTime, couldBeTap, noTap;\n\n  // Track the start time so we can determine how long the touch lasted\n  touchStart = 0;\n\n  this.on('touchstart', function(event) {\n    // Record start time so we can detect a tap vs. \"touch and hold\"\n    touchStart = new Date().getTime();\n    // Reset couldBeTap tracking\n    couldBeTap = true;\n  });\n\n  noTap = function(){\n    couldBeTap = false;\n  };\n  // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\n  this.on('touchmove', noTap);\n  this.on('touchleave', noTap);\n  this.on('touchcancel', noTap);\n\n  // When the touch ends, measure how long it took and trigger the appropriate\n  // event\n  this.on('touchend', function() {\n    // Proceed only if the touchmove/leave/cancel event didn't happen\n    if (couldBeTap === true) {\n      // Measure how long the touch lasted\n      touchTime = new Date().getTime() - touchStart;\n      // The touch needs to be quick in order to consider it a tap\n      if (touchTime < 250) {\n        this.trigger('tap');\n        // It may be good to copy the touchend event object and change the\n        // type to tap, if the other event properties aren't exact after\n        // vjs.fixEvent runs (e.g. event.target)\n      }\n    }\n  });\n};\n/* Button - Base class for all buttons\n================================================================================ */\n/**\n * Base class for all buttons\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.Button = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n\n    var touchstart = false;\n    this.on('touchstart', function(event) {\n      // Stop click and other mouse events from triggering also\n      event.preventDefault();\n      touchstart = true;\n    });\n    this.on('touchmove', function() {\n      touchstart = false;\n    });\n    var self = this;\n    this.on('touchend', function(event) {\n      if (touchstart) {\n        self.onClick(event);\n      }\n      event.preventDefault();\n    });\n\n    this.on('click', this.onClick);\n    this.on('focus', this.onFocus);\n    this.on('blur', this.onBlur);\n  }\n});\n\nvjs.Button.prototype.createEl = function(type, props){\n  // Add standard Aria and Tabindex info\n  props = vjs.obj.merge({\n    className: this.buildCSSClass(),\n    innerHTML: '<div class=\"vjs-control-content\"><span class=\"vjs-control-text\">' + (this.buttonText || 'Need Text') + '</span></div>',\n    role: 'button',\n    'aria-live': 'polite', // let the screen reader user know that the text of the button may change\n    tabIndex: 0\n  }, props);\n\n  return vjs.Component.prototype.createEl.call(this, type, props);\n};\n\nvjs.Button.prototype.buildCSSClass = function(){\n  // TODO: Change vjs-control to vjs-button?\n  return 'vjs-control ' + vjs.Component.prototype.buildCSSClass.call(this);\n};\n\n  // Click - Override with specific functionality for button\nvjs.Button.prototype.onClick = function(){};\n\n  // Focus - Add keyboard functionality to element\nvjs.Button.prototype.onFocus = function(){\n  vjs.on(document, 'keyup', vjs.bind(this, this.onKeyPress));\n};\n\n  // KeyPress (document level) - Trigger click when keys are pressed\nvjs.Button.prototype.onKeyPress = function(event){\n  // Check for space bar (32) or enter (13) keys\n  if (event.which == 32 || event.which == 13) {\n    event.preventDefault();\n    this.onClick();\n  }\n};\n\n// Blur - Remove keyboard triggers\nvjs.Button.prototype.onBlur = function(){\n  vjs.off(document, 'keyup', vjs.bind(this, this.onKeyPress));\n};\n/* Slider\n================================================================================ */\n/**\n * Parent for seek bar and volume slider\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.Slider = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n\n    // Set property names to bar and handle to match with the child Slider class is looking for\n    this.bar = this.getChild(this.options_['barName']);\n    this.handle = this.getChild(this.options_['handleName']);\n\n    player.on(this.playerEvent, vjs.bind(this, this.update));\n\n    this.on('mousedown', this.onMouseDown);\n    this.on('touchstart', this.onMouseDown);\n    this.on('focus', this.onFocus);\n    this.on('blur', this.onBlur);\n    this.on('click', this.onClick);\n\n    this.player_.on('controlsvisible', vjs.bind(this, this.update));\n\n    // This is actually to fix the volume handle position. http://twitter.com/#!/gerritvanaaken/status/159046254519787520\n    // this.player_.one('timeupdate', vjs.bind(this, this.update));\n\n    player.ready(vjs.bind(this, this.update));\n\n    this.boundEvents = {};\n  }\n});\n\nvjs.Slider.prototype.createEl = function(type, props) {\n  props = props || {};\n  // Add the slider element class to all sub classes\n  props.className = props.className + ' vjs-slider';\n  props = vjs.obj.merge({\n    role: 'slider',\n    'aria-valuenow': 0,\n    'aria-valuemin': 0,\n    'aria-valuemax': 100,\n    tabIndex: 0\n  }, props);\n\n  return vjs.Component.prototype.createEl.call(this, type, props);\n};\n\nvjs.Slider.prototype.onMouseDown = function(event){\n  event.preventDefault();\n  vjs.blockTextSelection();\n\n  this.boundEvents.move = vjs.bind(this, this.onMouseMove);\n  this.boundEvents.end = vjs.bind(this, this.onMouseUp);\n\n  vjs.on(document, 'mousemove', this.boundEvents.move);\n  vjs.on(document, 'mouseup', this.boundEvents.end);\n  vjs.on(document, 'touchmove', this.boundEvents.move);\n  vjs.on(document, 'touchend', this.boundEvents.end);\n\n  this.onMouseMove(event);\n};\n\nvjs.Slider.prototype.onMouseUp = function() {\n  vjs.unblockTextSelection();\n  vjs.off(document, 'mousemove', this.boundEvents.move, false);\n  vjs.off(document, 'mouseup', this.boundEvents.end, false);\n  vjs.off(document, 'touchmove', this.boundEvents.move, false);\n  vjs.off(document, 'touchend', this.boundEvents.end, false);\n\n  this.update();\n};\n\nvjs.Slider.prototype.update = function(){\n  // In VolumeBar init we have a setTimeout for update that pops and update to the end of the\n  // execution stack. The player is destroyed before then update will cause an error\n  if (!this.el_) return;\n\n  // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.\n  // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.\n  // var progress =  (this.player_.scrubbing) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();\n\n  var barProgress,\n      progress = this.getPercent(),\n      handle = this.handle,\n      bar = this.bar;\n\n  // Protect against no duration and other division issues\n  if (isNaN(progress)) { progress = 0; }\n\n  barProgress = progress;\n\n  // If there is a handle, we need to account for the handle in our calculation for progress bar\n  // so that it doesn't fall short of or extend past the handle.\n  if (handle) {\n\n    var box = this.el_,\n        boxWidth = box.offsetWidth,\n\n        handleWidth = handle.el().offsetWidth,\n\n        // The width of the handle in percent of the containing box\n        // In IE, widths may not be ready yet causing NaN\n        handlePercent = (handleWidth) ? handleWidth / boxWidth : 0,\n\n        // Get the adjusted size of the box, considering that the handle's center never touches the left or right side.\n        // There is a margin of half the handle's width on both sides.\n        boxAdjustedPercent = 1 - handlePercent,\n\n        // Adjust the progress that we'll use to set widths to the new adjusted box width\n        adjustedProgress = progress * boxAdjustedPercent;\n\n    // The bar does reach the left side, so we need to account for this in the bar's width\n    barProgress = adjustedProgress + (handlePercent / 2);\n\n    // Move the handle from the left based on the adjected progress\n    handle.el().style.left = vjs.round(adjustedProgress * 100, 2) + '%';\n  }\n\n  // Set the new bar width\n  bar.el().style.width = vjs.round(barProgress * 100, 2) + '%';\n};\n\nvjs.Slider.prototype.calculateDistance = function(event){\n  var el, box, boxX, boxY, boxW, boxH, handle, pageX, pageY;\n\n  el = this.el_;\n  box = vjs.findPosition(el);\n  boxW = boxH = el.offsetWidth;\n  handle = this.handle;\n\n  if (this.options_.vertical) {\n    boxY = box.top;\n\n    if (event.changedTouches) {\n      pageY = event.changedTouches[0].pageY;\n    } else {\n      pageY = event.pageY;\n    }\n\n    if (handle) {\n      var handleH = handle.el().offsetHeight;\n      // Adjusted X and Width, so handle doesn't go outside the bar\n      boxY = boxY + (handleH / 2);\n      boxH = boxH - handleH;\n    }\n\n    // Percent that the click is through the adjusted area\n    return Math.max(0, Math.min(1, ((boxY - pageY) + boxH) / boxH));\n\n  } else {\n    boxX = box.left;\n\n    if (event.changedTouches) {\n      pageX = event.changedTouches[0].pageX;\n    } else {\n      pageX = event.pageX;\n    }\n\n    if (handle) {\n      var handleW = handle.el().offsetWidth;\n\n      // Adjusted X and Width, so handle doesn't go outside the bar\n      boxX = boxX + (handleW / 2);\n      boxW = boxW - handleW;\n    }\n\n    // Percent that the click is through the adjusted area\n    return Math.max(0, Math.min(1, (pageX - boxX) / boxW));\n  }\n};\n\nvjs.Slider.prototype.onFocus = function(){\n  vjs.on(document, 'keyup', vjs.bind(this, this.onKeyPress));\n};\n\nvjs.Slider.prototype.onKeyPress = function(event){\n  if (event.which == 37) { // Left Arrow\n    event.preventDefault();\n    this.stepBack();\n  } else if (event.which == 39) { // Right Arrow\n    event.preventDefault();\n    this.stepForward();\n  }\n};\n\nvjs.Slider.prototype.onBlur = function(){\n  vjs.off(document, 'keyup', vjs.bind(this, this.onKeyPress));\n};\n\n/**\n * Listener for click events on slider, used to prevent clicks\n *   from bubbling up to parent elements like button menus.\n * @param  {Object} event Event object\n */\nvjs.Slider.prototype.onClick = function(event){\n  event.stopImmediatePropagation();\n  event.preventDefault();\n};\n\n/**\n * SeekBar Behavior includes play progress bar, and seek handle\n * Needed so it can determine seek position based on handle position/size\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.SliderHandle = vjs.Component.extend();\n\n/**\n * Default value of the slider\n * @type {Number}\n */\nvjs.SliderHandle.prototype.defaultValue = 0;\n\n/** @inheritDoc */\nvjs.SliderHandle.prototype.createEl = function(type, props) {\n  props = props || {};\n  // Add the slider element class to all sub classes\n  props.className = props.className + ' vjs-slider-handle';\n  props = vjs.obj.merge({\n    innerHTML: '<span class=\"vjs-control-text\">'+this.defaultValue+'</span>'\n  }, props);\n\n  return vjs.Component.prototype.createEl.call(this, 'div', props);\n};\n/* Menu\n================================================================================ */\n/**\n * The base for text track and settings menu buttons.\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.Menu = vjs.Component.extend();\n\n/**\n * Add a menu item to the menu\n * @param {Object|String} component Component or component type to add\n */\nvjs.Menu.prototype.addItem = function(component){\n  this.addChild(component);\n  component.on('click', vjs.bind(this, function(){\n    this.unlockShowing();\n  }));\n};\n\n/** @inheritDoc */\nvjs.Menu.prototype.createEl = function(){\n  var contentElType = this.options().contentElType || 'ul';\n  this.contentEl_ = vjs.createEl(contentElType, {\n    className: 'vjs-menu-content'\n  });\n  var el = vjs.Component.prototype.createEl.call(this, 'div', {\n    append: this.contentEl_,\n    className: 'vjs-menu'\n  });\n  el.appendChild(this.contentEl_);\n\n  // Prevent clicks from bubbling up. Needed for Menu Buttons,\n  // where a click on the parent is significant\n  vjs.on(el, 'click', function(event){\n    event.preventDefault();\n    event.stopImmediatePropagation();\n  });\n\n  return el;\n};\n\n/**\n * Menu item\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.MenuItem = vjs.Button.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Button.call(this, player, options);\n    this.selected(options['selected']);\n  }\n});\n\n/** @inheritDoc */\nvjs.MenuItem.prototype.createEl = function(type, props){\n  return vjs.Button.prototype.createEl.call(this, 'li', vjs.obj.merge({\n    className: 'vjs-menu-item',\n    innerHTML: this.options_['label']\n  }, props));\n};\n\n/** @inheritDoc */\nvjs.MenuItem.prototype.onClick = function(){\n  this.selected(true);\n};\n\n/**\n * Set this menu item as selected or not\n * @param  {Boolean} selected\n */\nvjs.MenuItem.prototype.selected = function(selected){\n  if (selected) {\n    this.addClass('vjs-selected');\n    this.el_.setAttribute('aria-selected',true);\n  } else {\n    this.removeClass('vjs-selected');\n    this.el_.setAttribute('aria-selected',false);\n  }\n};\n\n\n/**\n * A button class with a popup menu\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.MenuButton = vjs.Button.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Button.call(this, player, options);\n\n    this.menu = this.createMenu();\n\n    // Add list to element\n    this.addChild(this.menu);\n\n    // Automatically hide empty menu buttons\n    if (this.items && this.items.length === 0) {\n      this.hide();\n    }\n\n    this.on('keyup', this.onKeyPress);\n    this.el_.setAttribute('aria-haspopup', true);\n    this.el_.setAttribute('role', 'button');\n  }\n});\n\n/**\n * Track the state of the menu button\n * @type {Boolean}\n */\nvjs.MenuButton.prototype.buttonPressed_ = false;\n\nvjs.MenuButton.prototype.createMenu = function(){\n  var menu = new vjs.Menu(this.player_);\n\n  // Add a title list item to the top\n  if (this.options().title) {\n    menu.el().appendChild(vjs.createEl('li', {\n      className: 'vjs-menu-title',\n      innerHTML: vjs.capitalize(this.kind_),\n      tabindex: -1\n    }));\n  }\n\n  this.items = this['createItems']();\n\n  if (this.items) {\n    // Add menu items to the menu\n    for (var i = 0; i < this.items.length; i++) {\n      menu.addItem(this.items[i]);\n    }\n  }\n\n  return menu;\n};\n\n/**\n * Create the list of menu items. Specific to each subclass.\n */\nvjs.MenuButton.prototype.createItems = function(){};\n\n/** @inheritDoc */\nvjs.MenuButton.prototype.buildCSSClass = function(){\n  return this.className + ' vjs-menu-button ' + vjs.Button.prototype.buildCSSClass.call(this);\n};\n\n// Focus - Add keyboard functionality to element\n// This function is not needed anymore. Instead, the keyboard functionality is handled by\n// treating the button as triggering a submenu. When the button is pressed, the submenu\n// appears. Pressing the button again makes the submenu disappear.\nvjs.MenuButton.prototype.onFocus = function(){};\n// Can't turn off list display that we turned on with focus, because list would go away.\nvjs.MenuButton.prototype.onBlur = function(){};\n\nvjs.MenuButton.prototype.onClick = function(){\n  // When you click the button it adds focus, which will show the menu indefinitely.\n  // So we'll remove focus when the mouse leaves the button.\n  // Focus is needed for tab navigation.\n  this.one('mouseout', vjs.bind(this, function(){\n    this.menu.unlockShowing();\n    this.el_.blur();\n  }));\n  if (this.buttonPressed_){\n    this.unpressButton();\n  } else {\n    this.pressButton();\n  }\n};\n\nvjs.MenuButton.prototype.onKeyPress = function(event){\n  event.preventDefault();\n\n  // Check for space bar (32) or enter (13) keys\n  if (event.which == 32 || event.which == 13) {\n    if (this.buttonPressed_){\n      this.unpressButton();\n    } else {\n      this.pressButton();\n    }\n  // Check for escape (27) key\n  } else if (event.which == 27){\n    if (this.buttonPressed_){\n      this.unpressButton();\n    }\n  }\n};\n\nvjs.MenuButton.prototype.pressButton = function(){\n  this.buttonPressed_ = true;\n  this.menu.lockShowing();\n  this.el_.setAttribute('aria-pressed', true);\n  if (this.items && this.items.length > 0) {\n    this.items[0].el().focus(); // set the focus to the title of the submenu\n  }\n};\n\nvjs.MenuButton.prototype.unpressButton = function(){\n  this.buttonPressed_ = false;\n  this.menu.unlockShowing();\n  this.el_.setAttribute('aria-pressed', false);\n};\n\n/**\n * Main player class. A player instance is returned by _V_(id);\n * @param {Element} tag        The original video tag used for configuring options\n * @param {Object=} options    Player options\n * @param {Function=} ready    Ready callback function\n * @constructor\n */\nvjs.Player = vjs.Component.extend({\n  /** @constructor */\n  init: function(tag, options, ready){\n    this.tag = tag; // Store the original tag used to set options\n\n    // Set Options\n    // The options argument overrides options set in the video tag\n    // which overrides globally set options.\n    // This latter part coincides with the load order\n    // (tag must exist before Player)\n    options = vjs.obj.merge(this.getTagSettings(tag), options);\n\n    // Cache for video property values.\n    this.cache_ = {};\n\n    // Set poster\n    this.poster_ = options['poster'];\n    // Set controls\n    this.controls_ = options['controls'];\n    // Original tag settings stored in options\n    // now remove immediately so native controls don't flash.\n    // May be turned back on by HTML5 tech if nativeControlsForTouch is true\n    tag.controls = false;\n\n    // Run base component initializing with new options.\n    // Builds the element through createEl()\n    // Inits and embeds any child components in opts\n    vjs.Component.call(this, this, options, ready);\n\n    // Update controls className. Can't do this when the controls are initially\n    // set because the element doesn't exist yet.\n    if (this.controls()) {\n      this.addClass('vjs-controls-enabled');\n    } else {\n      this.addClass('vjs-controls-disabled');\n    }\n\n    // TODO: Make this smarter. Toggle user state between touching/mousing\n    // using events, since devices can have both touch and mouse events.\n    // if (vjs.TOUCH_ENABLED) {\n    //   this.addClass('vjs-touch-enabled');\n    // }\n\n    // Firstplay event implimentation. Not sold on the event yet.\n    // Could probably just check currentTime==0?\n    this.one('play', function(e){\n      var fpEvent = { type: 'firstplay', target: this.el_ };\n      // Using vjs.trigger so we can check if default was prevented\n      var keepGoing = vjs.trigger(this.el_, fpEvent);\n\n      if (!keepGoing) {\n        e.preventDefault();\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      }\n    });\n\n    this.on('ended', this.onEnded);\n    this.on('play', this.onPlay);\n    this.on('firstplay', this.onFirstPlay);\n    this.on('pause', this.onPause);\n    this.on('progress', this.onProgress);\n    this.on('durationchange', this.onDurationChange);\n    this.on('error', this.onError);\n    this.on('fullscreenchange', this.onFullscreenChange);\n\n    // Make player easily findable by ID\n    vjs.players[this.id_] = this;\n\n    if (options['plugins']) {\n      vjs.obj.each(options['plugins'], function(key, val){\n        this[key](val);\n      }, this);\n    }\n\n    this.listenForUserActivity();\n  }\n});\n\n/**\n * Player instance options, surfaced using vjs.options\n * vjs.options = vjs.Player.prototype.options_\n * Make changes in vjs.options, not here.\n * All options should use string keys so they avoid\n * renaming by closure compiler\n * @type {Object}\n * @private\n */\nvjs.Player.prototype.options_ = vjs.options;\n\nvjs.Player.prototype.dispose = function(){\n  this.trigger('dispose');\n  // prevent dispose from being called twice\n  this.off('dispose');\n\n  // Kill reference to this player\n  vjs.players[this.id_] = null;\n  if (this.tag && this.tag['player']) { this.tag['player'] = null; }\n  if (this.el_ && this.el_['player']) { this.el_['player'] = null; }\n\n  // Ensure that tracking progress and time progress will stop and plater deleted\n  this.stopTrackingProgress();\n  this.stopTrackingCurrentTime();\n\n  if (this.tech) { this.tech.dispose(); }\n\n  // Component dispose\n  vjs.Component.prototype.dispose.call(this);\n};\n\nvjs.Player.prototype.getTagSettings = function(tag){\n  var options = {\n    'sources': [],\n    'tracks': []\n  };\n\n  vjs.obj.merge(options, vjs.getAttributeValues(tag));\n\n  // Get tag children settings\n  if (tag.hasChildNodes()) {\n    var children, child, childName, i, j;\n\n    children = tag.childNodes;\n\n    for (i=0,j=children.length; i<j; i++) {\n      child = children[i];\n      // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\n      childName = child.nodeName.toLowerCase();\n      if (childName === 'source') {\n        options['sources'].push(vjs.getAttributeValues(child));\n      } else if (childName === 'track') {\n        options['tracks'].push(vjs.getAttributeValues(child));\n      }\n    }\n  }\n\n  return options;\n};\n\nvjs.Player.prototype.createEl = function(){\n  var el = this.el_ = vjs.Component.prototype.createEl.call(this, 'div');\n  var tag = this.tag;\n\n  // Remove width/height attrs from tag so CSS can make it 100% width/height\n  tag.removeAttribute('width');\n  tag.removeAttribute('height');\n  // Empty video tag sources and tracks so the built-in player doesn't use them also.\n  // This may not be fast enough to stop HTML5 browsers from reading the tags\n  // so we'll need to turn off any default tracks if we're manually doing\n  // captions and subtitles. videoElement.textTracks\n  if (tag.hasChildNodes()) {\n    var nodes, nodesLength, i, node, nodeName, removeNodes;\n\n    nodes = tag.childNodes;\n    nodesLength = nodes.length;\n    removeNodes = [];\n\n    while (nodesLength--) {\n      node = nodes[nodesLength];\n      nodeName = node.nodeName.toLowerCase();\n      if (nodeName === 'source' || nodeName === 'track') {\n        removeNodes.push(node);\n      }\n    }\n\n    for (i=0; i<removeNodes.length; i++) {\n      tag.removeChild(removeNodes[i]);\n    }\n  }\n\n  // Make sure tag ID exists\n  tag.id = tag.id || 'vjs_video_' + vjs.guid++;\n\n  // Give video tag ID and class to player div\n  // ID will now reference player box, not the video tag\n  el.id = tag.id;\n  el.className = tag.className;\n\n  // Update tag id/class for use as HTML5 playback tech\n  // Might think we should do this after embedding in container so .vjs-tech class\n  // doesn't flash 100% width/height, but class only applies with .video-js parent\n  tag.id += '_html5_api';\n  tag.className = 'vjs-tech';\n\n  // Make player findable on elements\n  tag['player'] = el['player'] = this;\n  // Default state of video is paused\n  this.addClass('vjs-paused');\n\n  // Make box use width/height of tag, or rely on default implementation\n  // Enforce with CSS since width/height attrs don't work on divs\n  this.width(this.options_['width'], true); // (true) Skip resize listener on load\n  this.height(this.options_['height'], true);\n\n  // Wrap video tag in div (el/box) container\n  if (tag.parentNode) {\n    tag.parentNode.insertBefore(el, tag);\n  }\n  vjs.insertFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.\n\n  return el;\n};\n\n// /* Media Technology (tech)\n// ================================================================================ */\n// Load/Create an instance of playback technlogy including element and API methods\n// And append playback element in player div.\nvjs.Player.prototype.loadTech = function(techName, source){\n\n  // Pause and remove current playback technology\n  if (this.tech) {\n    this.unloadTech();\n\n  // If the first time loading, HTML5 tag will exist but won't be initialized\n  // So we need to remove it if we're not loading HTML5\n  } else if (techName !== 'Html5' && this.tag) {\n    this.el_.removeChild(this.tag);\n    this.tag['player'] = null;\n    this.tag = null;\n  }\n\n  this.techName = techName;\n\n  // Turn off API access because we're loading a new tech that might load asynchronously\n  this.isReady_ = false;\n\n  var techReady = function(){\n    // removed this because it caused the progression to not go up for some reason...\n    //this.player_.triggerReady();\n\n    // Manually track progress in cases where the browser/flash player doesn't report it.\n    if (!this.features['progressEvents']) {\n      this.player_.manualProgressOn();\n    }\n\n    // Manually track timeudpates in cases where the browser/flash player doesn't report it.\n    if (!this.features['timeupdateEvents']) {\n      this.player_.manualTimeUpdatesOn();\n    }\n  };\n\n  // Grab tech-specific options from player options and add source and parent element to use.\n  var techOptions = vjs.obj.merge({ 'source': source, 'parentEl': this.el_ }, this.options_[techName.toLowerCase()]);\n\n  if (source) {\n    if (source.src == this.cache_.src && this.cache_.currentTime > 0) {\n      techOptions['startTime'] = this.cache_.currentTime;\n    }\n\n    this.cache_.src = source.src;\n  }\n\n  // Initialize tech instance\n  this.tech = new __webpack_provided_window_dot_videojs[techName](this, techOptions);\n\n  this.tech.ready(techReady);\n};\n\nvjs.Player.prototype.unloadTech = function(){\n  this.isReady_ = false;\n  this.tech.dispose();\n\n  // Turn off any manual progress or timeupdate tracking\n  if (this.manualProgress) { this.manualProgressOff(); }\n\n  if (this.manualTimeUpdates) { this.manualTimeUpdatesOff(); }\n\n  this.tech = false;\n};\n\n// There's many issues around changing the size of a Flash (or other plugin) object.\n// First is a plugin reload issue in Firefox that has been around for 11 years: https://bugzilla.mozilla.org/show_bug.cgi?id=90268\n// Then with the new fullscreen API, Mozilla and webkit browsers will reload the flash object after going to fullscreen.\n// To get around this, we're unloading the tech, caching source and currentTime values, and reloading the tech once the plugin is resized.\n// reloadTech: function(betweenFn){\n//   vjs.log('unloadingTech')\n//   this.unloadTech();\n//   vjs.log('unloadedTech')\n//   if (betweenFn) { betweenFn.call(); }\n//   vjs.log('LoadingTech')\n//   this.loadTech(this.techName, { src: this.cache_.src })\n//   vjs.log('loadedTech')\n// },\n\n/* Fallbacks for unsupported event types\n================================================================================ */\n// Manually trigger progress events based on changes to the buffered amount\n// Many flash players and older HTML5 browsers don't send progress or progress-like events\nvjs.Player.prototype.manualProgressOn = function(){\n  this.manualProgress = true;\n\n  // Trigger progress watching when a source begins loading\n  this.trackProgress();\n\n  // Watch for a native progress event call on the tech element\n  // In HTML5, some older versions don't support the progress event\n  // So we're assuming they don't, and turning off manual progress if they do.\n  // As opposed to doing user agent detection\n  this.tech.one('progress', function(){\n\n    // Update known progress support for this playback technology\n    this.features['progressEvents'] = true;\n\n    // Turn off manual progress tracking\n    this.player_.manualProgressOff();\n  });\n};\n\nvjs.Player.prototype.manualProgressOff = function(){\n  this.manualProgress = false;\n  this.stopTrackingProgress();\n};\n\nvjs.Player.prototype.trackProgress = function(){\n\n  this.progressInterval = setInterval(vjs.bind(this, function(){\n    // Don't trigger unless buffered amount is greater than last time\n    // log(this.cache_.bufferEnd, this.buffered().end(0), this.duration())\n    /* TODO: update for multiple buffered regions */\n    if (this.cache_.bufferEnd < this.buffered().end(0)) {\n      this.trigger('progress');\n    } else if (this.bufferedPercent() == 1) {\n      this.stopTrackingProgress();\n      this.trigger('progress'); // Last update\n    }\n  }), 500);\n};\nvjs.Player.prototype.stopTrackingProgress = function(){ clearInterval(this.progressInterval); };\n\n/* Time Tracking -------------------------------------------------------------- */\nvjs.Player.prototype.manualTimeUpdatesOn = function(){\n  this.manualTimeUpdates = true;\n\n  this.on('play', this.trackCurrentTime);\n  this.on('pause', this.stopTrackingCurrentTime);\n  // timeupdate is also called by .currentTime whenever current time is set\n\n  // Watch for native timeupdate event\n  this.tech.one('timeupdate', function(){\n    // Update known progress support for this playback technology\n    this.features['timeupdateEvents'] = true;\n    // Turn off manual progress tracking\n    this.player_.manualTimeUpdatesOff();\n  });\n};\n\nvjs.Player.prototype.manualTimeUpdatesOff = function(){\n  this.manualTimeUpdates = false;\n  this.stopTrackingCurrentTime();\n  this.off('play', this.trackCurrentTime);\n  this.off('pause', this.stopTrackingCurrentTime);\n};\n\nvjs.Player.prototype.trackCurrentTime = function(){\n  if (this.currentTimeInterval) { this.stopTrackingCurrentTime(); }\n  this.currentTimeInterval = setInterval(vjs.bind(this, function(){\n    this.trigger('timeupdate');\n  }), 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n};\n\n// Turn off play progress tracking (when paused or dragging)\nvjs.Player.prototype.stopTrackingCurrentTime = function(){ clearInterval(this.currentTimeInterval); };\n\n// /* Player event handlers (how the player reacts to certain events)\n// ================================================================================ */\nvjs.Player.prototype.onEnded = function(){\n  if (this.options_['loop']) {\n    this.currentTime(0);\n    this.play();\n  }\n};\n\nvjs.Player.prototype.onPlay = function(){\n  vjs.removeClass(this.el_, 'vjs-paused');\n  vjs.addClass(this.el_, 'vjs-playing');\n};\n\nvjs.Player.prototype.onFirstPlay = function(){\n    //If the first starttime attribute is specified\n    //then we will start at the given offset in seconds\n    if(this.options_['starttime']){\n      this.currentTime(this.options_['starttime']);\n    }\n\n    this.addClass('vjs-has-started');\n};\n\nvjs.Player.prototype.onPause = function(){\n  vjs.removeClass(this.el_, 'vjs-playing');\n  vjs.addClass(this.el_, 'vjs-paused');\n};\n\nvjs.Player.prototype.onProgress = function(){\n  // Add custom event for when source is finished downloading.\n  if (this.bufferedPercent() == 1) {\n    this.trigger('loadedalldata');\n  }\n};\n\n// Update duration with durationchange event\n// Allows for cacheing value instead of asking player each time.\nvjs.Player.prototype.onDurationChange = function(){\n  this.duration(this.techGet('duration'));\n};\n\nvjs.Player.prototype.onError = function(e) {\n  vjs.log('Video Error', e);\n};\n\nvjs.Player.prototype.onFullscreenChange = function() {\n  if (this.isFullScreen) {\n    this.addClass('vjs-fullscreen');\n  } else {\n    this.removeClass('vjs-fullscreen');\n  }\n};\n\n// /* Player API\n// ================================================================================ */\n\n/**\n * Object for cached values.\n * @private\n */\nvjs.Player.prototype.cache_;\n\nvjs.Player.prototype.getCache = function(){\n  return this.cache_;\n};\n\n// Pass values to the playback tech\nvjs.Player.prototype.techCall = function(method, arg){\n  // If it's not ready yet, call method when it is\n  if (this.tech && !this.tech.isReady_) {\n    this.tech.ready(function(){\n      this[method](arg);\n    });\n\n  // Otherwise call method now\n  } else {\n    try {\n      this.tech[method](arg);\n    } catch(e) {\n      vjs.log(e);\n      throw e;\n    }\n  }\n};\n\n// Get calls can't wait for the tech, and sometimes don't need to.\nvjs.Player.prototype.techGet = function(method){\n\n  if (this.tech && this.tech.isReady_) {\n\n    // Flash likes to die and reload when you hide or reposition it.\n    // In these cases the object methods go away and we get errors.\n    // When that happens we'll catch the errors and inform tech that it's not ready any more.\n    try {\n      return this.tech[method]();\n    } catch(e) {\n      // When building additional tech libs, an expected method may not be defined yet\n      if (this.tech[method] === undefined) {\n        vjs.log('Video.js: ' + method + ' method not defined for '+this.techName+' playback technology.', e);\n      } else {\n        // When a method isn't available on the object it throws a TypeError\n        if (e.name == 'TypeError') {\n          vjs.log('Video.js: ' + method + ' unavailable on '+this.techName+' playback technology element.', e);\n          this.tech.isReady_ = false;\n        } else {\n          vjs.log(e);\n        }\n      }\n      throw e;\n    }\n  }\n\n  return;\n};\n\n/**\n * Start media playback\n * http://dev.w3.org/html5/spec/video.html#dom-media-play\n * We're triggering the 'play' event here instead of relying on the\n * media element to allow using event.preventDefault() to stop\n * play from happening if desired. Usecase: preroll ads.\n */\nvjs.Player.prototype.play = function(){\n  this.techCall('play');\n  return this;\n};\n\n// http://dev.w3.org/html5/spec/video.html#dom-media-pause\nvjs.Player.prototype.pause = function(){\n  this.techCall('pause');\n  return this;\n};\n\n// http://dev.w3.org/html5/spec/video.html#dom-media-paused\n// The initial state of paused should be true (in Safari it's actually false)\nvjs.Player.prototype.paused = function(){\n  return (this.techGet('paused') === false) ? false : true;\n};\n\n// http://dev.w3.org/html5/spec/video.html#dom-media-currenttime\nvjs.Player.prototype.currentTime = function(seconds){\n  if (seconds !== undefined) {\n\n    // Cache the last set value for smoother scrubbing.\n    this.cache_.lastSetCurrentTime = seconds;\n\n    this.techCall('setCurrentTime', seconds);\n\n    // Improve the accuracy of manual timeupdates\n    if (this.manualTimeUpdates) { this.trigger('timeupdate'); }\n\n    return this;\n  }\n\n  // Cache last currentTime and return\n  // Default to 0 seconds\n  return this.cache_.currentTime = (this.techGet('currentTime') || 0);\n};\n\n// http://dev.w3.org/html5/spec/video.html#dom-media-duration\n// Duration should return NaN if not available. ParseFloat will turn false-ish values to NaN.\nvjs.Player.prototype.duration = function(seconds){\n  if (seconds !== undefined) {\n\n    // Cache the last set value for optimiized scrubbing (esp. Flash)\n    this.cache_.duration = parseFloat(seconds);\n\n    return this;\n  }\n\n  return this.cache_.duration;\n};\n\n// Calculates how much time is left. Not in spec, but useful.\nvjs.Player.prototype.remainingTime = function(){\n  return this.duration() - this.currentTime();\n};\n\n// http://dev.w3.org/html5/spec/video.html#dom-media-buffered\n// Buffered returns a timerange object.\n// Kind of like an array of portions of the video that have been downloaded.\n// So far no browsers return more than one range (portion)\nvjs.Player.prototype.buffered = function(){\n  var buffered = this.techGet('buffered'),\n      start = 0,\n      buflast = buffered.length - 1,\n      // Default end to 0 and store in values\n      end = this.cache_.bufferEnd = this.cache_.bufferEnd || 0;\n\n  if (buffered && buflast >= 0 && buffered.end(buflast) !== end) {\n    end = buffered.end(buflast);\n    // Storing values allows them be overridden by setBufferedFromProgress\n    this.cache_.bufferEnd = end;\n  }\n\n  return vjs.createTimeRange(start, end);\n};\n\n// Calculates amount of buffer is full. Not in spec but useful.\nvjs.Player.prototype.bufferedPercent = function(){\n  return (this.duration()) ? this.buffered().end(0) / this.duration() : 0;\n};\n\n// http://dev.w3.org/html5/spec/video.html#dom-media-volume\nvjs.Player.prototype.volume = function(percentAsDecimal){\n  var vol;\n\n  if (percentAsDecimal !== undefined) {\n    vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1\n    this.cache_.volume = vol;\n    this.techCall('setVolume', vol);\n    vjs.setLocalStorage('volume', vol);\n    return this;\n  }\n\n  // Default to 1 when returning current volume.\n  vol = parseFloat(this.techGet('volume'));\n  return (isNaN(vol)) ? 1 : vol;\n};\n\n// http://dev.w3.org/html5/spec/video.html#attr-media-muted\nvjs.Player.prototype.muted = function(muted){\n  if (muted !== undefined) {\n    this.techCall('setMuted', muted);\n    return this;\n  }\n  return this.techGet('muted') || false; // Default to false\n};\n\n// Check if current tech can support native fullscreen (e.g. with built in controls lik iOS, so not our flash swf)\nvjs.Player.prototype.supportsFullScreen = function(){ return this.techGet('supportsFullScreen') || false; };\n\n// Turn on fullscreen (or window) mode\nvjs.Player.prototype.requestFullScreen = function(){\n  var requestFullScreen = vjs.support.requestFullScreen;\n  this.isFullScreen = true;\n\n  if (requestFullScreen) {\n    // the browser supports going fullscreen at the element level so we can\n    // take the controls fullscreen as well as the video\n\n    // Trigger fullscreenchange event after change\n    // We have to specifically add this each time, and remove\n    // when cancelling fullscreen. Otherwise if there's multiple\n    // players on a page, they would all be reacting to the same fullscreen\n    // events\n    vjs.on(document, requestFullScreen.eventName, vjs.bind(this, function(e){\n      this.isFullScreen = document[requestFullScreen.isFullScreen];\n\n      // If cancelling fullscreen, remove event listener.\n      if (this.isFullScreen === false) {\n        vjs.off(document, requestFullScreen.eventName, arguments.callee);\n      }\n\n      this.trigger('fullscreenchange');\n    }));\n\n    this.el_[requestFullScreen.requestFn]();\n\n  } else if (this.tech.supportsFullScreen()) {\n    // we can't take the video.js controls fullscreen but we can go fullscreen\n    // with native controls\n    this.techCall('enterFullScreen');\n  } else {\n    // fullscreen isn't supported so we'll just stretch the video element to\n    // fill the viewport\n    this.enterFullWindow();\n    this.trigger('fullscreenchange');\n  }\n\n  return this;\n};\n\nvjs.Player.prototype.cancelFullScreen = function(){\n  var requestFullScreen = vjs.support.requestFullScreen;\n  this.isFullScreen = false;\n\n  // Check for browser element fullscreen support\n  if (requestFullScreen) {\n    document[requestFullScreen.cancelFn]();\n  } else if (this.tech.supportsFullScreen()) {\n   this.techCall('exitFullScreen');\n  } else {\n   this.exitFullWindow();\n   this.trigger('fullscreenchange');\n  }\n\n  return this;\n};\n\n// When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.\nvjs.Player.prototype.enterFullWindow = function(){\n  this.isFullWindow = true;\n\n  // Storing original doc overflow value to return to when fullscreen is off\n  this.docOrigOverflow = document.documentElement.style.overflow;\n\n  // Add listener for esc key to exit fullscreen\n  vjs.on(document, 'keydown', vjs.bind(this, this.fullWindowOnEscKey));\n\n  // Hide any scroll bars\n  document.documentElement.style.overflow = 'hidden';\n\n  // Apply fullscreen styles\n  vjs.addClass(document.body, 'vjs-full-window');\n\n  this.trigger('enterFullWindow');\n};\nvjs.Player.prototype.fullWindowOnEscKey = function(event){\n  if (event.keyCode === 27) {\n    if (this.isFullScreen === true) {\n      this.cancelFullScreen();\n    } else {\n      this.exitFullWindow();\n    }\n  }\n};\n\nvjs.Player.prototype.exitFullWindow = function(){\n  this.isFullWindow = false;\n  vjs.off(document, 'keydown', this.fullWindowOnEscKey);\n\n  // Unhide scroll bars.\n  document.documentElement.style.overflow = this.docOrigOverflow;\n\n  // Remove fullscreen styles\n  vjs.removeClass(document.body, 'vjs-full-window');\n\n  // Resize the box, controller, and poster to original sizes\n  // this.positionAll();\n  this.trigger('exitFullWindow');\n};\n\nvjs.Player.prototype.selectSource = function(sources){\n\n  // Loop through each playback technology in the options order\n  for (var i=0,j=this.options_['techOrder'];i<j.length;i++) {\n    var techName = vjs.capitalize(j[i]),\n        tech = __webpack_provided_window_dot_videojs[techName];\n\n    // Check if the browser supports this technology\n    if (tech.isSupported()) {\n      // Loop through each source object\n      for (var a=0,b=sources;a<b.length;a++) {\n        var source = b[a];\n\n        // Check if source can be played with this technology\n        if (tech['canPlaySource'](source)) {\n          return { source: source, tech: techName };\n        }\n      }\n    }\n  }\n\n  return false;\n};\n\n// src is a pretty powerful function\n// If you pass it an array of source objects, it will find the best source to play and use that object.src\n//   If the new source requires a new playback technology, it will switch to that.\n// If you pass it an object, it will set the source to object.src\n// If you pass it anything else (url string) it will set the video source to that\nvjs.Player.prototype.src = function(source){\n  // Case: Array of source objects to choose from and pick the best to play\n  if (source instanceof Array) {\n\n    var sourceTech = this.selectSource(source),\n        techName;\n\n    if (sourceTech) {\n        source = sourceTech.source;\n        techName = sourceTech.tech;\n\n      // If this technology is already loaded, set source\n      if (techName == this.techName) {\n        this.src(source); // Passing the source object\n      // Otherwise load this technology with chosen source\n      } else {\n        this.loadTech(techName, source);\n      }\n    } else {\n      this.el_.appendChild(vjs.createEl('p', {\n        innerHTML: this.options()['notSupportedMessage']\n      }));\n    }\n\n  // Case: Source object { src: '', type: '' ... }\n  } else if (source instanceof Object) {\n\n    if (__webpack_provided_window_dot_videojs[this.techName]['canPlaySource'](source)) {\n      this.src(source.src);\n    } else {\n      // Send through tech loop to check for a compatible technology.\n      this.src([source]);\n    }\n\n  // Case: URL String (http://myvideo...)\n  } else {\n    // Cache for getting last set source\n    this.cache_.src = source;\n\n    if (!this.isReady_) {\n      this.ready(function(){\n        this.src(source);\n      });\n    } else {\n      this.techCall('src', source);\n      if (this.options_['preload'] == 'auto') {\n        this.load();\n      }\n      if (this.options_['autoplay']) {\n        this.play();\n      }\n    }\n  }\n  return this;\n};\n\n// Begin loading the src data\n// http://dev.w3.org/html5/spec/video.html#dom-media-load\nvjs.Player.prototype.load = function(){\n  this.techCall('load');\n  return this;\n};\n\n// http://dev.w3.org/html5/spec/video.html#dom-media-currentsrc\nvjs.Player.prototype.currentSrc = function(){\n  return this.techGet('currentSrc') || this.cache_.src || '';\n};\n\n// Attributes/Options\nvjs.Player.prototype.preload = function(value){\n  if (value !== undefined) {\n    this.techCall('setPreload', value);\n    this.options_['preload'] = value;\n    return this;\n  }\n  return this.techGet('preload');\n};\nvjs.Player.prototype.autoplay = function(value){\n  if (value !== undefined) {\n    this.techCall('setAutoplay', value);\n    this.options_['autoplay'] = value;\n    return this;\n  }\n  return this.techGet('autoplay', value);\n};\nvjs.Player.prototype.loop = function(value){\n  if (value !== undefined) {\n    this.techCall('setLoop', value);\n    this.options_['loop'] = value;\n    return this;\n  }\n  return this.techGet('loop');\n};\n\n/**\n * The url of the poster image source.\n * @type {String}\n * @private\n */\nvjs.Player.prototype.poster_;\n\n/**\n * Get or set the poster image source url.\n * @param  {String} src Poster image source URL\n * @return {String}    Poster image source URL or null\n */\nvjs.Player.prototype.poster = function(src){\n  if (src !== undefined) {\n    this.poster_ = src;\n  }\n  return this.poster_;\n};\n\n/**\n * Whether or not the controls are showing\n * @type {Boolean}\n * @private\n */\nvjs.Player.prototype.controls_;\n\n/**\n * Get or set whether or not the controls are showing.\n * @param  {Boolean} controls Set controls to showing or not\n * @return {Boolean}    Controls are showing\n */\nvjs.Player.prototype.controls = function(bool){\n  if (bool !== undefined) {\n    bool = !!bool; // force boolean\n    // Don't trigger a change event unless it actually changed\n    if (this.controls_ !== bool) {\n      this.controls_ = bool;\n      if (bool) {\n        this.removeClass('vjs-controls-disabled');\n        this.addClass('vjs-controls-enabled');\n        this.trigger('controlsenabled');\n      } else {\n        this.removeClass('vjs-controls-enabled');\n        this.addClass('vjs-controls-disabled');\n        this.trigger('controlsdisabled');\n      }\n    }\n    return this;\n  }\n  return this.controls_;\n};\n\nvjs.Player.prototype.usingNativeControls_;\n\n/**\n * Toggle native controls on/off. Native controls are the controls built into\n * devices (e.g. default iPhone controls), Flash, or other techs\n * (e.g. Vimeo Controls)\n *\n * **This should only be set by the current tech, because only the tech knows\n * if it can support native controls**\n *\n * @param  {Boolean} bool    True signals that native controls are on\n * @return {vjs.Player}      Returns the player\n */\nvjs.Player.prototype.usingNativeControls = function(bool){\n  if (bool !== undefined) {\n    bool = !!bool; // force boolean\n    // Don't trigger a change event unless it actually changed\n    if (this.usingNativeControls_ !== bool) {\n      this.usingNativeControls_ = bool;\n      if (bool) {\n        this.addClass('vjs-using-native-controls');\n        this.trigger('usingnativecontrols');\n      } else {\n        this.removeClass('vjs-using-native-controls');\n        this.trigger('usingcustomcontrols');\n      }\n    }\n    return this;\n  }\n  return this.usingNativeControls_;\n};\n\nvjs.Player.prototype.error = function(){ return this.techGet('error'); };\nvjs.Player.prototype.ended = function(){ return this.techGet('ended'); };\nvjs.Player.prototype.seeking = function(){ return this.techGet('seeking'); };\n\n// When the player is first initialized, trigger activity so components\n// like the control bar show themselves if needed\nvjs.Player.prototype.userActivity_ = true;\nvjs.Player.prototype.reportUserActivity = function(event){\n  this.userActivity_ = true;\n};\n\nvjs.Player.prototype.userActive_ = true;\nvjs.Player.prototype.userActive = function(bool){\n  if (bool !== undefined) {\n    bool = !!bool;\n    if (bool !== this.userActive_) {\n      this.userActive_ = bool;\n      if (bool) {\n        // If the user was inactive and is now active we want to reset the\n        // inactivity timer\n        this.userActivity_ = true;\n        this.removeClass('vjs-user-inactive');\n        this.addClass('vjs-user-active');\n        this.trigger('useractive');\n      } else {\n        // We're switching the state to inactive manually, so erase any other\n        // activity\n        this.userActivity_ = false;\n\n        // Chrome/Safari/IE have bugs where when you change the cursor it can\n        // trigger a mousemove event. This causes an issue when you're hiding\n        // the cursor when the user is inactive, and a mousemove signals user\n        // activity. Making it impossible to go into inactive mode. Specifically\n        // this happens in fullscreen when we really need to hide the cursor.\n        //\n        // When this gets resolved in ALL browsers it can be removed\n        // https://code.google.com/p/chromium/issues/detail?id=103041\n        this.tech.one('mousemove', function(e){\n          e.stopPropagation();\n          e.preventDefault();\n        });\n        this.removeClass('vjs-user-active');\n        this.addClass('vjs-user-inactive');\n        this.trigger('userinactive');\n      }\n    }\n    return this;\n  }\n  return this.userActive_;\n};\n\nvjs.Player.prototype.listenForUserActivity = function(){\n  var onMouseActivity, onMouseDown, mouseInProgress, onMouseUp,\n      activityCheck, inactivityTimeout;\n\n  onMouseActivity = this.reportUserActivity;\n\n  onMouseDown = function() {\n    onMouseActivity();\n    // For as long as the they are touching the device or have their mouse down,\n    // we consider them active even if they're not moving their finger or mouse.\n    // So we want to continue to update that they are active\n    clearInterval(mouseInProgress);\n    // Setting userActivity=true now and setting the interval to the same time\n    // as the activityCheck interval (250) should ensure we never miss the\n    // next activityCheck\n    mouseInProgress = setInterval(vjs.bind(this, onMouseActivity), 250);\n  };\n\n  onMouseUp = function(event) {\n    onMouseActivity();\n    // Stop the interval that maintains activity if the mouse/touch is down\n    clearInterval(mouseInProgress);\n  };\n\n  // Any mouse movement will be considered user activity\n  this.on('mousedown', onMouseDown);\n  this.on('mousemove', onMouseActivity);\n  this.on('mouseup', onMouseUp);\n\n  // Listen for keyboard navigation\n  // Shouldn't need to use inProgress interval because of key repeat\n  this.on('keydown', onMouseActivity);\n  this.on('keyup', onMouseActivity);\n\n  // Consider any touch events that bubble up to be activity\n  // Certain touches on the tech will be blocked from bubbling because they\n  // toggle controls\n  this.on('touchstart', onMouseDown);\n  this.on('touchmove', onMouseActivity);\n  this.on('touchend', onMouseUp);\n  this.on('touchcancel', onMouseUp);\n\n  // Run an interval every 250 milliseconds instead of stuffing everything into\n  // the mousemove/touchmove function itself, to prevent performance degradation.\n  // `this.reportUserActivity` simply sets this.userActivity_ to true, which\n  // then gets picked up by this loop\n  // http://ejohn.org/blog/learning-from-twitter/\n  activityCheck = setInterval(vjs.bind(this, function() {\n    // Check to see if mouse/touch activity has happened\n    if (this.userActivity_) {\n      // Reset the activity tracker\n      this.userActivity_ = false;\n\n      // If the user state was inactive, set the state to active\n      this.userActive(true);\n\n      // Clear any existing inactivity timeout to start the timer over\n      clearTimeout(inactivityTimeout);\n\n      // In X seconds, if no more activity has occurred the user will be\n      // considered inactive\n      inactivityTimeout = setTimeout(vjs.bind(this, function() {\n        // Protect against the case where the inactivityTimeout can trigger just\n        // before the next user activity is picked up by the activityCheck loop\n        // causing a flicker\n        if (!this.userActivity_) {\n          this.userActive(false);\n        }\n      }), 2000);\n    }\n  }), 250);\n\n  // Clean up the intervals when we kill the player\n  this.on('dispose', function(){\n    clearInterval(activityCheck);\n    clearTimeout(inactivityTimeout);\n  });\n};\n\nvjs.Player.prototype.playbackRate = function(rate) {\n  if (rate !== undefined) {\n    this.techCall('setPlaybackRate', rate);\n    return this;\n  }\n\n  if (this.tech && this.tech.features && this.tech.features['playbackRate']) {\n    return this.techGet('playbackRate');\n  } else {\n    return 1.0;\n  }\n\n};\n\n// Methods to add support for\n// networkState: function(){ return this.techCall('networkState'); },\n// readyState: function(){ return this.techCall('readyState'); },\n// seeking: function(){ return this.techCall('seeking'); },\n// initialTime: function(){ return this.techCall('initialTime'); },\n// startOffsetTime: function(){ return this.techCall('startOffsetTime'); },\n// played: function(){ return this.techCall('played'); },\n// seekable: function(){ return this.techCall('seekable'); },\n// videoTracks: function(){ return this.techCall('videoTracks'); },\n// audioTracks: function(){ return this.techCall('audioTracks'); },\n// videoWidth: function(){ return this.techCall('videoWidth'); },\n// videoHeight: function(){ return this.techCall('videoHeight'); },\n// defaultPlaybackRate: function(){ return this.techCall('defaultPlaybackRate'); },\n// playbackRate: function(){ return this.techCall('playbackRate'); },\n// mediaGroup: function(){ return this.techCall('mediaGroup'); },\n// controller: function(){ return this.techCall('controller'); },\n// defaultMuted: function(){ return this.techCall('defaultMuted'); }\n\n// TODO\n// currentSrcList: the array of sources including other formats and bitrates\n// playList: array of source lists in order of playback\n\n// RequestFullscreen API\n(function(){\n  var prefix, requestFS, div;\n\n  div = document.createElement('div');\n\n  requestFS = {};\n\n  // Current W3C Spec\n  // http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html#api\n  // Mozilla Draft: https://wiki.mozilla.org/Gecko:FullScreenAPI#fullscreenchange_event\n  // New: https://dvcs.w3.org/hg/fullscreen/raw-file/529a67b8d9f3/Overview.html\n  if (div.cancelFullscreen !== undefined) {\n    requestFS.requestFn = 'requestFullscreen';\n    requestFS.cancelFn = 'exitFullscreen';\n    requestFS.eventName = 'fullscreenchange';\n    requestFS.isFullScreen = 'fullScreen';\n\n  // Webkit (Chrome/Safari) and Mozilla (Firefox) have working implementations\n  // that use prefixes and vary slightly from the new W3C spec. Specifically,\n  // using 'exit' instead of 'cancel', and lowercasing the 'S' in Fullscreen.\n  // Other browsers don't have any hints of which version they might follow yet,\n  // so not going to try to predict by looping through all prefixes.\n  } else {\n\n    if (document.mozCancelFullScreen) {\n      prefix = 'moz';\n      requestFS.isFullScreen = prefix + 'FullScreen';\n    } else {\n      prefix = 'webkit';\n      requestFS.isFullScreen = prefix + 'IsFullScreen';\n    }\n\n    if (div[prefix + 'RequestFullScreen']) {\n      requestFS.requestFn = prefix + 'RequestFullScreen';\n      requestFS.cancelFn = prefix + 'CancelFullScreen';\n    }\n    requestFS.eventName = prefix + 'fullscreenchange';\n  }\n\n  if (document[requestFS.cancelFn]) {\n    vjs.support.requestFullScreen = requestFS;\n  }\n\n})();\n\n\n/**\n * Container of main controls\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.ControlBar = vjs.Component.extend();\n\nvjs.ControlBar.prototype.options_ = {\n  loadEvent: 'play',\n  children: {\n    'playToggle': {},\n    'currentTimeDisplay': {},\n    'timeDivider': {},\n    'durationDisplay': {},\n    'remainingTimeDisplay': {},\n    'progressControl': {},\n    'fullscreenToggle': {},\n    'volumeControl': {},\n    'muteToggle': {},\n    // 'volumeMenuButton': {}\n    'playbackRateMenuButton': {},\n    'transcriptToggle': {},\n    'downloadMenuButton': {},\n  }\n};\n\nvjs.ControlBar.prototype.createEl = function(){\n  return vjs.createEl('div', {\n    className: 'vjs-control-bar'\n  });\n};\n/**\n * Button to toggle between play and pause\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.PlayToggle = vjs.Button.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Button.call(this, player, options);\n\n    player.on('play', vjs.bind(this, this.onPlay));\n    player.on('pause', vjs.bind(this, this.onPause));\n  }\n});\n\nvjs.PlayToggle.prototype.buttonText = 'Play';\n\nvjs.PlayToggle.prototype.buildCSSClass = function(){\n  return 'vjs-play-control ' + vjs.Button.prototype.buildCSSClass.call(this);\n};\n\n  // OnClick - Toggle between play and pause\nvjs.PlayToggle.prototype.onClick = function(){\n  if (this.player_.paused()) {\n    this.player_.play();\n  } else {\n    this.player_.pause();\n  }\n};\n\n  // OnPlay - Add the vjs-playing class to the element so it can change appearance\nvjs.PlayToggle.prototype.onPlay = function(){\n  vjs.removeClass(this.el_, 'vjs-paused');\n  vjs.addClass(this.el_, 'vjs-playing');\n  this.el_.children[0].children[0].innerHTML = 'Pause'; // change the button text to \"Pause\"\n};\n\n  // OnPause - Add the vjs-paused class to the element so it can change appearance\nvjs.PlayToggle.prototype.onPause = function(){\n  vjs.removeClass(this.el_, 'vjs-playing');\n  vjs.addClass(this.el_, 'vjs-paused');\n  this.el_.children[0].children[0].innerHTML = 'Play'; // change the button text to \"Play\"\n};/**\n * Displays the current time\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.CurrentTimeDisplay = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n\n    player.on('timeupdate', vjs.bind(this, this.updateContent));\n  }\n});\n\nvjs.CurrentTimeDisplay.prototype.createEl = function(){\n  var el = vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-current-time vjs-time-controls vjs-control'\n  });\n\n  this.content = vjs.createEl('div', {\n    className: 'vjs-current-time-display',\n    innerHTML: '<span class=\"vjs-control-text\">Current Time </span>' + '0:00', // label the current time for screen reader users\n    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes\n  });\n\n  el.appendChild(vjs.createEl('div').appendChild(this.content));\n  return el;\n};\n\nvjs.CurrentTimeDisplay.prototype.updateContent = function(){\n  // Allows for smooth scrubbing, when player can't keep up.\n  var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();\n  this.content.innerHTML = '<span class=\"vjs-control-text\">Current Time </span>' + vjs.formatTime(time, this.player_.duration());\n};\n\n/**\n * Displays the duration\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.DurationDisplay = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n\n    player.on('timeupdate', vjs.bind(this, this.updateContent)); // this might need to be changes to 'durationchange' instead of 'timeupdate' eventually, however the durationchange event fires before this.player_.duration() is set, so the value cannot be written out using this method. Once the order of durationchange and this.player_.duration() being set is figured out, this can be updated.\n  }\n});\n\nvjs.DurationDisplay.prototype.createEl = function(){\n  var el = vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-duration vjs-time-controls vjs-control'\n  });\n\n  this.content = vjs.createEl('div', {\n    className: 'vjs-duration-display',\n    innerHTML: '<span class=\"vjs-control-text\">Duration Time </span>' + '0:00', // label the duration time for screen reader users\n    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes\n  });\n\n  el.appendChild(vjs.createEl('div').appendChild(this.content));\n  return el;\n};\n\nvjs.DurationDisplay.prototype.updateContent = function(){\n  var duration = this.player_.duration();\n  if (duration) {\n      this.content.innerHTML = '<span class=\"vjs-control-text\">Duration Time </span>' + vjs.formatTime(duration); // label the duration time for screen reader users\n  }\n};\n\n/**\n * Time Separator (Not used in main skin, but still available, and could be used as a 'spare element')\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.TimeDivider = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n  }\n});\n\nvjs.TimeDivider.prototype.createEl = function(){\n  return vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-time-divider',\n    innerHTML: '<div><span>/</span></div>'\n  });\n};\n\n/**\n * Displays the time left in the video\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.RemainingTimeDisplay = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n\n    player.on('timeupdate', vjs.bind(this, this.updateContent));\n  }\n});\n\nvjs.RemainingTimeDisplay.prototype.createEl = function(){\n  var el = vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-remaining-time vjs-time-controls vjs-control'\n  });\n\n  this.content = vjs.createEl('div', {\n    className: 'vjs-remaining-time-display',\n    innerHTML: '<span class=\"vjs-control-text\">Remaining Time </span>' + '-0:00', // label the remaining time for screen reader users\n    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes\n  });\n\n  el.appendChild(vjs.createEl('div').appendChild(this.content));\n  return el;\n};\n\nvjs.RemainingTimeDisplay.prototype.updateContent = function(){\n  if (this.player_.duration()) {\n    this.content.innerHTML = '<span class=\"vjs-control-text\">Remaining Time </span>' + '-'+ vjs.formatTime(this.player_.remainingTime());\n  }\n\n  // Allows for smooth scrubbing, when player can't keep up.\n  // var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();\n  // this.content.innerHTML = vjs.formatTime(time, this.player_.duration());\n};\n/**\n * Toggle fullscreen video\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.FullscreenToggle = vjs.Button.extend({\n  /** @constructor */\n  init: function(player, options){\n    //vjs.Button.call(this, player, options);\n  }\n});\n\nvjs.FullscreenToggle.prototype.buttonText = 'Fullscreen';\n\nvjs.FullscreenToggle.prototype.buildCSSClass = function(){\n  return 'vjs-fullscreen-control ' + vjs.Button.prototype.buildCSSClass.call(this);\n};\n\nvjs.FullscreenToggle.prototype.onClick = function(){\n  if (!this.player_.isFullScreen) {\n    this.player_.requestFullScreen();\n    this.el_.children[0].children[0].innerHTML = 'Non-Fullscreen'; // change the button text to \"Non-Fullscreen\"\n  } else {\n    this.player_.cancelFullScreen();\n    this.el_.children[0].children[0].innerHTML = 'Fullscreen'; // change the button to \"Fullscreen\"\n  }\n};/**\n * Seek, Load Progress, and Play Progress\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.ProgressControl = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n  }\n});\n\nvjs.ProgressControl.prototype.options_ = {\n  children: {\n    'seekBar': {}\n  }\n};\n\nvjs.ProgressControl.prototype.createEl = function(){\n  return vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-progress-control vjs-control'\n  });\n};\n\n/**\n * Seek Bar and holder for the progress bars\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.SeekBar = vjs.Slider.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Slider.call(this, player, options);\n    player.on('timeupdate', vjs.bind(this, this.updateARIAAttributes));\n    player.ready(vjs.bind(this, this.updateARIAAttributes));\n  }\n});\n\nvjs.SeekBar.prototype.options_ = {\n  children: {\n    'loadProgressBar': {},\n    'playProgressBar': {},\n    'seekHandle': {}\n  },\n  'barName': 'playProgressBar',\n  'handleName': 'seekHandle'\n};\n\nvjs.SeekBar.prototype.playerEvent = 'timeupdate';\n\nvjs.SeekBar.prototype.createEl = function(){\n  return vjs.Slider.prototype.createEl.call(this, 'div', {\n    className: 'vjs-progress-holder',\n    'aria-label': 'video progress bar'\n  });\n};\n\nvjs.SeekBar.prototype.updateARIAAttributes = function(){\n    // Allows for smooth scrubbing, when player can't keep up.\n    var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();\n    this.el_.setAttribute('aria-valuenow',vjs.round(this.getPercent()*100, 2)); // machine readable value of progress bar (percentage complete)\n    this.el_.setAttribute('aria-valuetext',vjs.formatTime(time, this.player_.duration())); // human readable value of progress bar (time complete)\n};\n\nvjs.SeekBar.prototype.getPercent = function(){\n  var currentTime;\n  // Flash RTMP provider will not report the correct time\n  // immediately after a seek. This isn't noticeable if you're\n  // seeking while the video is playing, but it is if you seek\n  // while the video is paused.\n  if (this.player_.techName === 'Flash' && this.player_.seeking()) {\n    var cache = this.player_.getCache();\n    if (cache.lastSetCurrentTime) {\n      currentTime = cache.lastSetCurrentTime;\n    }\n    else {\n      currentTime = this.player_.currentTime();\n    }\n  }\n  else {\n    currentTime = this.player_.currentTime();\n  }\n\n  return currentTime / this.player_.duration();\n};\n\nvjs.SeekBar.prototype.onMouseDown = function(event){\n  vjs.Slider.prototype.onMouseDown.call(this, event);\n\n  this.player_.scrubbing = true;\n\n  this.videoWasPlaying = !this.player_.paused();\n  this.player_.pause();\n};\n\nvjs.SeekBar.prototype.onMouseMove = function(event){\n  var newTime = this.calculateDistance(event) * this.player_.duration();\n\n  // Don't let video end while scrubbing.\n  if (newTime == this.player_.duration()) { newTime = newTime - 0.1; }\n\n  // Set new time (tell player to seek to new time)\n  this.player_.currentTime(newTime);\n};\n\nvjs.SeekBar.prototype.onMouseUp = function(event){\n  vjs.Slider.prototype.onMouseUp.call(this, event);\n\n  this.player_.scrubbing = false;\n  if (this.videoWasPlaying) {\n    this.player_.play();\n  }\n};\n\nvjs.SeekBar.prototype.stepForward = function(){\n  this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users\n};\n\nvjs.SeekBar.prototype.stepBack = function(){\n  this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users\n};\n\n\n/**\n * Shows load progres\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.LoadProgressBar = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n    player.on('progress', vjs.bind(this, this.update));\n  }\n});\n\nvjs.LoadProgressBar.prototype.createEl = function(){\n  return vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-load-progress',\n    innerHTML: '<span class=\"vjs-control-text\">Loaded: 0%</span>'\n  });\n};\n\nvjs.LoadProgressBar.prototype.update = function(){\n  if (this.el_.style) { this.el_.style.width = vjs.round(this.player_.bufferedPercent() * 100, 2) + '%'; }\n};\n\n\n/**\n * Shows play progress\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.PlayProgressBar = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n  }\n});\n\nvjs.PlayProgressBar.prototype.createEl = function(){\n  return vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-play-progress',\n    innerHTML: '<span class=\"vjs-control-text\">Progress: 0%</span>'\n  });\n};\n\n/**\n * SeekBar component includes play progress bar, and seek handle\n * Needed so it can determine seek position based on handle position/size\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.SeekHandle = vjs.SliderHandle.extend();\n\n/** @inheritDoc */\nvjs.SeekHandle.prototype.defaultValue = '00:00';\n\n/** @inheritDoc */\nvjs.SeekHandle.prototype.createEl = function(){\n  return vjs.SliderHandle.prototype.createEl.call(this, 'div', {\n    className: 'vjs-seek-handle'\n  });\n};/**\n * Control the volume\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.VolumeControl = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n\n    // hide volume controls when they're not supported by the current tech\n    if (player.tech && player.tech.features && player.tech.features['volumeControl'] === false) {\n      this.addClass('vjs-hidden');\n    }\n    player.on('loadstart', vjs.bind(this, function(){\n      if (player.tech.features && player.tech.features['volumeControl'] === false) {\n        this.addClass('vjs-hidden');\n      } else {\n        this.removeClass('vjs-hidden');\n      }\n    }));\n  }\n});\n\nvjs.VolumeControl.prototype.options_ = {\n  children: {\n    'volumeBar': {}\n  }\n};\n\nvjs.VolumeControl.prototype.createEl = function(){\n  return vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-volume-control vjs-control'\n  });\n};\n\n/**\n * Contains volume level\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.VolumeBar = vjs.Slider.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Slider.call(this, player, options);\n    player.on('volumechange', vjs.bind(this, this.updateARIAAttributes));\n    player.ready(vjs.bind(this, this.updateARIAAttributes));\n    setTimeout(vjs.bind(this, this.update), 0); // update when elements is in DOM\n  }\n});\n\nvjs.VolumeBar.prototype.updateARIAAttributes = function(){\n  // Current value of volume bar as a percentage\n  this.el_.setAttribute('aria-valuenow',vjs.round(this.player_.volume()*100, 2));\n  this.el_.setAttribute('aria-valuetext',vjs.round(this.player_.volume()*100, 2)+'%');\n};\n\nvjs.VolumeBar.prototype.options_ = {\n  children: {\n    'volumeLevel': {},\n    'volumeHandle': {}\n  },\n  'barName': 'volumeLevel',\n  'handleName': 'volumeHandle'\n};\n\nvjs.VolumeBar.prototype.playerEvent = 'volumechange';\n\nvjs.VolumeBar.prototype.createEl = function(){\n  return vjs.Slider.prototype.createEl.call(this, 'div', {\n    className: 'vjs-volume-bar',\n    'aria-label': 'volume level'\n  });\n};\n\nvjs.VolumeBar.prototype.onMouseMove = function(event) {\n  if (this.player_.muted()) {\n    this.player_.muted(false);\n  }\n\n  this.player_.volume(this.calculateDistance(event));\n};\n\nvjs.VolumeBar.prototype.getPercent = function(){\n  if (this.player_.muted()) {\n    return 0;\n  } else {\n    return this.player_.volume();\n  }\n};\n\nvjs.VolumeBar.prototype.stepForward = function(){\n  this.player_.volume(this.player_.volume() + 0.1);\n};\n\nvjs.VolumeBar.prototype.stepBack = function(){\n  this.player_.volume(this.player_.volume() - 0.1);\n};\n\n/**\n * Shows volume level\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.VolumeLevel = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n  }\n});\n\nvjs.VolumeLevel.prototype.createEl = function(){\n  return vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-volume-level',\n    innerHTML: '<span class=\"vjs-control-text\"></span>'\n  });\n};\n\n/**\n * Change volume level\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\n vjs.VolumeHandle = vjs.SliderHandle.extend();\n\n /** @inheritDoc */\n vjs.VolumeHandle.prototype.defaultValue = '00:00';\n\n /** @inheritDoc */\n vjs.VolumeHandle.prototype.createEl = function(){\n   return vjs.SliderHandle.prototype.createEl.call(this, 'div', {\n     className: 'vjs-volume-handle'\n   });\n };\n/**\n * Mute the audio\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.MuteToggle = vjs.Button.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Button.call(this, player, options);\n\n    player.on('volumechange', vjs.bind(this, this.update));\n\n    // hide mute toggle if the current tech doesn't support volume control\n    if (player.tech && player.tech.features && player.tech.features['volumeControl'] === false) {\n      this.addClass('vjs-hidden');\n    }\n    player.on('loadstart', vjs.bind(this, function(){\n      if (player.tech.features && player.tech.features['volumeControl'] === false) {\n        this.addClass('vjs-hidden');\n      } else {\n        this.removeClass('vjs-hidden');\n      }\n    }));\n  }\n});\n\nvjs.MuteToggle.prototype.createEl = function(){\n  return vjs.Button.prototype.createEl.call(this, 'div', {\n    className: 'vjs-mute-control vjs-control',\n    innerHTML: '<div><span class=\"vjs-control-text\">Mute</span></div>'\n  });\n};\n\nvjs.MuteToggle.prototype.onClick = function(){\n  this.player_.muted( this.player_.muted() ? false : true );\n};\n\nvjs.MuteToggle.prototype.update = function(){\n  var vol = this.player_.volume(),\n      level = 3;\n\n  if (vol === 0 || this.player_.muted()) {\n    level = 0;\n  } else if (vol < 0.33) {\n    level = 1;\n  } else if (vol < 0.67) {\n    level = 2;\n  }\n\n  // Don't rewrite the button text if the actual text doesn't change.\n  // This causes unnecessary and confusing information for screen reader users.\n  // This check is needed because this function gets called every time the volume level is changed.\n  if(this.player_.muted()){\n      if(this.el_.children[0].children[0].innerHTML!='Unmute'){\n          this.el_.children[0].children[0].innerHTML = 'Unmute'; // change the button text to \"Unmute\"\n      }\n  } else {\n      if(this.el_.children[0].children[0].innerHTML!='Mute'){\n          this.el_.children[0].children[0].innerHTML = 'Mute'; // change the button text to \"Mute\"\n      }\n  }\n\n  /* TODO improve muted icon classes */\n  for (var i = 0; i < 4; i++) {\n    vjs.removeClass(this.el_, 'vjs-vol-'+i);\n  }\n  vjs.addClass(this.el_, 'vjs-vol-'+level);\n};\n/**\n * Menu button with a popup for showing the volume slider.\n * @constructor\n */\nvjs.VolumeMenuButton = vjs.MenuButton.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.MenuButton.call(this, player, options);\n\n    // Same listeners as MuteToggle\n    player.on('volumechange', vjs.bind(this, this.update));\n\n    // hide mute toggle if the current tech doesn't support volume control\n    if (player.tech && player.tech.features && player.tech.features.volumeControl === false) {\n      this.addClass('vjs-hidden');\n    }\n    player.on('loadstart', vjs.bind(this, function(){\n      if (player.tech.features && player.tech.features.volumeControl === false) {\n        this.addClass('vjs-hidden');\n      } else {\n        this.removeClass('vjs-hidden');\n      }\n    }));\n    this.addClass('vjs-menu-button');\n  }\n});\n\nvjs.VolumeMenuButton.prototype.createMenu = function(){\n  var menu = new vjs.Menu(this.player_, {\n    contentElType: 'div'\n  });\n  var vc = new vjs.VolumeBar(this.player_, vjs.obj.merge({vertical: true}, this.options_.volumeBar));\n  menu.addChild(vc);\n  return menu;\n};\n\nvjs.VolumeMenuButton.prototype.onClick = function(){\n  vjs.MuteToggle.prototype.onClick.call(this);\n  vjs.MenuButton.prototype.onClick.call(this);\n};\n\nvjs.VolumeMenuButton.prototype.createEl = function(){\n  return vjs.Button.prototype.createEl.call(this, 'div', {\n    className: 'vjs-volume-menu-button vjs-menu-button vjs-control',\n    innerHTML: '<div><span class=\"vjs-control-text\">Mute</span></div>'\n  });\n};\nvjs.VolumeMenuButton.prototype.update = vjs.MuteToggle.prototype.update;\n\nvjs.PlaybackRateMenuButton = vjs.MenuButton.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.MenuButton.call(this, player, options);\n\n    this.updateVisibility();\n    this.updateLabel();\n\n    player.on('loadstart', vjs.bind(this, this.updateVisibility));\n    player.on('ratechange', vjs.bind(this, this.updateLabel));\n  }\n});\n\nvjs.PlaybackRateMenuButton.prototype.createEl = function(){\n  var el = vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-playback-rate vjs-menu-button vjs-control',\n    innerHTML: '<div class=\"vjs-control-content\"><span class=\"vjs-control-text\">Playback Rate</span></div>'\n  });\n\n  this.labelEl_ = vjs.createEl('div', {\n    className: 'vjs-playback-rate-value',\n    innerHTML: 1.0\n  });\n\n  el.appendChild(this.labelEl_);\n\n  return el;\n};\n\n// Menu creation\nvjs.PlaybackRateMenuButton.prototype.createMenu = function(){\n  var menu = new vjs.Menu(this.player());\n  var rates = this.player().options()['playbackRates'];\n\n  if (rates) {\n    for (var i = rates.length - 1; i >= 0; i--) {\n      menu.addChild(\n        new vjs.PlaybackRateMenuItem(this.player(), { 'rate': rates[i] + 'x'})\n        );\n    };\n  }\n\n  return menu;\n};\n\nvjs.PlaybackRateMenuButton.prototype.updateARIAAttributes = function(){\n  // Current playback rate\n  this.el().setAttribute('aria-valuenow', this.player().playbackRate());\n};\n\nvjs.PlaybackRateMenuButton.prototype.onClick = function(){\n  // select next rate option\n  var currentRate = this.player().playbackRate();\n  var rates = this.player().options()['playbackRates'];\n  // this will select first one if the last one currently selected\n  var newRate = rates[0];\n  for (var i = 0; i <rates.length ; i++) {\n    if (rates[i] > currentRate) {\n      newRate = rates[i];\n      break;\n    }\n  };\n  this.player().playbackRate(newRate);\n  this.labelEl_.innerHTML = newRate + 'x';\n  if (typeof(jQuery.publish) === \"function\") {\n      jQuery.publish('speed_change', [newRate]);\n  }\n};\n\nvjs.PlaybackRateMenuButton.prototype.playbackRateSupported = function(){\n  return this.player().tech\n    && this.player().tech.features['playbackRate']\n    && this.player().options()['playbackRates']\n    && this.player().options()['playbackRates'].length > 0\n  ;\n};\n\n/**\n * Hide playback rate controls when they're no playback rate options to select\n */\nvjs.PlaybackRateMenuButton.prototype.updateVisibility = function(){\n  if (this.playbackRateSupported()) {\n    this.removeClass('vjs-hidden');\n  } else {\n    this.addClass('vjs-hidden');\n  }\n};\n\n/**\n * Update button label when rate changed\n */\nvjs.PlaybackRateMenuButton.prototype.updateLabel = function(){\n  if (this.playbackRateSupported()) {\n    this.labelEl_.innerHTML = this.player().playbackRate() + 'x';\n  }\n};\n\n/**\n * The specific menu item type for selecting a playback rate\n *\n * @constructor\n */\nvjs.PlaybackRateMenuItem = vjs.MenuItem.extend({\n  contentElType: 'button',\n  /** @constructor */\n  init: function(player, options){\n    var label = this.label = options['rate'];\n    var rate = this.rate = parseFloat(label, 10);\n\n    // Modify options for parent MenuItem class's init.\n    options['label'] = label;\n    options['selected'] = rate === 1;\n    vjs.MenuItem.call(this, player, options);\n\n    this.player().on('ratechange', vjs.bind(this, this.update));\n  }\n});\n\nvjs.PlaybackRateMenuItem.prototype.onClick = function(){\n  vjs.MenuItem.prototype.onClick.call(this);\n  this.player().playbackRate(this.rate);\n  this.player().controlBar.playbackRateMenuButton.labelEl_.innerHTML = this.rate + \"x\";\n  if (typeof(jQuery.publish) === \"function\") {\n      jQuery.publish('speed_change', [this.rate]);\n  }\n};\n\nvjs.PlaybackRateMenuItem.prototype.update = function(){\n  this.selected(this.player().playbackRate() == this.rate);\n};\n\nvjs.TranscriptToggle = vjs.Button.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Button.call(this, player, options);\n  }\n});\n\nvjs.TranscriptToggle.prototype.buttonText = 'Transcript';\n\nvjs.TranscriptToggle.prototype.buildCSSClass = function(){\n  return 'vjs-transcript-control ' + vjs.Button.prototype.buildCSSClass.call(this);\n};\n\nvjs.TranscriptToggle.prototype.onClick = function(){\n  if (jQuery('#transcript').is(\":hidden\")){\n    jQuery(\"#transcript\").show();\n    jQuery('#viewer').css('height', '80%');\n    translate_editor = (jQuery(window).height() - (jQuery('#viewer').height() + 50)) * -1;\n    //AController.annotationCore.annotation_tool.editor.element.css('transform', 'translateY('+translate_editor+'px)');\n  } else {\n    jQuery('#transcript').hide(10, function(){\n      jQuery('#viewer').css('height', '100%');\n      //AController.annotationCore.annotation_tool.editor.element.css('transform', 'translateY(0px)');\n    });\n  }\n  \n};\n\nvjs.DownloadMenuButton = vjs.MenuButton.extend({\n  init: function(player, options) {\n\n    var downloads = player.options()['downloadItems'];\n    if (downloads.length > 0){\n      vjs.MenuButton.call(this, player, options);\n    } \n  }\n});\n\nvjs.DownloadMenuButton.prototype.createEl = function(){\n  var el = vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-download-control vjs-control vjs-menu-button',\n    innerHTML: '<div class=\"vjs-control-content\"><span class=\"vjs-control-text\">Download Video/Transcript</span></div>',\n  });\n  \n  return el;\n};\n\nvjs.DownloadMenuButton.prototype.createMenu = function (){\n  var menu = new vjs.Menu(this.player());\n  var downloads = this.player().options()['downloadItems'];\n  var self = this;\n\n  if (downloads) {\n\n    for (var i = downloads.length - 1; i >= 0; i--) {\n      if (downloads[i] === 'video') {\n        jQuery.each(this.player().options_.sources, function(index, value) {\n          if (value.type === \"video/mp4\") {\n            menu.addChild(\n              new vjs.DownloadMenuItem(self.player(), {'downloadItem': 'Download Video', 'source': value.src})\n            );\n          }\n        });\n      };\n      if (downloads[i] === 'transcript') {\n        jQuery.each(this.player().options_.tracks, function(index, value) {\n          console.log(value);\n            menu.addChild(\n              new vjs.DownloadMenuItem(self.player(), {'downloadItem': 'Download ' + value.label + ' Transcript', 'source': value.src})\n            );\n        });\n      };\n    };\n    \n  };\n\n  return menu;\n};\n\nvjs.DownloadMenuItem = vjs.MenuItem.extend({\n  contentElType: 'button',\n  init: function(player, options) {\n    var label = this.label = options['downloadItem'];\n    var src = this.src = options['source'];\n\n    options['label'] = label;\n    vjs.MenuItem.call(this, player, options);\n  }\n});\n\nvjs.DownloadMenuItem.prototype.onClick = function() {\n  vjs.MenuItem.prototype.onClick.call(this);\n  window.open(this.src);\n};\n/* Poster Image\n================================================================================ */\n/**\n * Poster image. Shows before the video plays.\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.PosterImage = vjs.Button.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Button.call(this, player, options);\n\n    if (!player.poster() || !player.controls()) {\n      this.hide();\n    }\n\n    player.on('play', vjs.bind(this, this.hide));\n  }\n});\n\nvjs.PosterImage.prototype.createEl = function(){\n  var el = vjs.createEl('div', {\n        className: 'vjs-poster',\n\n        // Don't want poster to be tabbable.\n        tabIndex: -1\n      }),\n      poster = this.player_.poster();\n\n  if (poster) {\n    if ('backgroundSize' in el.style) {\n      el.style.backgroundImage = 'url(\"' + poster + '\")';\n    } else {\n      el.appendChild(vjs.createEl('img', { src: poster }));\n    }\n  }\n\n  return el;\n};\n\nvjs.PosterImage.prototype.onClick = function(){\n  // Only accept clicks when controls are enabled\n  if (this.player().controls()) {\n    if (typeof(jQuery.publish) === \"function\") {\n      jQuery.publish('video_play_button_clicked');\n    }\n    this.player_.play();\n  }\n};\n/* Loading Spinner\n================================================================================ */\n/**\n * Loading spinner for waiting events\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.LoadingSpinner = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n\n    player.on('canplay', vjs.bind(this, this.hide));\n    player.on('canplaythrough', vjs.bind(this, this.hide));\n    player.on('playing', vjs.bind(this, this.hide));\n    player.on('seeked', vjs.bind(this, this.hide));\n\n    player.on('seeking', vjs.bind(this, this.show));\n\n    // in some browsers seeking does not trigger the 'playing' event,\n    // so we also need to trap 'seeked' if we are going to set a\n    // 'seeking' event\n    player.on('seeked', vjs.bind(this, this.hide));\n\n    player.on('error', vjs.bind(this, this.show));\n\n    // Not showing spinner on stalled any more. Browsers may stall and then not trigger any events that would remove the spinner.\n    // Checked in Chrome 16 and Safari 5.1.2. http://help.videojs.com/discussions/problems/883-why-is-the-download-progress-showing\n    // player.on('stalled', vjs.bind(this, this.show));\n\n    player.on('waiting', vjs.bind(this, this.show));\n  }\n});\n\nvjs.LoadingSpinner.prototype.createEl = function(){\n  return vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-loading-spinner'\n  });\n};\n/* Big Play Button\n================================================================================ */\n/**\n * Initial play button. Shows before the video has played. The hiding of the\n * big play button is done via CSS and player states.\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.BigPlayButton = vjs.Button.extend();\n\nvjs.BigPlayButton.prototype.createEl = function(){\n  return vjs.Button.prototype.createEl.call(this, 'div', {\n    className: 'vjs-big-play-button',\n    innerHTML: '<span></span>',\n    'aria-label': 'play video'\n  });\n};\n\nvjs.BigPlayButton.prototype.onClick = function(){\n  if (typeof(jQuery.publish) === \"function\") {\n      jQuery.publish('video_play_button_clicked');\n    }\n  this.player_.play();\n};\n/**\n * @fileoverview Media Technology Controller - Base class for media playback\n * technology controllers like Flash and HTML5\n */\n\n/**\n * Base class for media (HTML5 Video, Flash) controllers\n * @param {vjs.Player|Object} player  Central player instance\n * @param {Object=} options Options object\n * @constructor\n */\nvjs.MediaTechController = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    vjs.Component.call(this, player, options, ready);\n\n    this.initControlsListeners();\n  }\n});\n\n/**\n * Set up click and touch listeners for the playback element\n * On desktops, a click on the video itself will toggle playback,\n * on a mobile device a click on the video toggles controls.\n * (toggling controls is done by toggling the user state between active and\n * inactive)\n *\n * A tap can signal that a user has become active, or has become inactive\n * e.g. a quick tap on an iPhone movie should reveal the controls. Another\n * quick tap should hide them again (signaling the user is in an inactive\n * viewing state)\n *\n * In addition to this, we still want the user to be considered inactive after\n * a few seconds of inactivity.\n *\n * Note: the only part of iOS interaction we can't mimic with this setup\n * is a touch and hold on the video element counting as activity in order to\n * keep the controls showing, but that shouldn't be an issue. A touch and hold on\n * any controls will still keep the user active\n */\nvjs.MediaTechController.prototype.initControlsListeners = function(){\n  var player, tech, activateControls, deactivateControls;\n\n  tech = this;\n  player = this.player();\n\n  var activateControls = function(){\n    if (player.controls() && !player.usingNativeControls()) {\n      tech.addControlsListeners();\n    }\n  };\n\n  deactivateControls = vjs.bind(tech, tech.removeControlsListeners);\n\n  // Set up event listeners once the tech is ready and has an element to apply\n  // listeners to\n  this.ready(activateControls);\n  player.on('controlsenabled', activateControls);\n  player.on('controlsdisabled', deactivateControls);\n};\n\nvjs.MediaTechController.prototype.addControlsListeners = function(){\n  var preventBubble, userWasActive;\n\n  // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do\n  // trigger mousedown/up.\n  // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object\n  // Any touch events are set to block the mousedown event from happening\n  this.on('mousedown', this.onClick);\n\n  // We need to block touch events on the video element from bubbling up,\n  // otherwise they'll signal activity prematurely. The specific use case is\n  // when the video is playing and the controls have faded out. In this case\n  // only a tap (fast touch) should toggle the user active state and turn the\n  // controls back on. A touch and move or touch and hold should not trigger\n  // the controls (per iOS as an example at least)\n  //\n  // We always want to stop propagation on touchstart because touchstart\n  // at the player level starts the touchInProgress interval. We can still\n  // report activity on the other events, but won't let them bubble for\n  // consistency. We don't want to bubble a touchend without a touchstart.\n  this.on('touchstart', function(event) {\n    // Stop the mouse events from also happening\n    event.preventDefault();\n    event.stopPropagation();\n    // Record if the user was active now so we don't have to keep polling it\n    userWasActive = this.player_.userActive();\n  });\n\n  preventBubble = function(event){\n    event.stopPropagation();\n    if (userWasActive) {\n      this.player_.reportUserActivity();\n    }\n  };\n\n  // Treat all touch events the same for consistency\n  this.on('touchmove', preventBubble);\n  this.on('touchleave', preventBubble);\n  this.on('touchcancel', preventBubble);\n  this.on('touchend', preventBubble);\n\n  // Turn on component tap events\n  this.emitTapEvents();\n\n  // The tap listener needs to come after the touchend listener because the tap\n  // listener cancels out any reportedUserActivity when setting userActive(false)\n  this.on('tap', this.onTap);\n};\n\n/**\n * Remove the listeners used for click and tap controls. This is needed for\n * toggling to controls disabled, where a tap/touch should do nothing.\n */\nvjs.MediaTechController.prototype.removeControlsListeners = function(){\n  // We don't want to just use `this.off()` because there might be other needed\n  // listeners added by techs that extend this.\n  this.off('tap');\n  this.off('touchstart');\n  this.off('touchmove');\n  this.off('touchleave');\n  this.off('touchcancel');\n  this.off('touchend');\n  this.off('click');\n  this.off('mousedown');\n};\n\n/**\n * Handle a click on the media element. By default will play/pause the media.\n */\nvjs.MediaTechController.prototype.onClick = function(event){\n  // We're using mousedown to detect clicks thanks to Flash, but mousedown\n  // will also be triggered with right-clicks, so we need to prevent that\n  if (event.button !== 0) return;\n\n  // When controls are disabled a click should not toggle playback because\n  // the click is considered a control\n  if (this.player().controls()) {\n    if (this.player().paused()) {\n      this.player().play();\n    } else {\n      this.player().pause();\n    }\n  }\n};\n\n/**\n * Handle a tap on the media element. By default it will toggle the user\n * activity state, which hides and shows the controls.\n */\n\nvjs.MediaTechController.prototype.onTap = function(){\n  this.player().userActive(!this.player().userActive());\n};\n\nvjs.MediaTechController.prototype.features = {\n  'volumeControl': true,\n\n  // Resizing plugins using request fullscreen reloads the plugin\n  'fullscreenResize': false,\n  'playbackRate': true,\n\n  // Optional events that we can manually mimic with timers\n  // currently not triggered by video-js-swf\n  'progressEvents': false,\n  'timeupdateEvents': false,\n};\n\nvjs.media = {};\n\n/**\n * List of default API methods for any MediaTechController\n * @type {String}\n */\nvjs.media.ApiMethods = 'play,pause,paused,currentTime,setCurrentTime,duration,buffered,volume,setVolume,muted,setMuted,width,height,supportsFullScreen,enterFullScreen,src,load,currentSrc,preload,setPreload,autoplay,setAutoplay,loop,setLoop,error,networkState,readyState,seeking,initialTime,startOffsetTime,played,seekable,ended,videoTracks,audioTracks,videoWidth,videoHeight,textTracks,defaultPlaybackRate,playbackRate,mediaGroup,controller,controls,defaultMuted'.split(',');\n// Create placeholder methods for each that warn when a method isn't supported by the current playback technology\n\nfunction createMethod(methodName){\n  return function(){\n    throw new Error('The \"'+methodName+'\" method is not available on the playback technology\\'s API');\n  };\n}\n\nfor (var i = vjs.media.ApiMethods.length - 1; i >= 0; i--) {\n  var methodName = vjs.media.ApiMethods[i];\n  vjs.MediaTechController.prototype[vjs.media.ApiMethods[i]] = createMethod(methodName);\n}\n\n/**\n * @fileoverview YouTube Media Controller - Wrapper for YouTube Media API\n */\n\n/**\n * YouTube Media Controller - Wrapper for YouTube Media API\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @param {Function=} ready\n * @constructor\n */\nvjs.Youtube = vjs.MediaTechController.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    vjs.MediaTechController.call(this, player, options, ready);\n    \n    // No event is triggering this for YouTube\n    this.features['progressEvents'] = false;\n    this.features['timeupdateEvents'] = false;\n\n    // Copy the JavaScript options if they exists\n    if (typeof options['source'] != 'undefined') {\n      for (var key in options['source']) {\n        player.options()[key] = options['source'][key];\n      }\n    }\n\n    this.userQuality = vjs.Youtube.convertQualityName(player.options()['quality']);\n\n    // Save those for internal usage\n    this.player_ = player;\n    this.player_el_ = document.getElementById(player.id());\n    this.player_el_.className += ' vjs-youtube';\n\n    // Mobile devices are using their own native players\n    if (!!navigator.userAgent.match(/iPhone/i) || !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPod/i) || !!navigator.userAgent.match(/Android.*AppleWebKit/i)) {\n      player.options()['ytcontrols'] = true;\n    }\n\n    // Create the Quality button\n    this.qualityButton = document.createElement('div');\n    this.qualityButton.setAttribute('class', 'vjs-quality-button vjs-menu-button vjs-control');\n    this.qualityButton.setAttribute('tabindex', 0);\n    \n    var qualityContent = document.createElement('div');\n    this.qualityButton.appendChild(qualityContent);\n    \n    this.qualityTitle = document.createElement('span');\n    qualityContent.appendChild(this.qualityTitle);\n    \n    var qualityMenu = document.createElement('div');\n    qualityMenu.setAttribute('class', 'vjs-menu');\n    this.qualityButton.appendChild(qualityMenu);\n    \n    this.qualityMenuContent = document.createElement('ul');\n    this.qualityMenuContent.setAttribute('class', 'vjs-menu-content');\n    qualityMenu.appendChild(this.qualityMenuContent);\n\n    this.id_ = this.player_.id() + '_youtube_api';\n\n    this.el_ = vjs.Component.prototype.createEl('iframe', {\n      id: this.id_,\n      className: 'vjs-tech',\n      scrolling: 'no',\n      marginWidth: 0,\n      marginHeight: 0,\n      frameBorder: 0,\n      title:'Youtube Video',\n      webkitAllowFullScreen: 'true',\n      mozallowfullscreen: 'true',\n      allowFullScreen: 'true'\n    });\n\n    // This makes sure the mousemove is not lost within the iframe\n    // Only way to make sure the control bar shows when we come back in the video player\n    this.iframeblocker = vjs.Component.prototype.createEl('div', {\n      className: 'iframeblocker'\n    });\n\n    // Make sure to not block the play or pause\n    var self = this;\n    var toggleThis = function() {\n      if (self.paused()) {\n        self.play();\n      } else {\n        self.pause();\n      }\n    };\n\n    this.iframeblocker.addEventListener('click', toggleThis);\n    this.iframeblocker.addEventListener('mousemove', function(e) {\n      if (!self.player_.userActive()) {\n        self.player_.userActive(true);\n      }\n      \n      e.stopPropagation();\n      e.preventDefault();\n    });\n\n    if (!this.player_.options()['ytcontrols']) {\n      // Before the tech is ready, we have to take care of the play action\n      this.iframeblocker.style.display = 'block';\n    }\n\n    this.player_el_.insertBefore(this.iframeblocker, this.player_el_.firstChild);\n    this.player_el_.insertBefore(this.el_, this.iframeblocker);\n\n    this.parseSrc(player.options()['src']);\n\n    this.playOnReady = this.player_.options()['autoplay'] || false;\n\n    var params = {\n      enablejsapi: 1,\n      iv_load_policy: 3,\n      playerapiid: this.id(),\n      disablekb: 1,\n      wmode: 'transparent',\n      controls: (this.player_.options()['ytcontrols'])?1:0,\n      showinfo: 0,\n      modestbranding: 1,\n      rel: 0,\n      autoplay: (this.playOnReady)?1:0,\n      loop: (this.player_.options()['loop'])?1:0,\n      list: this.playlistId,\n      vq: this.userQuality\n    };\n\n    if (typeof params.list == 'undefined') {\n      delete params.list;\n    }\n\n    // If we are not on a server, don't specify the origin (it will crash)\n    if (window.location.protocol != 'file:'){\n      params.origin = window.location.protocol + '//' + window.location.host;\n      this.el_.src = window.location.protocol + '//www.youtube.com/embed/' + this.videoId + '?' + vjs.Youtube.makeQueryString(params);\n    } else {\n      this.el_.src = 'https://www.youtube.com/embed/' + this.videoId + '?' + vjs.Youtube.makeQueryString(params);\n    }\n\n    var self = this;\n    player.ready(function(){\n      var controlBar = self.player_el_.getElementsByClassName('vjs-control-bar')[0];\n      controlBar.appendChild(self.qualityButton);\n\n      if (self.playOnReady && !self.player_.options()['ytcontrols']) {\n        self.player_.loadingSpinner.show();\n        self.player_.bigPlayButton.hide();\n      }\n    });\n\n    if (this.player_.options()['ytcontrols']){\n      // Disable the video.js controls if we use the YouTube controls\n      this.player_.controls(false);\n    } else {\n      // Show the YouTube poster if their is no custom poster\n      if (!this.player_.poster()) {\n        if (this.videoId == null) {\n          // Set the black background if their is no video initially\n          this.iframeblocker.style.backgroundColor = 'black';\n        } else {\n          this.player_.poster('https://img.youtube.com/vi/' + this.videoId + '/maxresdefault.jpg');\n        }\n      }\n    }\n\n    if (vjs.Youtube.apiReady){\n      this.loadYoutube();\n    } else {\n      // Add to the queue because the YouTube API is not ready\n      vjs.Youtube.loadingQueue.push(this);\n\n      // Load the YouTube API if it is the first YouTube video\n      if(!vjs.Youtube.apiLoading){\n        var tag = document.createElement('script');\n        tag.src = '//www.youtube.com/iframe_api';\n        var firstScriptTag = document.getElementsByTagName('script')[0];\n        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n        vjs.Youtube.apiLoading = true;\n      }\n    }\n    \n    this.on('dispose', function() {\n      // Get rid of the created DOM elements\n      this.el_.parentNode.removeChild(this.el_);\n      this.iframeblocker.parentNode.removeChild(this.iframeblocker);\n      this.qualityButton.parentNode.removeChild(this.qualityButton);\n      \n      this.player_.loadingSpinner.hide();\n      this.player_.bigPlayButton.hide();\n    });\n  }\n});\n\nvjs.Youtube.prototype.parseSrc = function(src){\n  this.srcVal = src;\n  \n  if (src) {\n    // Regex to parse the video ID\n    var regId = /^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|\\&v=)([^#\\&\\?]*).*/;\n    var match = src.match(regId);\n    \n    if (match && match[2].length == 11){\n      this.videoId = match[2];\n    } else {\n      this.videoId = null;\n    }\n    \n    // Regex to parse the playlist ID\n    var regPlaylist = /[?&]list=([^#\\&\\?]+)/;\n    match = src.match(regPlaylist);\n    \n    if (match != null && match.length > 1) {\n      this.playlistId = match[1];\n    } else {\n      // Make sure their is no playlist\n      if (this.playlistId) {\n        delete this.playlistId;\n      }\n    }\n\n    // Parse video quality option\n    var regVideoQuality = /[?&]vq=([^#\\&\\?]+)/;\n    match = src.match(regVideoQuality);\n\n    if (match != null && match.length > 1) {\n      this.userQuality = match[1];\n    }\n  }\n};\n\nvjs.Youtube.prototype.src = function(src){\n  if (src) {\n    this.parseSrc(src);\n\n    if (this.videoId == null) {\n      // Set the black background if the URL isn't valid\n      this.iframeblocker.style.backgroundColor = 'black';\n      this.iframeblocker.style.display = 'block';\n    } else {\n      this.ytplayer.loadVideoById({\n        videoId: this.videoId,\n        suggestedQuality: this.userQuality\n      });\n\n      // Update the poster\n      this.player_el_.getElementsByClassName('vjs-poster')[0].style.backgroundImage = 'url(https://img.youtube.com/vi/' + this.videoId + '/maxresdefault.jpg)';\n      this.iframeblocker.style.backgroundColor = '';\n      this.iframeblocker.style.display = '';\n      this.player_.poster('https://img.youtube.com/vi/' + this.videoId + '/maxresdefault.jpg');\n    }\n  }\n\n  return this.srcVal;\n};\n\nvjs.Youtube.prototype.load = function(){};\n\nvjs.Youtube.prototype.play = function(){\n  if (this.videoId != null) {\n    // Make sure to not display the spinner for mobile\n    if (!this.player_.options()['ytcontrols']) {\n      // Display the spinner until the video is playing by YouTube\n      this.player_.trigger('waiting');\n    }\n    \n    if (this.isReady_){\n      this.ytplayer.playVideo();\n    } else {\n      this.playOnReady = true;\n    }\n  }\n};\n\nvjs.Youtube.prototype.pause = function(){ this.ytplayer.pauseVideo(); };\nvjs.Youtube.prototype.paused = function(){ return (this.ytplayer)?(this.lastState !== YT.PlayerState.PLAYING && this.lastState !== YT.PlayerState.BUFFERING):true; };\nvjs.Youtube.prototype.currentTime = function(){ return (this.ytplayer && this.ytplayer.getCurrentTime)?this.ytplayer.getCurrentTime():0; };\nvjs.Youtube.prototype.setCurrentTime = function(seconds){ this.ytplayer.seekTo(seconds, true); this.player_.trigger('timeupdate'); };\nvjs.Youtube.prototype.playbackRate = function(){ return this.ytplayer.getPlaybackRate();};\nvjs.Youtube.prototype.setPlaybackRate = function(rate) {this.ytplayer.setPlaybackRate(rate);};\nvjs.Youtube.prototype.duration = function(){ return (this.ytplayer && this.ytplayer.getDuration)?this.ytplayer.getDuration():0; };\n\nvjs.Youtube.prototype.volume = function() {\n  if (this.ytplayer && isNaN(this.volumeVal)) {\n    this.volumeVal = this.ytplayer.getVolume() / 100.0;\n  }\n\n  return this.volumeVal;\n};\n\nvjs.Youtube.prototype.setVolume = function(percentAsDecimal){\n  if (percentAsDecimal && percentAsDecimal != this.volumeVal) {\n    this.ytplayer.setVolume(percentAsDecimal * 100.0);\n    this.volumeVal = percentAsDecimal;\n    this.player_.trigger('volumechange');\n  }\n};\n\nvjs.Youtube.prototype.muted = function() { return this.mutedVal; };\nvjs.Youtube.prototype.setMuted = function(muted) {\n  if (muted) {\n    this.ytplayer.mute();\n  } else {\n    this.ytplayer.unMute();\n  }\n\n  this.mutedVal = muted;\n  this.player_.trigger('volumechange');\n};\n\nvjs.Youtube.prototype.buffered = function(){\n  if (this.ytplayer && this.ytplayer.getVideoBytesLoaded) {\n    var loadedBytes = this.ytplayer.getVideoBytesLoaded();\n    var totalBytes = this.ytplayer.getVideoBytesTotal();\n    if (!loadedBytes || !totalBytes) return 0;\n\n    var duration = this.ytplayer.getDuration();\n    var secondsBuffered = (loadedBytes / totalBytes) * duration;\n    var secondsOffset = (this.ytplayer.getVideoStartBytes() / totalBytes) * duration;\n\n    return vjs.createTimeRange(secondsOffset, secondsOffset + secondsBuffered);\n  } else {\n    return vjs.createTimeRange(0, 0);\n  }\n};\n\nvjs.Youtube.prototype.supportsFullScreen = function(){ return true; };\n\n// YouTube is supported on all platforms\nvjs.Youtube.isSupported = function(){ return true; };\n\n// You can use video/youtube as a media in your HTML5 video to specify the source\nvjs.Youtube.canPlaySource = function(srcObj){\n  return (srcObj.type == 'video/youtube');\n};\n\n// Always can control the volume\nvjs.Youtube.canControlVolume = function(){ return true; };\n\n////////////////////////////// YouTube specific functions //////////////////////////////\n\n// All videos created before YouTube API is loaded\nvjs.Youtube.loadingQueue = [];\n\n// Create the YouTube player\nvjs.Youtube.prototype.loadYoutube = function(){\n  this.ytplayer = new YT.Player(this.id_, {\n    events: {\n      onReady: function(e) { e.target.vjsTech.onReady(); },\n      onStateChange: function(e) { e.target.vjsTech.onStateChange(e.data); },\n      onPlaybackQualityChange: function(e){ e.target.vjsTech.onPlaybackQualityChange(e.data); },\n      onError: function(e){ e.target.vjsTech.onError(e.data); }\n    }\n  });\n\n  this.ytplayer.vjsTech = this;\n};\n\n// Transform a JavaScript object into URL params\nvjs.Youtube.makeQueryString = function(args){\n  var array = [];\n  for (var key in args){\n    if (args.hasOwnProperty(key)){\n      array.push(encodeURIComponent(key) + '=' + encodeURIComponent(args[key]));\n    }\n  }\n\n  return array.join('&');\n};\n\n// Called when YouTube API is ready to be used\nwindow.onYouTubeIframeAPIReady = function(){\n  var yt;\n  while ((yt = vjs.Youtube.loadingQueue.shift())){\n    yt.loadYoutube();\n  }\n  vjs.Youtube.loadingQueue = [];\n  vjs.Youtube.apiReady = true;\n};\n\nvjs.Youtube.prototype.onReady = function(){\n  this.isReady_ = true;\n  this.triggerReady();\n\n  // Let the player take care of itself as soon as the YouTube is ready\n  // The loading spinner while waiting for the tech would be impossible otherwise\n  this.iframeblocker.style.display = '';\n  this.player_.loadingSpinner.hide();\n\n  if (this.player_.options()['muted']) {\n    this.setMuted(true);\n  }\n\n  // Play ASAP if they clicked play before it's ready\n  if (this.playOnReady) {\n    this.playOnReady = false;\n    this.play();\n  }\n};\n\nvjs.Youtube.prototype.updateQualities = function(){\n  var qualities = this.ytplayer.getAvailableQualityLevels();\n  \n  if (qualities.length == 0) {\n    this.qualityButton.style.display = 'none';\n  } else {\n    this.qualityButton.style.display = '';\n    \n    while (this.qualityMenuContent.hasChildNodes()) {\n      this.qualityMenuContent.removeChild(this.qualityMenuContent.lastChild);\n    }\n\n    for (var i = 0; i < qualities.length; ++i) {\n      var el = document.createElement('li');\n      el.setAttribute('class', 'vjs-menu-item');\n\n      setInnerText(el, vjs.Youtube.parseQualityName(qualities[i]));\n\n      el.setAttribute('data-val', qualities[i]);\n      if (qualities[i] == this.quality) el.classList.add('vjs-selected');\n      \n      var self = this;\n      \n      el.addEventListener('click', function() {\n        var quality = this.getAttribute('data-val');\n        self.ytplayer.setPlaybackQuality(quality);\n        \n        setInnerText(self.qualityTitle, vjs.Youtube.parseQualityName(quality));\n        \n        var selected = self.qualityMenuContent.querySelector('.vjs-selected');\n        if (selected) selected.classList.remove('vjs-selected');\n        \n        this.classList.add('vjs-selected');\n      });\n      \n      this.qualityMenuContent.appendChild(el);\n    }\n  }\n};\n\nvjs.Youtube.prototype.onStateChange = function(state){\n  if (state != this.lastState){\n    switch(state){\n      case -1:\n        this.player_.trigger('durationchange');\n        break;\n\n      case YT.PlayerState.ENDED:\n        // Replace YouTube play button by our own\n        if (!this.player_.options()['ytcontrols']) {\n          // commented out because adding the first line pushes the live transcript down\n          // and the second line has a button appear over the youtube play button and looks weird.\n          //this.player_el_.getElementsByClassName('vjs-poster')[0].style.display = 'block';\n          //this.player_.bigPlayButton.show();\n        }\n\n        this.player_.trigger('ended');\n        break;\n\n      case YT.PlayerState.PLAYING:\n        // Make sure the big play is not there\n        this.player_.bigPlayButton.hide();\n\n        this.updateQualities();\n\n        this.player_.trigger('timeupdate');\n        this.player_.trigger('durationchange');\n        this.player_.trigger('playing');\n        this.player_.trigger('play');\n        break;\n\n      case YT.PlayerState.PAUSED:\n        this.player_.trigger('pause');\n        break;\n\n      case YT.PlayerState.BUFFERING:\n        this.player_.trigger('timeupdate');\n        \n        // Make sure to not display the spinner for mobile\n        if (!this.player_.options()['ytcontrols']) {\n          this.player_.trigger('waiting');\n        }\n        break;\n\n      case YT.PlayerState.CUED:\n        break;\n    }\n\n    this.lastState = state;\n  }\n};\n\nvjs.Youtube.convertQualityName = function(name) {\n  switch (name) {\n    case '144p':\n      return 'tiny';\n\n    case '240p':\n      return 'small';\n\n    case '360p':\n      return 'medium';\n\n    case '480p':\n      return 'large';\n\n    case '720p':\n      return 'hd720';\n\n    case '1080p':\n      return 'hd1080';\n  }\n\n  return name;\n};\n\nvjs.Youtube.parseQualityName = function(name) {\n  switch (name) {\n    case 'tiny':\n      return '144p';\n\n    case 'small':\n      return '240p';\n\n    case 'medium':\n      return '360p';\n\n    case 'large':\n      return '480p';\n\n    case 'hd720':\n      return '720p';\n\n    case 'hd1080':\n      return '1080p';\n  }\n  \n  return name;\n};\n\nvjs.Youtube.prototype.onPlaybackQualityChange = function(quality){\n  this.quality = quality;\n  setInnerText(this.qualityTitle, vjs.Youtube.parseQualityName(quality));\n  \n  switch(quality){\n    case 'medium':\n      this.player_.videoWidth = 480;\n      this.player_.videoHeight = 360;\n      break;\n\n    case 'large':\n      this.player_.videoWidth = 640;\n      this.player_.videoHeight = 480;\n      break;\n\n    case 'hd720':\n      this.player_.videoWidth = 960;\n      this.player_.videoHeight = 720;\n      break;\n\n    case 'hd1080':\n      this.player_.videoWidth = 1440;\n      this.player_.videoHeight = 1080;\n      break;\n\n    case 'highres':\n      this.player_.videoWidth = 1920;\n      this.player_.videoHeight = 1080;\n      break;\n\n    case 'small':\n      this.player_.videoWidth = 320;\n      this.player_.videoHeight = 240;\n      break;\n      \n    case 'tiny':\n      this.player_.videoWidth = 144;\n      this.player_.videoHeight = 108;\n      break;\n\n    default:\n      this.player_.videoWidth = 0;\n      this.player_.videoHeight = 0;\n      break;\n  }\n\n  this.player_.trigger('ratechange');\n};\n\nvjs.Youtube.prototype.onError = function(error){\n  this.player_.error = error;\n  this.player_.trigger('error');\n};\n\n//Cross browser solution to add text content to an element\nfunction setInnerText(element, text) {\n  var textProperty = ('innerText' in element)? 'innerText' : 'textContent';\n  element[textProperty] = text;\n}\n\n// Stretch the YouTube poster\n// Keep the iframeblocker in front of the player when the user is inactive\n// (ONLY way because the iframe is so selfish with events)\n(function() {\n  var style = document.createElement(\"style\");\n  style.type = 'text/css';\n  var css = \" .vjs-youtube .vjs-poster { background-size: cover; }.iframeblocker { display:none;position:absolute;top:0;left:0;width:100%;height:100%;cursor:pointer;z-index:2; }.vjs-youtube.vjs-user-inactive .iframeblocker { display:block; } .vjs-quality-button > div:first-child > span:first-child { position:relative;top:7px }\";\n  setInnerText(style, css);\n  document.getElementsByTagName(\"head\")[0].appendChild(style);\n})();\n\n\n/**\n * @fileoverview HTML5 Media Controller - Wrapper for HTML5 Media API\n */\n\n/**\n * HTML5 Media Controller - Wrapper for HTML5 Media API\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @param {Function=} ready\n * @constructor\n */\nvjs.Html5 = vjs.MediaTechController.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    // volume cannot be changed from 1 on iOS\n    this.features['volumeControl'] = vjs.Html5.canControlVolume();\n\n    // just in case; or is it excessively...\n    this.features['playbackRate'] = vjs.Html5.canControlPlaybackRate();\n\n    // In iOS, if you move a video element in the DOM, it breaks video playback.\n    this.features['movingMediaElementInDOM'] = !vjs.IS_IOS;\n\n    // HTML video is able to automatically resize when going to fullscreen\n    this.features['fullscreenResize'] = true;\n\n    vjs.MediaTechController.call(this, player, options, ready);\n\n    var source = options['source'];\n\n    // If the element source is already set, we may have missed the loadstart event, and want to trigger it.\n    // We don't want to set the source again and interrupt playback.\n    if (source && this.el_.currentSrc == source.src) {\n      player.trigger('loadstart');\n\n    // Otherwise set the source if one was provided.\n    } else if (source) {\n      this.el_.src = source.src;\n    }\n\n    // Determine if native controls should be used\n    // Our goal should be to get the custom controls on mobile solid everywhere\n    // so we can remove this all together. Right now this will block custom\n    // controls on touch enabled laptops like the Chrome Pixel\n    if (vjs.TOUCH_ENABLED && player.options()['nativeControlsForTouch'] !== false) {\n      this.useNativeControls();\n    }\n\n    // Chrome and Safari both have issues with autoplay.\n    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.\n    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)\n    // This fixes both issues. Need to wait for API, so it updates displays correctly\n    player.ready(function(){\n      if (this.tag && this.options_['autoplay'] && this.paused()) {\n        delete this.tag['poster']; // Chrome Fix. Fixed in Chrome v16.\n        this.play();\n      }\n    });\n\n    this.setupTriggers();\n    this.triggerReady();\n  }\n});\n\nvjs.Html5.prototype.dispose = function(){\n  vjs.MediaTechController.prototype.dispose.call(this);\n};\n\nvjs.Html5.prototype.createEl = function(){\n  var player = this.player_,\n      // If possible, reuse original tag for HTML5 playback technology element\n      el = player.tag,\n      newEl;\n\n  // Check if this browser supports moving the element into the box.\n  // On the iPhone video will break if you move the element,\n  // So we have to create a brand new element.\n  if (!el || this.features['movingMediaElementInDOM'] === false) {\n\n    // If the original tag is still there, remove it.\n    if (el) {\n      el['player'] = null;\n      player.tag = null;\n      player.el().removeChild(el);\n      el = el.cloneNode(false);\n    } else {\n      el = vjs.createEl('video', {\n        id:player.id() + '_html5_api',\n        className:'vjs-tech'\n      });\n    }\n    // associate the player with the new tag\n    el['player'] = player;\n\n    vjs.insertFirst(el, player.el());\n  }\n\n  // Update specific tag settings, in case they were overridden\n  var attrs = ['autoplay','preload','loop','muted'];\n  for (var i = attrs.length - 1; i >= 0; i--) {\n    var attr = attrs[i];\n    if (player.options_[attr] !== null) {\n      el[attr] = player.options_[attr];\n    }\n  }\n\n  return el;\n  // jenniisawesome = true;\n};\n\n// Make video events trigger player events\n// May seem verbose here, but makes other APIs possible.\nvjs.Html5.prototype.setupTriggers = function(){\n  for (var i = vjs.Html5.Events.length - 1; i >= 0; i--) {\n    vjs.on(this.el_, vjs.Html5.Events[i], vjs.bind(this.player_, this.eventHandler));\n  }\n};\n// Triggers removed using this.off when disposed\n\nvjs.Html5.prototype.eventHandler = function(e){\n  this.trigger(e);\n\n  // No need for media events to bubble up.\n  e.stopPropagation();\n};\n\nvjs.Html5.prototype.useNativeControls = function(){\n  var tech, player, controlsOn, controlsOff, cleanUp;\n\n  tech = this;\n  player = this.player();\n\n  // If the player controls are enabled turn on the native controls\n  tech.setControls(player.controls());\n\n  // Update the native controls when player controls state is updated\n  controlsOn = function(){\n    tech.setControls(true);\n  };\n  controlsOff = function(){\n    tech.setControls(false);\n  };\n  player.on('controlsenabled', controlsOn);\n  player.on('controlsdisabled', controlsOff);\n\n  // Clean up when not using native controls anymore\n  cleanUp = function(){\n    player.off('controlsenabled', controlsOn);\n    player.off('controlsdisabled', controlsOff);\n  };\n  tech.on('dispose', cleanUp);\n  player.on('usingcustomcontrols', cleanUp);\n\n  // Update the state of the player to using native controls\n  player.usingNativeControls(true);\n};\n\n\nvjs.Html5.prototype.play = function(){ this.el_.play(); };\nvjs.Html5.prototype.pause = function(){ this.el_.pause(); };\nvjs.Html5.prototype.paused = function(){ return this.el_.paused; };\n\nvjs.Html5.prototype.currentTime = function(){ return this.el_.currentTime; };\nvjs.Html5.prototype.setCurrentTime = function(seconds){\n  try {\n    this.el_.currentTime = seconds;\n  } catch(e) {\n    vjs.log(e, 'Video is not ready. (Video.js)');\n    // this.warning(VideoJS.warnings.videoNotReady);\n  }\n};\n\nvjs.Html5.prototype.duration = function(){ return this.el_.duration || 0; };\nvjs.Html5.prototype.buffered = function(){ return this.el_.buffered; };\n\nvjs.Html5.prototype.volume = function(){ return this.el_.volume; };\nvjs.Html5.prototype.setVolume = function(percentAsDecimal){ this.el_.volume = percentAsDecimal; };\nvjs.Html5.prototype.muted = function(){ return this.el_.muted; };\nvjs.Html5.prototype.setMuted = function(muted){ this.el_.muted = muted; };\n\nvjs.Html5.prototype.width = function(){ return this.el_.offsetWidth; };\nvjs.Html5.prototype.height = function(){ return this.el_.offsetHeight; };\n\nvjs.Html5.prototype.supportsFullScreen = function(){\n  if (typeof this.el_.webkitEnterFullScreen == 'function') {\n\n    // Seems to be broken in Chromium/Chrome && Safari in Leopard\n    if (/Android/.test(vjs.USER_AGENT) || !/Chrome|Mac OS X 10.5/.test(vjs.USER_AGENT)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvjs.Html5.prototype.enterFullScreen = function(){\n  var video = this.el_;\n  if (video.paused && video.networkState <= video.HAVE_METADATA) {\n    // attempt to prime the video element for programmatic access\n    // this isn't necessary on the desktop but shouldn't hurt\n    this.el_.play();\n\n    // playing and pausing synchronously during the transition to fullscreen\n    // can get iOS ~6.1 devices into a play/pause loop\n    setTimeout(function(){\n      video.pause();\n      video.webkitEnterFullScreen();\n    }, 0);\n  } else {\n    video.webkitEnterFullScreen();\n  }\n};\nvjs.Html5.prototype.exitFullScreen = function(){\n  this.el_.webkitExitFullScreen();\n};\nvjs.Html5.prototype.src = function(src){ this.el_.src = src; };\nvjs.Html5.prototype.load = function(){ this.el_.load(); };\nvjs.Html5.prototype.currentSrc = function(){ return this.el_.currentSrc; };\n\nvjs.Html5.prototype.preload = function(){ return this.el_.preload; };\nvjs.Html5.prototype.setPreload = function(val){ this.el_.preload = val; };\n\nvjs.Html5.prototype.autoplay = function(){ return this.el_.autoplay; };\nvjs.Html5.prototype.setAutoplay = function(val){ this.el_.autoplay = val; };\n\nvjs.Html5.prototype.controls = function(){ return this.el_.controls; }\nvjs.Html5.prototype.setControls = function(val){ this.el_.controls = !!val; }\n\nvjs.Html5.prototype.loop = function(){ return this.el_.loop; };\nvjs.Html5.prototype.setLoop = function(val){ this.el_.loop = val; };\n\nvjs.Html5.prototype.error = function(){ return this.el_.error; };\nvjs.Html5.prototype.seeking = function(){ return this.el_.seeking; };\nvjs.Html5.prototype.ended = function(){ return this.el_.ended; };\nvjs.Html5.prototype.defaultMuted = function(){ return this.el_.defaultMuted; };\n\nvjs.Html5.prototype.playbackRate = function(){ return this.el_.playbackRate; };\nvjs.Html5.prototype.setPlaybackRate = function(val){ this.el_.playbackRate = val; };\n\n/* HTML5 Support Testing ---------------------------------------------------- */\n\nvjs.Html5.isSupported = function(){\n  return !!vjs.TEST_VID.canPlayType;\n};\n\nvjs.Html5.canPlaySource = function(srcObj){\n  // IE9 on Windows 7 without MediaPlayer throws an error here\n  // https://github.com/videojs/video.js/issues/519\n  try {\n    return !!vjs.TEST_VID.canPlayType(srcObj.type);\n  } catch(e) {\n    return '';\n  }\n  // TODO: Check Type\n  // If no Type, check ext\n  // Check Media Type\n};\n\nvjs.Html5.canControlVolume = function(){\n  var volume =  vjs.TEST_VID.volume;\n  vjs.TEST_VID.volume = (volume / 2) + 0.1;\n  return volume !== vjs.TEST_VID.volume;\n};\n\nvjs.Html5.canControlPlaybackRate = function(){\n  var playbackRate = vjs.TEST_VID.playbackRate;\n  vjs.TEST_VID.playbackRate = (playbackRate / 2) + 0.1;\n  return playbackRate !== vjs.TEST_VID.playbackRate;\n};\n\n// List of all HTML5 events (various uses).\nvjs.Html5.Events = 'loadstart,suspend,abort,error,emptied,stalled,loadedmetadata,loadeddata,canplay,canplaythrough,playing,waiting,seeking,seeked,ended,durationchange,timeupdate,progress,play,pause,ratechange,volumechange'.split(',');\n\n\n// HTML5 Feature detection and Device Fixes --------------------------------- //\n\n  // Override Android 2.2 and less canPlayType method which is broken\nif (vjs.IS_OLD_ANDROID) {\n  document.createElement('video').constructor.prototype.canPlayType = function(type){\n    return (type && type.toLowerCase().indexOf('video/mp4') != -1) ? 'maybe' : '';\n  };\n}\n/**\n * @fileoverview VideoJS-SWF - Custom Flash Player with HTML5-ish API\n * https://github.com/zencoder/video-js-swf\n * Not using setupTriggers. Using global onEvent func to distribute events\n */\n\n/**\n * HTML5 Media Controller - Wrapper for HTML5 Media API\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @param {Function=} ready\n * @constructor\n */\nvjs.Flash = vjs.MediaTechController.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    vjs.MediaTechController.call(this, player, options, ready);\n\n    var source = options['source'],\n\n        // Which element to embed in\n        parentEl = options['parentEl'],\n\n        // Create a temporary element to be replaced by swf object\n        placeHolder = this.el_ = vjs.createEl('div', { id: player.id() + '_temp_flash' }),\n\n        // Generate ID for swf object\n        objId = player.id()+'_flash_api',\n\n        // Store player options in local var for optimization\n        // TODO: switch to using player methods instead of options\n        // e.g. player.autoplay();\n        playerOptions = player.options_,\n\n        // Merge default flashvars with ones passed in to init\n        flashVars = vjs.obj.merge({\n\n          // SWF Callback Functions\n          'readyFunction': 'videojs.Flash.onReady',\n          'eventProxyFunction': 'videojs.Flash.onEvent',\n          'errorEventProxyFunction': 'videojs.Flash.onError',\n\n          // Player Settings\n          'autoplay': playerOptions.autoplay,\n          'preload': playerOptions.preload,\n          'loop': playerOptions.loop,\n          'muted': playerOptions.muted\n\n        }, options['flashVars']),\n\n        // Merge default parames with ones passed in\n        params = vjs.obj.merge({\n          'wmode': 'opaque', // Opaque is needed to overlay controls, but can affect playback performance\n          'bgcolor': '#000000' // Using bgcolor prevents a white flash when the object is loading\n        }, options['params']),\n\n        // Merge default attributes with ones passed in\n        attributes = vjs.obj.merge({\n          'id': objId,\n          'name': objId, // Both ID and Name needed or swf to identifty itself\n          'class': 'vjs-tech'\n        }, options['attributes'])\n    ;\n\n    // If source was supplied pass as a flash var.\n    if (source) {\n      if (source.type && vjs.Flash.isStreamingType(source.type)) {\n        var parts = vjs.Flash.streamToParts(source.src);\n        flashVars['rtmpConnection'] = encodeURIComponent(parts.connection);\n        flashVars['rtmpStream'] = encodeURIComponent(parts.stream);\n      }\n      else {\n        flashVars['src'] = encodeURIComponent(vjs.getAbsoluteURL(source.src));\n      }\n    }\n\n    // Add placeholder to player div\n    vjs.insertFirst(placeHolder, parentEl);\n\n    // Having issues with Flash reloading on certain page actions (hide/resize/fullscreen) in certain browsers\n    // This allows resetting the playhead when we catch the reload\n    if (options['startTime']) {\n      this.ready(function(){\n        this.load();\n        this.play();\n        this.currentTime(options['startTime']);\n      });\n    }\n\n    // Flash iFrame Mode\n    // In web browsers there are multiple instances where changing the parent element or visibility of a plugin causes the plugin to reload.\n    // - Firefox just about always. https://bugzilla.mozilla.org/show_bug.cgi?id=90268 (might be fixed by version 13)\n    // - Webkit when hiding the plugin\n    // - Webkit and Firefox when using requestFullScreen on a parent element\n    // Loading the flash plugin into a dynamically generated iFrame gets around most of these issues.\n    // Issues that remain include hiding the element and requestFullScreen in Firefox specifically\n\n    // There's on particularly annoying issue with this method which is that Firefox throws a security error on an offsite Flash object loaded into a dynamically created iFrame.\n    // Even though the iframe was inserted into a page on the web, Firefox + Flash considers it a local app trying to access an internet file.\n    // I tried mulitple ways of setting the iframe src attribute but couldn't find a src that worked well. Tried a real/fake source, in/out of domain.\n    // Also tried a method from stackoverflow that caused a security error in all browsers. http://stackoverflow.com/questions/2486901/how-to-set-document-domain-for-a-dynamically-generated-iframe\n    // In the end the solution I found to work was setting the iframe window.location.href right before doing a document.write of the Flash object.\n    // The only downside of this it seems to trigger another http request to the original page (no matter what's put in the href). Not sure why that is.\n\n    // NOTE (2012-01-29): Cannot get Firefox to load the remote hosted SWF into a dynamically created iFrame\n    // Firefox 9 throws a security error, unleess you call location.href right before doc.write.\n    //    Not sure why that even works, but it causes the browser to look like it's continuously trying to load the page.\n    // Firefox 3.6 keeps calling the iframe onload function anytime I write to it, causing an endless loop.\n\n    if (options['iFrameMode'] === true && !vjs.IS_FIREFOX) {\n\n      // Create iFrame with vjs-tech class so it's 100% width/height\n      var iFrm = vjs.createEl('iframe', {\n        'id': objId + '_iframe',\n        'name': objId + '_iframe',\n        'className': 'vjs-tech',\n        'scrolling': 'no',\n        'marginWidth': 0,\n        'marginHeight': 0,\n        'frameBorder': 0\n      });\n\n      // Update ready function names in flash vars for iframe window\n      flashVars['readyFunction'] = 'ready';\n      flashVars['eventProxyFunction'] = 'events';\n      flashVars['errorEventProxyFunction'] = 'errors';\n\n      // Tried multiple methods to get this to work in all browsers\n\n      // Tried embedding the flash object in the page first, and then adding a place holder to the iframe, then replacing the placeholder with the page object.\n      // The goal here was to try to load the swf URL in the parent page first and hope that got around the firefox security error\n      // var newObj = vjs.Flash.embed(options['swf'], placeHolder, flashVars, params, attributes);\n      // (in onload)\n      //  var temp = vjs.createEl('a', { id:'asdf', innerHTML: 'asdf' } );\n      //  iDoc.body.appendChild(temp);\n\n      // Tried embedding the flash object through javascript in the iframe source.\n      // This works in webkit but still triggers the firefox security error\n      // iFrm.src = 'javascript: document.write('\"+vjs.Flash.getEmbedCode(options['swf'], flashVars, params, attributes)+\"');\";\n\n      // Tried an actual local iframe just to make sure that works, but it kills the easiness of the CDN version if you require the user to host an iframe\n      // We should add an option to host the iframe locally though, because it could help a lot of issues.\n      // iFrm.src = \"iframe.html\";\n\n      // Wait until iFrame has loaded to write into it.\n      vjs.on(iFrm, 'load', vjs.bind(this, function(){\n\n        var iDoc,\n            iWin = iFrm.contentWindow;\n\n        // The one working method I found was to use the iframe's document.write() to create the swf object\n        // This got around the security issue in all browsers except firefox.\n        // I did find a hack where if I call the iframe's window.location.href='', it would get around the security error\n        // However, the main page would look like it was loading indefinitely (URL bar loading spinner would never stop)\n        // Plus Firefox 3.6 didn't work no matter what I tried.\n        // if (vjs.USER_AGENT.match('Firefox')) {\n        //   iWin.location.href = '';\n        // }\n\n        // Get the iFrame's document depending on what the browser supports\n        iDoc = iFrm.contentDocument ? iFrm.contentDocument : iFrm.contentWindow.document;\n\n        // Tried ensuring both document domains were the same, but they already were, so that wasn't the issue.\n        // Even tried adding /. that was mentioned in a browser security writeup\n        // document.domain = document.domain+'/.';\n        // iDoc.domain = document.domain+'/.';\n\n        // Tried adding the object to the iframe doc's innerHTML. Security error in all browsers.\n        // iDoc.body.innerHTML = swfObjectHTML;\n\n        // Tried appending the object to the iframe doc's body. Security error in all browsers.\n        // iDoc.body.appendChild(swfObject);\n\n        // Using document.write actually got around the security error that browsers were throwing.\n        // Again, it's a dynamically generated (same domain) iframe, loading an external Flash swf.\n        // Not sure why that's a security issue, but apparently it is.\n        iDoc.write(vjs.Flash.getEmbedCode(options['swf'], flashVars, params, attributes));\n\n        // Setting variables on the window needs to come after the doc write because otherwise they can get reset in some browsers\n        // So far no issues with swf ready event being called before it's set on the window.\n        iWin['player'] = this.player_;\n\n        // Create swf ready function for iFrame window\n        iWin['ready'] = vjs.bind(this.player_, function(currSwf){\n          var el = iDoc.getElementById(currSwf),\n              player = this,\n              tech = player.tech;\n\n          // Update reference to playback technology element\n          tech.el_ = el;\n\n          // Make sure swf is actually ready. Sometimes the API isn't actually yet.\n          vjs.Flash.checkReady(tech);\n        });\n\n        // Create event listener for all swf events\n        iWin['events'] = vjs.bind(this.player_, function(swfID, eventName){\n          var player = this;\n          if (player && player.techName === 'flash') {\n            player.trigger(eventName);\n          }\n        });\n\n        // Create error listener for all swf errors\n        iWin['errors'] = vjs.bind(this.player_, function(swfID, eventName){\n          vjs.log('Flash Error', eventName);\n        });\n\n      }));\n\n      // Replace placeholder with iFrame (it will load now)\n      placeHolder.parentNode.replaceChild(iFrm, placeHolder);\n\n    // If not using iFrame mode, embed as normal object\n    } else {\n      vjs.Flash.embed(options['swf'], placeHolder, flashVars, params, attributes);\n    }\n  }\n});\n\nvjs.Flash.prototype.dispose = function(){\n  vjs.MediaTechController.prototype.dispose.call(this);\n};\n\nvjs.Flash.prototype.play = function(){\n  this.el_.vjs_play();\n};\n\nvjs.Flash.prototype.pause = function(){\n  this.el_.vjs_pause();\n};\n\nvjs.Flash.prototype.src = function(src){\n  if (vjs.Flash.isStreamingSrc(src)) {\n    src = vjs.Flash.streamToParts(src);\n    this.setRtmpConnection(src.connection);\n    this.setRtmpStream(src.stream);\n  }\n  else {\n    // Make sure source URL is abosolute.\n    src = vjs.getAbsoluteURL(src);\n    this.el_.vjs_src(src);\n  }\n\n  // Currently the SWF doesn't autoplay if you load a source later.\n  // e.g. Load player w/ no source, wait 2s, set src.\n  if (this.player_.autoplay()) {\n    var tech = this;\n    setTimeout(function(){ tech.play(); }, 0);\n  }\n};\n\nvjs.Flash.prototype.currentSrc = function(){\n  var src = this.el_.vjs_getProperty('currentSrc');\n  // no src, check and see if RTMP\n  if (src == null) {\n    var connection = this.rtmpConnection(),\n        stream = this.rtmpStream();\n\n    if (connection && stream) {\n      src = vjs.Flash.streamFromParts(connection, stream);\n    }\n  }\n  return src;\n};\n\nvjs.Flash.prototype.load = function(){\n  this.el_.vjs_load();\n};\n\nvjs.Flash.prototype.poster = function(){\n  this.el_.vjs_getProperty('poster');\n};\n\nvjs.Flash.prototype.buffered = function(){\n  return vjs.createTimeRange(0, this.el_.vjs_getProperty('buffered'));\n};\n\nvjs.Flash.prototype.supportsFullScreen = function(){\n  return false; // Flash does not allow fullscreen through javascript\n};\n\nvjs.Flash.prototype.enterFullScreen = function(){\n  return false;\n};\n\n\n// Create setters and getters for attributes\nvar api = vjs.Flash.prototype,\n    readWrite = 'rtmpConnection,rtmpStream,preload,currentTime,defaultPlaybackRate,playbackRate,autoplay,loop,mediaGroup,controller,controls,volume,muted,defaultMuted'.split(','),\n    readOnly = 'error,currentSrc,networkState,readyState,seeking,initialTime,duration,startOffsetTime,paused,played,seekable,ended,videoTracks,audioTracks,videoWidth,videoHeight,textTracks'.split(',');\n    // Overridden: buffered\n\n/**\n * @this {*}\n */\nvar createSetter = function(attr){\n  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);\n  api['set'+attrUpper] = function(val){ return this.el_.vjs_setProperty(attr, val); };\n};\n\n/**\n * @this {*}\n */\nvar createGetter = function(attr){\n  api[attr] = function(){ return this.el_.vjs_getProperty(attr); };\n};\n\n(function(){\n  var i;\n  // Create getter and setters for all read/write attributes\n  for (i = 0; i < readWrite.length; i++) {\n    createGetter(readWrite[i]);\n    createSetter(readWrite[i]);\n  }\n\n  // Create getters for read-only attributes\n  for (i = 0; i < readOnly.length; i++) {\n    createGetter(readOnly[i]);\n  }\n})();\n\n/* Flash Support Testing -------------------------------------------------------- */\n\nvjs.Flash.isSupported = function(){\n  return vjs.Flash.version()[0] >= 10;\n  // return swfobject.hasFlashPlayerVersion('10');\n};\n\nvjs.Flash.canPlaySource = function(srcObj){\n  if (srcObj.type in vjs.Flash.formats || srcObj.type in vjs.Flash.streamingFormats) { return 'maybe'; }\n};\n\nvjs.Flash.formats = {\n  'video/flv': 'FLV',\n  'video/x-flv': 'FLV',\n  'video/mp4': 'MP4',\n  'video/m4v': 'MP4'\n};\n\nvjs.Flash.streamingFormats = {\n  'rtmp/mp4': 'MP4',\n  'rtmp/flv': 'FLV'\n};\n\nvjs.Flash['onReady'] = function(currSwf){\n  var el = vjs.el(currSwf);\n\n  // Get player from box\n  // On firefox reloads, el might already have a player\n  var player = el['player'] || el.parentNode['player'],\n      tech = player.tech;\n\n  // Reference player on tech element\n  el['player'] = player;\n\n  // Update reference to playback technology element\n  tech.el_ = el;\n\n  vjs.Flash.checkReady(tech);\n};\n\n// The SWF isn't alwasy ready when it says it is. Sometimes the API functions still need to be added to the object.\n// If it's not ready, we set a timeout to check again shortly.\nvjs.Flash.checkReady = function(tech){\n\n  // Check if API property exists\n  if (tech.el().vjs_getProperty) {\n\n    // If so, tell tech it's ready\n    tech.triggerReady();\n\n  // Otherwise wait longer.\n  } else {\n\n    setTimeout(function(){\n      vjs.Flash.checkReady(tech);\n    }, 50);\n\n  }\n};\n\n// Trigger events from the swf on the player\nvjs.Flash['onEvent'] = function(swfID, eventName){\n  var player = vjs.el(swfID)['player'];\n  player.trigger(eventName);\n};\n\n// Log errors from the swf\nvjs.Flash['onError'] = function(swfID, err){\n  var player = vjs.el(swfID)['player'];\n  player.trigger('error');\n  vjs.log('Flash Error', err, swfID);\n};\n\n// Flash Version Check\nvjs.Flash.version = function(){\n  var version = '0,0,0';\n\n  // IE\n  try {\n    version = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\\D+/g, ',').match(/^,?(.+),?$/)[1];\n\n  // other browsers\n  } catch(e) {\n    try {\n      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin){\n        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\\D+/g, ',').match(/^,?(.+),?$/)[1];\n      }\n    } catch(err) {}\n  }\n  return version.split(',');\n};\n\n// Flash embedding method. Only used in non-iframe mode\nvjs.Flash.embed = function(swf, placeHolder, flashVars, params, attributes){\n  var code = vjs.Flash.getEmbedCode(swf, flashVars, params, attributes),\n\n      // Get element by embedding code and retrieving created element\n      obj = vjs.createEl('div', { innerHTML: code }).childNodes[0],\n\n      par = placeHolder.parentNode\n  ;\n\n  placeHolder.parentNode.replaceChild(obj, placeHolder);\n\n  // IE6 seems to have an issue where it won't initialize the swf object after injecting it.\n  // This is a dumb fix\n  var newObj = par.childNodes[0];\n  setTimeout(function(){\n    newObj.style.display = 'block';\n  }, 1000);\n\n  return obj;\n\n};\n\nvjs.Flash.getEmbedCode = function(swf, flashVars, params, attributes){\n\n  var objTag = '<object type=\"application/x-shockwave-flash\"',\n      flashVarsString = '',\n      paramsString = '',\n      attrsString = '';\n\n  // Convert flash vars to string\n  if (flashVars) {\n    vjs.obj.each(flashVars, function(key, val){\n      flashVarsString += (key + '=' + val + '&amp;');\n    });\n  }\n\n  // Add swf, flashVars, and other default params\n  params = vjs.obj.merge({\n    'movie': swf,\n    'flashvars': flashVarsString,\n    'allowScriptAccess': 'always', // Required to talk to swf\n    'allowNetworking': 'all' // All should be default, but having security issues.\n  }, params);\n\n  // Create param tags string\n  vjs.obj.each(params, function(key, val){\n    paramsString += '<param name=\"'+key+'\" value=\"'+val+'\" />';\n  });\n\n  attributes = vjs.obj.merge({\n    // Add swf to attributes (need both for IE and Others to work)\n    'data': swf,\n\n    // Default to 100% width/height\n    'width': '100%',\n    'height': '100%'\n\n  }, attributes);\n\n  // Create Attributes string\n  vjs.obj.each(attributes, function(key, val){\n    attrsString += (key + '=\"' + val + '\" ');\n  });\n\n  return objTag + attrsString + '>' + paramsString + '</object>';\n};\n\nvjs.Flash.streamFromParts = function(connection, stream) {\n  return connection + '&' + stream;\n};\n\nvjs.Flash.streamToParts = function(src) {\n  var parts = {\n    connection: '',\n    stream: ''\n  };\n\n  if (! src) {\n    return parts;\n  }\n\n  // Look for the normal URL separator we expect, '&'.\n  // If found, we split the URL into two pieces around the\n  // first '&'.\n  var connEnd = src.indexOf('&');\n  var streamBegin;\n  if (connEnd !== -1) {\n    streamBegin = connEnd + 1;\n  }\n  else {\n    // If there's not a '&', we use the last '/' as the delimiter.\n    connEnd = streamBegin = src.lastIndexOf('/') + 1;\n    if (connEnd === 0) {\n      // really, there's not a '/'?\n      connEnd = streamBegin = src.length;\n    }\n  }\n  parts.connection = src.substring(0, connEnd);\n  parts.stream = src.substring(streamBegin, src.length);\n\n  return parts;\n};\n\nvjs.Flash.isStreamingType = function(srcType) {\n  return srcType in vjs.Flash.streamingFormats;\n};\n\n// RTMP has four variations, any string starting\n// with one of these protocols should be valid\nvjs.Flash.RTMP_RE = /^rtmp[set]?:\\/\\//i;\n\nvjs.Flash.isStreamingSrc = function(src) {\n  return vjs.Flash.RTMP_RE.test(src);\n};\n/**\n * @constructor\n */\nvjs.MediaLoader = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    vjs.Component.call(this, player, options, ready);\n\n    // If there are no sources when the player is initialized,\n    // load the first supported playback technology.\n    if (!player.options_['sources'] || player.options_['sources'].length === 0) {\n      for (var i=0,j=player.options_['techOrder']; i<j.length; i++) {\n        var techName = vjs.capitalize(j[i]),\n            tech = __webpack_provided_window_dot_videojs[techName];\n\n        // Check if the browser supports this technology\n        if (tech && tech.isSupported()) {\n          player.loadTech(techName);\n          break;\n        }\n      }\n    } else {\n      // // Loop through playback technologies (HTML5, Flash) and check for support.\n      // // Then load the best source.\n      // // A few assumptions here:\n      // //   All playback technologies respect preload false.\n      player.src(player.options_['sources']);\n    }\n  }\n});/**\n * @fileoverview Text Tracks\n * Text tracks are tracks of timed text events.\n * Captions - text displayed over the video for the hearing impared\n * Subtitles - text displayed over the video for those who don't understand langauge in the video\n * Chapters - text displayed in a menu allowing the user to jump to particular points (chapters) in the video\n * Descriptions (not supported yet) - audio descriptions that are read back to the user by a screen reading device\n */\n\n// Player Additions - Functions add to the player object for easier access to tracks\n\n/**\n * List of associated text tracks\n * @type {Array}\n * @private\n */\nvjs.Player.prototype.textTracks_;\n\n/**\n * Get an array of associated text tracks. captions, subtitles, chapters, descriptions\n * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\n * @return {Array}           Array of track objects\n */\nvjs.Player.prototype.textTracks = function(){\n  this.textTracks_ = this.textTracks_ || [];\n  return this.textTracks_;\n};\n\n/**\n * Add a text track\n * In addition to the W3C settings we allow adding additional info through options.\n * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\n * @param {String}  kind        Captions, subtitles, chapters, descriptions, or metadata\n * @param {String=} label       Optional label\n * @param {String=} language    Optional language\n * @param {Object=} options     Additional track options, like src\n */\nvjs.Player.prototype.addTextTrack = function(kind, label, language, options){\n  var tracks = this.textTracks_ = this.textTracks_ || [];\n  options = options || {};\n\n  options['kind'] = kind;\n  options['label'] = label;\n  options['language'] = language;\n\n  // HTML5 Spec says default to subtitles.\n  // Uppercase first letter to match class names\n  var Kind = vjs.capitalize(kind || 'subtitles');\n\n  // Create correct texttrack class. CaptionsTrack, etc.\n  var track = new __webpack_provided_window_dot_videojs[Kind + 'Track'](this, options);\n\n  tracks.push(track);\n\n  // If track.dflt() is set, start showing immediately\n  // TODO: Add a process to deterime the best track to show for the specific kind\n  // Incase there are mulitple defaulted tracks of the same kind\n  // Or the user has a set preference of a specific language that should override the default\n  // if (track.dflt()) {\n  //   this.ready(vjs.bind(track, track.show));\n  // }\n\n  return track;\n};\n\n/**\n * Add an array of text tracks. captions, subtitles, chapters, descriptions\n * Track objects will be stored in the player.textTracks() array\n * @param {Array} trackList Array of track elements or objects (fake track elements)\n */\nvjs.Player.prototype.addTextTracks = function(trackList){\n  var trackObj;\n\n  for (var i = 0; i < trackList.length; i++) {\n    trackObj = trackList[i];\n    this.addTextTrack(trackObj['kind'], trackObj['label'], trackObj['language'], trackObj);\n  }\n\n  return this;\n};\n\n// Show a text track\n// disableSameKind: disable all other tracks of the same kind. Value should be a track kind (captions, etc.)\nvjs.Player.prototype.showTextTrack = function(id, disableSameKind){\n  var tracks = this.textTracks_,\n      i = 0,\n      j = tracks.length,\n      track, showTrack, kind;\n  // Find Track with same ID\n  for (;i<j;i++) {\n    track = tracks[i];\n    if (track.id() === id) {\n      track.show();\n      showTrack = track;\n\n    // Disable tracks of the same kind\n    } else if (disableSameKind && track.kind() == disableSameKind && track.mode() > 0) {\n      track.disable();\n    }\n  }\n\n  // Get track kind from shown track or disableSameKind\n  kind = (showTrack) ? showTrack.kind() : ((disableSameKind) ? disableSameKind : false);\n\n  // Trigger trackchange event, captionstrackchange, subtitlestrackchange, etc.\n  if (kind) {\n    this.trigger(kind+'trackchange');\n  }\n\n  return this;\n};\n\n/**\n * Track Class\n * Contains track methods for loading, showing, parsing cues of tracks\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @constructor\n */\nvjs.TextTrack = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.Component.call(this, player, options);\n\n    // Apply track info to track object\n    // Options will often be a track element\n\n    // Build ID if one doesn't exist\n    this.id_ = options['id'] || ('vjs_' + options['kind'] + '_' + options['language'] + '_' + vjs.guid++);\n    this.src_ = options['src'];\n    // 'default' is a reserved keyword in js so we use an abbreviated version\n    this.dflt_ = options['default'] || options['dflt'];\n    this.title_ = options['title'];\n    this.language_ = options['srclang'];\n    this.label_ = options['label'];\n    this.cues_ = [];\n    this.activeCues_ = [];\n    this.readyState_ = 0;\n    this.mode_ = 0;\n\n    this.player_.on('fullscreenchange', vjs.bind(this, this.adjustFontSize));\n  }\n});\n\n/**\n * Track kind value. Captions, subtitles, etc.\n * @private\n */\nvjs.TextTrack.prototype.kind_;\n\n/**\n * Get the track kind value\n * @return {String}\n */\nvjs.TextTrack.prototype.kind = function(){\n  return this.kind_;\n};\n\n/**\n * Track src value\n * @private\n */\nvjs.TextTrack.prototype.src_;\n\n/**\n * Get the track src value\n * @return {String}\n */\nvjs.TextTrack.prototype.src = function(){\n  return this.src_;\n};\n\n/**\n * Track default value\n * If default is used, subtitles/captions to start showing\n * @private\n */\nvjs.TextTrack.prototype.dflt_;\n\n/**\n * Get the track default value\n * 'default' is a reserved keyword\n * @return {Boolean}\n */\nvjs.TextTrack.prototype.dflt = function(){\n  return this.dflt_;\n};\n\n/**\n * Track title value\n * @private\n */\nvjs.TextTrack.prototype.title_;\n\n/**\n * Get the track title value\n * @return {String}\n */\nvjs.TextTrack.prototype.title = function(){\n  return this.title_;\n};\n\n/**\n * Language - two letter string to represent track language, e.g. 'en' for English\n * Spec def: readonly attribute DOMString language;\n * @private\n */\nvjs.TextTrack.prototype.language_;\n\n/**\n * Get the track language value\n * @return {String}\n */\nvjs.TextTrack.prototype.language = function(){\n  return this.language_;\n};\n\n/**\n * Track label e.g. 'English'\n * Spec def: readonly attribute DOMString label;\n * @private\n */\nvjs.TextTrack.prototype.label_;\n\n/**\n * Get the track label value\n * @return {String}\n */\nvjs.TextTrack.prototype.label = function(){\n  return this.label_;\n};\n\n/**\n * All cues of the track. Cues have a startTime, endTime, text, and other properties.\n * Spec def: readonly attribute TextTrackCueList cues;\n * @private\n */\nvjs.TextTrack.prototype.cues_;\n\n/**\n * Get the track cues\n * @return {Array}\n */\nvjs.TextTrack.prototype.cues = function(){\n  return this.cues_;\n};\n\n/**\n * ActiveCues is all cues that are currently showing\n * Spec def: readonly attribute TextTrackCueList activeCues;\n * @private\n */\nvjs.TextTrack.prototype.activeCues_;\n\n/**\n * Get the track active cues\n * @return {Array}\n */\nvjs.TextTrack.prototype.activeCues = function(){\n  return this.activeCues_;\n};\n\n/**\n * ReadyState describes if the text file has been loaded\n * const unsigned short NONE = 0;\n * const unsigned short LOADING = 1;\n * const unsigned short LOADED = 2;\n * const unsigned short ERROR = 3;\n * readonly attribute unsigned short readyState;\n * @private\n */\nvjs.TextTrack.prototype.readyState_;\n\n/**\n * Get the track readyState\n * @return {Number}\n */\nvjs.TextTrack.prototype.readyState = function(){\n  return this.readyState_;\n};\n\n/**\n * Mode describes if the track is showing, hidden, or disabled\n * const unsigned short OFF = 0;\n * const unsigned short HIDDEN = 1; (still triggering cuechange events, but not visible)\n * const unsigned short SHOWING = 2;\n * attribute unsigned short mode;\n * @private\n */\nvjs.TextTrack.prototype.mode_;\n\n/**\n * Get the track mode\n * @return {Number}\n */\nvjs.TextTrack.prototype.mode = function(){\n  return this.mode_;\n};\n\n/**\n * Change the font size of the text track to make it larger when playing in fullscreen mode\n * and restore it to its normal size when not in fullscreen mode.\n */\nvjs.TextTrack.prototype.adjustFontSize = function(){\n    if (this.player_.isFullScreen) {\n        // Scale the font by the same factor as increasing the video width to the full screen window width.\n        // Additionally, multiply that factor by 1.4, which is the default font size for\n        // the caption track (from the CSS)\n        this.el_.style.fontSize = screen.width / this.player_.width() * 1.4 * 100 + '%';\n    } else {\n        // Change the font size of the text track back to its original non-fullscreen size\n        this.el_.style.fontSize = '';\n    }\n};\n\n/**\n * Create basic div to hold cue text\n * @return {Element}\n */\nvjs.TextTrack.prototype.createEl = function(){\n  return vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-' + this.kind_ + ' vjs-text-track'\n  });\n};\n\n/**\n * Show: Mode Showing (2)\n * Indicates that the text track is active. If no attempt has yet been made to obtain the track's cues, the user agent will perform such an attempt momentarily.\n * The user agent is maintaining a list of which cues are active, and events are being fired accordingly.\n * In addition, for text tracks whose kind is subtitles or captions, the cues are being displayed over the video as appropriate;\n * for text tracks whose kind is descriptions, the user agent is making the cues available to the user in a non-visual fashion;\n * and for text tracks whose kind is chapters, the user agent is making available to the user a mechanism by which the user can navigate to any point in the media resource by selecting a cue.\n * The showing by default state is used in conjunction with the default attribute on track elements to indicate that the text track was enabled due to that attribute.\n * This allows the user agent to override the state if a later track is discovered that is more appropriate per the user's preferences.\n */\nvjs.TextTrack.prototype.show = function(){\n  this.activate();\n\n  this.mode_ = 2;\n\n  // Show element.\n  vjs.Component.prototype.show.call(this);\n};\n\n/**\n * Hide: Mode Hidden (1)\n * Indicates that the text track is active, but that the user agent is not actively displaying the cues.\n * If no attempt has yet been made to obtain the track's cues, the user agent will perform such an attempt momentarily.\n * The user agent is maintaining a list of which cues are active, and events are being fired accordingly.\n */\nvjs.TextTrack.prototype.hide = function(){\n  // When hidden, cues are still triggered. Disable to stop triggering.\n  this.activate();\n\n  this.mode_ = 1;\n\n  // Hide element.\n  vjs.Component.prototype.hide.call(this);\n};\n\n/**\n * Disable: Mode Off/Disable (0)\n * Indicates that the text track is not active. Other than for the purposes of exposing the track in the DOM, the user agent is ignoring the text track.\n * No cues are active, no events are fired, and the user agent will not attempt to obtain the track's cues.\n */\nvjs.TextTrack.prototype.disable = function(){\n  // If showing, hide.\n  if (this.mode_ == 2) { this.hide(); }\n\n  // Stop triggering cues\n  this.deactivate();\n\n  // Switch Mode to Off\n  this.mode_ = 0;\n};\n\n/**\n * Turn on cue tracking. Tracks that are showing OR hidden are active.\n */\nvjs.TextTrack.prototype.activate = function(){\n  // Load text file if it hasn't been yet.\n  if (this.readyState_ === 0) { this.load(); }\n\n  // Only activate if not already active.\n  if (this.mode_ === 0) {\n    // Update current cue on timeupdate\n    // Using unique ID for bind function so other tracks don't remove listener\n    this.player_.on('timeupdate', vjs.bind(this, this.update, this.id_));\n\n    // Reset cue time on media end\n    this.player_.on('ended', vjs.bind(this, this.reset, this.id_));\n\n    // Add to display\n    if (this.kind_ === 'captions' || this.kind_ === 'subtitles') {\n      this.player_.getChild('textTrackDisplay').addChild(this);\n    }\n  }\n};\n\n/**\n * Turn off cue tracking.\n */\nvjs.TextTrack.prototype.deactivate = function(){\n  // Using unique ID for bind function so other tracks don't remove listener\n  this.player_.off('timeupdate', vjs.bind(this, this.update, this.id_));\n  this.player_.off('ended', vjs.bind(this, this.reset, this.id_));\n  this.reset(); // Reset\n\n  // Remove from display\n  this.player_.getChild('textTrackDisplay').removeChild(this);\n};\n\n// A readiness state\n// One of the following:\n//\n// Not loaded\n// Indicates that the text track is known to exist (e.g. it has been declared with a track element), but its cues have not been obtained.\n//\n// Loading\n// Indicates that the text track is loading and there have been no fatal errors encountered so far. Further cues might still be added to the track.\n//\n// Loaded\n// Indicates that the text track has been loaded with no fatal errors. No new cues will be added to the track except if the text track corresponds to a MutableTextTrack object.\n//\n// Failed to load\n// Indicates that the text track was enabled, but when the user agent attempted to obtain it, this failed in some way (e.g. URL could not be resolved, network error, unknown text track format). Some or all of the cues are likely missing and will not be obtained.\nvjs.TextTrack.prototype.load = function(){\n\n  // Only load if not loaded yet.\n  if (this.readyState_ === 0) {\n    this.readyState_ = 1;\n    vjs.get(this.src_, vjs.bind(this, this.parseCues), vjs.bind(this, this.onError));\n  }\n\n};\n\nvjs.TextTrack.prototype.onError = function(err){\n  this.error = err;\n  this.readyState_ = 3;\n  this.trigger('error');\n};\n\n// Parse the WebVTT text format for cue times.\n// TODO: Separate parser into own class so alternative timed text formats can be used. (TTML, DFXP)\nvjs.TextTrack.prototype.parseCues = function(srcContent) {\n  var cue, time, text,\n      lines = srcContent.split('\\n'),\n      line = '', id;\n\n  for (var i=1, j=lines.length; i<j; i++) {\n    // Line 0 should be 'WEBVTT', so skipping i=0\n\n    line = vjs.trim(lines[i]); // Trim whitespace and linebreaks\n\n    if (line) { // Loop until a line with content\n\n      // First line could be an optional cue ID\n      // Check if line has the time separator\n      if (line.indexOf('-->') == -1) {\n        id = line;\n        // Advance to next line for timing.\n        line = vjs.trim(lines[++i]);\n      } else {\n        id = this.cues_.length;\n      }\n\n      // First line - Number\n      cue = {\n        id: id, // Cue Number\n        index: this.cues_.length // Position in Array\n      };\n\n      // Timing line\n      time = line.split(' --> ');\n      cue.startTime = this.parseCueTime(time[0]);\n      cue.endTime = this.parseCueTime(time[1]);\n\n      // Additional lines - Cue Text\n      text = [];\n\n      // Loop until a blank line or end of lines\n      // Assumeing trim('') returns false for blank lines\n      while (lines[++i] && (line = vjs.trim(lines[i]))) {\n        text.push(line);\n      }\n\n      cue.text = text.join('<br/>');\n\n      // Add this cue\n      this.cues_.push(cue);\n    }\n  }\n\n  this.readyState_ = 2;\n  this.trigger('loaded');\n};\n\n\nvjs.TextTrack.prototype.parseCueTime = function(timeText) {\n  var parts = timeText.split(':'),\n      time = 0,\n      hours, minutes, other, seconds, ms;\n\n  // Check if optional hours place is included\n  // 00:00:00.000 vs. 00:00.000\n  if (parts.length == 3) {\n    hours = parts[0];\n    minutes = parts[1];\n    other = parts[2];\n  } else {\n    hours = 0;\n    minutes = parts[0];\n    other = parts[1];\n  }\n\n  // Break other (seconds, milliseconds, and flags) by spaces\n  // TODO: Make additional cue layout settings work with flags\n  other = other.split(/\\s+/);\n  // Remove seconds. Seconds is the first part before any spaces.\n  seconds = other.splice(0,1)[0];\n  // Could use either . or , for decimal\n  seconds = seconds.split(/\\.|,/);\n  // Get milliseconds\n  ms = parseFloat(seconds[1]);\n  seconds = seconds[0];\n\n  // hours => seconds\n  time += parseFloat(hours) * 3600;\n  // minutes => seconds\n  time += parseFloat(minutes) * 60;\n  // Add seconds\n  time += parseFloat(seconds);\n  // Add milliseconds\n  if (ms) { time += ms/1000; }\n\n  return time;\n};\n\n// Update active cues whenever timeupdate events are triggered on the player.\nvjs.TextTrack.prototype.update = function(){\n  if (this.cues_.length > 0) {\n\n    // Get curent player time\n    var time = this.player_.currentTime();\n\n    // Check if the new time is outside the time box created by the the last update.\n    if (this.prevChange === undefined || time < this.prevChange || this.nextChange <= time) {\n      var cues = this.cues_,\n\n          // Create a new time box for this state.\n          newNextChange = this.player_.duration(), // Start at beginning of the timeline\n          newPrevChange = 0, // Start at end\n\n          reverse = false, // Set the direction of the loop through the cues. Optimized the cue check.\n          newCues = [], // Store new active cues.\n\n          // Store where in the loop the current active cues are, to provide a smart starting point for the next loop.\n          firstActiveIndex, lastActiveIndex,\n          cue, i; // Loop vars\n\n      // Check if time is going forwards or backwards (scrubbing/rewinding)\n      // If we know the direction we can optimize the starting position and direction of the loop through the cues array.\n      if (time >= this.nextChange || this.nextChange === undefined) { // NextChange should happen\n        // Forwards, so start at the index of the first active cue and loop forward\n        i = (this.firstActiveIndex !== undefined) ? this.firstActiveIndex : 0;\n      } else {\n        // Backwards, so start at the index of the last active cue and loop backward\n        reverse = true;\n        i = (this.lastActiveIndex !== undefined) ? this.lastActiveIndex : cues.length - 1;\n      }\n\n      while (true) { // Loop until broken\n        cue = cues[i];\n\n        // Cue ended at this point\n        if (cue.endTime <= time) {\n          newPrevChange = Math.max(newPrevChange, cue.endTime);\n\n          if (cue.active) {\n            cue.active = false;\n          }\n\n          // No earlier cues should have an active start time.\n          // Nevermind. Assume first cue could have a duration the same as the video.\n          // In that case we need to loop all the way back to the beginning.\n          // if (reverse && cue.startTime) { break; }\n\n        // Cue hasn't started\n        } else if (time < cue.startTime) {\n          newNextChange = Math.min(newNextChange, cue.startTime);\n\n          if (cue.active) {\n            cue.active = false;\n          }\n\n          // No later cues should have an active start time.\n          if (!reverse) { break; }\n\n        // Cue is current\n        } else {\n\n          if (reverse) {\n            // Add cue to front of array to keep in time order\n            newCues.splice(0,0,cue);\n\n            // If in reverse, the first current cue is our lastActiveCue\n            if (lastActiveIndex === undefined) { lastActiveIndex = i; }\n            firstActiveIndex = i;\n          } else {\n            // Add cue to end of array\n            newCues.push(cue);\n\n            // If forward, the first current cue is our firstActiveIndex\n            if (firstActiveIndex === undefined) { firstActiveIndex = i; }\n            lastActiveIndex = i;\n          }\n\n          newNextChange = Math.min(newNextChange, cue.endTime);\n          newPrevChange = Math.max(newPrevChange, cue.startTime);\n\n          cue.active = true;\n        }\n\n        if (reverse) {\n          // Reverse down the array of cues, break if at first\n          if (i === 0) { break; } else { i--; }\n        } else {\n          // Walk up the array fo cues, break if at last\n          if (i === cues.length - 1) { break; } else { i++; }\n        }\n\n      }\n\n      this.activeCues_ = newCues;\n      this.nextChange = newNextChange;\n      this.prevChange = newPrevChange;\n      this.firstActiveIndex = firstActiveIndex;\n      this.lastActiveIndex = lastActiveIndex;\n\n      this.updateDisplay();\n\n      this.trigger('cuechange');\n    }\n  }\n};\n\n// Add cue HTML to display\nvjs.TextTrack.prototype.updateDisplay = function(){\n  var cues = this.activeCues_,\n      html = '',\n      i=0,j=cues.length;\n\n  for (;i<j;i++) {\n    html += '<span class=\"vjs-tt-cue\">'+cues[i].text+'</span>';\n  }\n\n  this.el_.innerHTML = html;\n};\n\n// Set all loop helper values back\nvjs.TextTrack.prototype.reset = function(){\n  this.nextChange = 0;\n  this.prevChange = this.player_.duration();\n  this.firstActiveIndex = 0;\n  this.lastActiveIndex = 0;\n};\n\n// Create specific track types\n/**\n * @constructor\n */\nvjs.CaptionsTrack = vjs.TextTrack.extend();\nvjs.CaptionsTrack.prototype.kind_ = 'captions';\n// Exporting here because Track creation requires the track kind\n// to be available on global object. e.g. new window['videojs'][Kind + 'Track']\n\n/**\n * @constructor\n */\nvjs.SubtitlesTrack = vjs.TextTrack.extend();\nvjs.SubtitlesTrack.prototype.kind_ = 'subtitles';\n\n/**\n * @constructor\n */\nvjs.ChaptersTrack = vjs.TextTrack.extend();\nvjs.ChaptersTrack.prototype.kind_ = 'chapters';\n\n\n/* Text Track Display\n============================================================================= */\n// Global container for both subtitle and captions text. Simple div container.\n\n/**\n * @constructor\n */\nvjs.TextTrackDisplay = vjs.Component.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    vjs.Component.call(this, player, options, ready);\n\n    // This used to be called during player init, but was causing an error\n    // if a track should show by default and the display hadn't loaded yet.\n    // Should probably be moved to an external track loader when we support\n    // tracks that don't need a display.\n    if (player.options_['tracks'] && player.options_['tracks'].length > 0) {\n      this.player_.addTextTracks(player.options_['tracks']);\n    }\n  }\n});\n\nvjs.TextTrackDisplay.prototype.createEl = function(){\n  return vjs.Component.prototype.createEl.call(this, 'div', {\n    className: 'vjs-text-track-display'\n  });\n};\n\n\n/* Text Track Menu Items\n============================================================================= */\n/**\n * @constructor\n */\nvjs.TextTrackMenuItem = vjs.MenuItem.extend({\n  /** @constructor */\n  init: function(player, options){\n    var track = this.track = options['track'];\n\n    // Modify options for parent MenuItem class's init.\n    options['label'] = track.label();\n    options['selected'] = track.dflt();\n    vjs.MenuItem.call(this, player, options);\n\n    this.player_.on(track.kind() + 'trackchange', vjs.bind(this, this.update));\n  }\n});\n\nvjs.TextTrackMenuItem.prototype.onClick = function(){\n  vjs.MenuItem.prototype.onClick.call(this);\n  this.player_.showTextTrack(this.track.id_, this.track.kind());\n  if (typeof(jQuery.publish) === \"function\") {\n      var label = this.track.label();\n      jQuery.publish('captions_toggled', [label]);\n    }\n};\n\nvjs.TextTrackMenuItem.prototype.update = function(){\n  this.selected(this.track.mode() == 2);\n};\n\n/**\n * @constructor\n */\nvjs.OffTextTrackMenuItem = vjs.TextTrackMenuItem.extend({\n  /** @constructor */\n  init: function(player, options){\n    // Create pseudo track info\n    // Requires options['kind']\n    options['track'] = {\n      kind: function() { return options['kind']; },\n      player: player,\n      label: function(){ return options['kind'] + ' off'; },\n      dflt: function(){ return false; },\n      mode: function(){ return false; }\n    };\n    vjs.TextTrackMenuItem.call(this, player, options);\n    this.selected(true);\n  }\n});\n\nvjs.OffTextTrackMenuItem.prototype.onClick = function(){\n  vjs.TextTrackMenuItem.prototype.onClick.call(this);\n  this.player_.showTextTrack(this.track.id_, this.track.kind());\n};\n\nvjs.OffTextTrackMenuItem.prototype.update = function(){\n  var tracks = this.player_.textTracks(),\n      i=0, j=tracks.length, track,\n      off = true;\n\n  for (;i<j;i++) {\n    track = tracks[i];\n    if (track.kind() == this.track.kind() && track.mode() == 2) {\n      off = false;\n    }\n  }\n\n  this.selected(off);\n};\n\n/* Captions Button\n================================================================================ */\n/**\n * @constructor\n */\nvjs.TextTrackButton = vjs.MenuButton.extend({\n  /** @constructor */\n  init: function(player, options){\n    vjs.MenuButton.call(this, player, options);\n\n    if (this.items.length <= 1) {\n      this.hide();\n    }\n  }\n});\n\n// vjs.TextTrackButton.prototype.buttonPressed = false;\n\n// vjs.TextTrackButton.prototype.createMenu = function(){\n//   var menu = new vjs.Menu(this.player_);\n\n//   // Add a title list item to the top\n//   // menu.el().appendChild(vjs.createEl('li', {\n//   //   className: 'vjs-menu-title',\n//   //   innerHTML: vjs.capitalize(this.kind_),\n//   //   tabindex: -1\n//   // }));\n\n//   this.items = this.createItems();\n\n//   // Add menu items to the menu\n//   for (var i = 0; i < this.items.length; i++) {\n//     menu.addItem(this.items[i]);\n//   }\n\n//   // Add list to element\n//   this.addChild(menu);\n\n//   return menu;\n// };\n\n// Create a menu item for each text track\nvjs.TextTrackButton.prototype.createItems = function(){\n  var items = [], track;\n\n  // Add an OFF menu item to turn all tracks off\n  items.push(new vjs.OffTextTrackMenuItem(this.player_, { 'kind': this.kind_ }));\n\n  for (var i = 0; i < this.player_.textTracks().length; i++) {\n    track = this.player_.textTracks()[i];\n    if (track.kind() === this.kind_) {\n      items.push(new vjs.TextTrackMenuItem(this.player_, {\n        'track': track\n      }));\n    }\n  }\n\n  return items;\n};\n\n/**\n * @constructor\n */\nvjs.CaptionsButton = vjs.TextTrackButton.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    vjs.TextTrackButton.call(this, player, options, ready);\n    this.el_.setAttribute('aria-label','Captions Menu');\n  }\n});\nvjs.CaptionsButton.prototype.kind_ = 'captions';\nvjs.CaptionsButton.prototype.buttonText = 'Captions';\nvjs.CaptionsButton.prototype.className = 'vjs-captions-button';\n\n/**\n * @constructor\n */\nvjs.SubtitlesButton = vjs.TextTrackButton.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    vjs.TextTrackButton.call(this, player, options, ready);\n    this.el_.setAttribute('aria-label','Subtitles Menu');\n  }\n});\nvjs.SubtitlesButton.prototype.kind_ = 'subtitles';\nvjs.SubtitlesButton.prototype.buttonText = 'Subtitles';\nvjs.SubtitlesButton.prototype.className = 'vjs-subtitles-button';\n\n// Chapters act much differently than other text tracks\n// Cues are navigation vs. other tracks of alternative languages\n/**\n * @constructor\n */\nvjs.ChaptersButton = vjs.TextTrackButton.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    vjs.TextTrackButton.call(this, player, options, ready);\n    this.el_.setAttribute('aria-label','Chapters Menu');\n  }\n});\nvjs.ChaptersButton.prototype.kind_ = 'chapters';\nvjs.ChaptersButton.prototype.buttonText = 'Chapters';\nvjs.ChaptersButton.prototype.className = 'vjs-chapters-button';\n\n// Create a menu item for each text track\nvjs.ChaptersButton.prototype.createItems = function(){\n  var items = [], track;\n\n  for (var i = 0; i < this.player_.textTracks().length; i++) {\n    track = this.player_.textTracks()[i];\n    if (track.kind() === this.kind_) {\n      items.push(new vjs.TextTrackMenuItem(this.player_, {\n        'track': track\n      }));\n    }\n  }\n\n  return items;\n};\n\nvjs.ChaptersButton.prototype.createMenu = function(){\n  var tracks = this.player_.textTracks(),\n      i = 0,\n      j = tracks.length,\n      track, chaptersTrack,\n      items = this.items = [];\n\n  for (;i<j;i++) {\n    track = tracks[i];\n    if (track.kind() == this.kind_ && track.dflt()) {\n      if (track.readyState() < 2) {\n        this.chaptersTrack = track;\n        track.on('loaded', vjs.bind(this, this.createMenu));\n        return;\n      } else {\n        chaptersTrack = track;\n        break;\n      }\n    }\n  }\n\n  var menu = this.menu = new vjs.Menu(this.player_);\n\n  menu.el_.appendChild(vjs.createEl('li', {\n    className: 'vjs-menu-title',\n    innerHTML: vjs.capitalize(this.kind_),\n    tabindex: -1\n  }));\n\n  if (chaptersTrack) {\n    var cues = chaptersTrack.cues_, cue, mi;\n    i = 0;\n    j = cues.length;\n\n    for (;i<j;i++) {\n      cue = cues[i];\n\n      mi = new vjs.ChaptersTrackMenuItem(this.player_, {\n        'track': chaptersTrack,\n        'cue': cue\n      });\n\n      items.push(mi);\n\n      menu.addChild(mi);\n    }\n  }\n\n  if (this.items.length > 0) {\n    this.show();\n  }\n\n  return menu;\n};\n\n\n/**\n * @constructor\n */\nvjs.ChaptersTrackMenuItem = vjs.MenuItem.extend({\n  /** @constructor */\n  init: function(player, options){\n    var track = this.track = options['track'],\n        cue = this.cue = options['cue'],\n        currentTime = player.currentTime();\n\n    // Modify options for parent MenuItem class's init.\n    options['label'] = cue.text;\n    options['selected'] = (cue.startTime <= currentTime && currentTime < cue.endTime);\n    vjs.MenuItem.call(this, player, options);\n\n    track.on('cuechange', vjs.bind(this, this.update));\n  }\n});\n\nvjs.ChaptersTrackMenuItem.prototype.onClick = function(){\n  vjs.MenuItem.prototype.onClick.call(this);\n  this.player_.currentTime(this.cue.startTime);\n  this.update(this.cue.startTime);\n};\n\nvjs.ChaptersTrackMenuItem.prototype.update = function(){\n  var cue = this.cue,\n      currentTime = this.player_.currentTime();\n\n  // vjs.log(currentTime, cue.startTime);\n  this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);\n};\n\n// Add Buttons to controlBar\nvjs.obj.merge(vjs.ControlBar.prototype.options_['children'], {\n  'subtitlesButton': {},\n  'captionsButton': {},\n  'chaptersButton': {}\n});\n\n// vjs.Cue = vjs.Component.extend({\n//   /** @constructor */\n//   init: function(player, options){\n//     vjs.Component.call(this, player, options);\n//   }\n// });\n/**\n * @fileoverview Add JSON support\n * @suppress {undefinedVars}\n * (Compiler doesn't like JSON not being declared)\n */\n\n/**\n * Javascript JSON implementation\n * (Parse Method Only)\n * https://github.com/douglascrockford/JSON-js/blob/master/json2.js\n * Only using for parse method when parsing data-setup attribute JSON.\n * @type {Object}\n * @suppress {undefinedVars}\n */\nvjs.JSON;\n\n/**\n * @suppress {undefinedVars}\n */\nif (typeof window.JSON !== 'undefined' && window.JSON.parse === 'function') {\n  vjs.JSON = window.JSON;\n\n} else {\n  vjs.JSON = {};\n\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\n  vjs.JSON.parse = function (text, reviver) {\n      var j;\n\n      function walk(holder, key) {\n          var k, v, value = holder[key];\n          if (value && typeof value === 'object') {\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = walk(value, k);\n                      if (v !== undefined) {\n                          value[k] = v;\n                      } else {\n                          delete value[k];\n                      }\n                  }\n              }\n          }\n          return reviver.call(holder, key, value);\n      }\n      text = String(text);\n      cx.lastIndex = 0;\n      if (cx.test(text)) {\n          text = text.replace(cx, function (a) {\n              return '\\\\u' +\n                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n          });\n      }\n\n      if (/^[\\],:{}\\s]*$/\n              .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n                  .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n                  .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n          j = eval('(' + text + ')');\n\n          return typeof reviver === 'function' ?\n              walk({'': j}, '') : j;\n      }\n\n      throw new SyntaxError('JSON.parse(): invalid or malformed JSON data');\n  };\n}\n/**\n * @fileoverview Functions for automatically setting up a player\n * based on the data-setup attribute of the video tag\n */\n\n// Automatically set up any tags that have a data-setup attribute\nvjs.autoSetup = function(){\n  var options, vid, player,\n      vids = document.getElementsByTagName('video');\n\n  // Check if any media elements exist\n  if (vids && vids.length > 0) {\n\n    for (var i=0,j=vids.length; i<j; i++) {\n      vid = vids[i];\n\n      // Check if element exists, has getAttribute func.\n      // IE seems to consider typeof el.getAttribute == 'object' instead of 'function' like expected, at least when loading the player immediately.\n      if (vid && vid.getAttribute) {\n\n        // Make sure this player hasn't already been set up.\n        if (vid['player'] === undefined) {\n          options = vid.getAttribute('data-setup');\n\n          // Check if data-setup attr exists.\n          // We only auto-setup if they've added the data-setup attr.\n          if (options !== null) {\n\n            // Parse options JSON\n            // If empty string, make it a parsable json object.\n            options = vjs.JSON.parse(options || '{}');\n\n            // Create new video.js instance.\n            player = videojs(vid, options);\n          }\n        }\n\n      // If getAttribute isn't defined, we need to wait for the DOM.\n      } else {\n        vjs.autoSetupTimeout(1);\n        break;\n      }\n    }\n\n  // No videos were found, so keep looping unless page is finisehd loading.\n  } else if (!vjs.windowLoaded) {\n    vjs.autoSetupTimeout(1);\n  }\n};\n\n// Pause to let the DOM keep processing\nvjs.autoSetupTimeout = function(wait){\n  setTimeout(vjs.autoSetup, wait);\n};\n\nif (document.readyState === 'complete') {\n  vjs.windowLoaded = true;\n} else {\n  vjs.one(window, 'load', function(){\n    vjs.windowLoaded = true;\n  });\n}\n\n// Run Auto-load players\n// You have to wait at least once in case this script is loaded after your video in the DOM (weird behavior only with minified version)\nvjs.autoSetupTimeout(1);\nvjs.plugin = function(name, init){\n  vjs.Player.prototype[name] = init;\n};\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = __webpack_provided_window_dot_videojs;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/static/vendors/development/video.dev.js */ \"./src/static/vendors/development/video.dev.js\")))\n\n//# sourceURL=webpack:///./src/static/vendors/development/video.dev.js?");

/***/ }),

/***/ "./src/static/vendors/development/videojs-annotator-plugin.js":
/*!********************************************************************!*\
  !*** ./src/static/vendors/development/videojs-annotator-plugin.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(videojs) {var Annotator =  true ? __webpack_require__(/*! annotator */ \"./src/static/vendors/Annotator/annotator-full.js\").Annotator : undefined;\n\n// ----------------Utilities---------------- //\nvar _ref;\nvar __bind = function(fn, me) { \n    return function() { \n        return fn.apply(me, arguments); \n    }; \n};\nvar __hasProp = {}.hasOwnProperty;\nvar __extends = function(child, parent) { \n    for (var key in parent) { \n        if (__hasProp.call(parent, key)) \n            child[key] = parent[key]; \n    } \n    function ctor() { \n        this.constructor = child; \n    } \n\n    ctor.prototype = parent.prototype; \n    child.prototype = new ctor(); \n    child.__super__ = parent.prototype; \n    return child; \n};\nvar createDateFromISO8601 = function(string) {\n  var d, date, offset, regexp, time, _ref;\n  regexp = \"([0-9]{4})(-([0-9]{2})(-([0-9]{2})\" + \"(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\\\\.([0-9]+))?)?\" + \"(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?\";\n  d = string.match(new RegExp(regexp));\n  offset = 0;\n  date = new Date(d[1], 0, 1);\n  if (d[3]) {\n    date.setMonth(d[3] - 1);\n  }\n  if (d[5]) {\n    date.setDate(d[5]);\n  }\n  if (d[7]) {\n    date.setHours(d[7]);\n  }\n  if (d[8]) {\n    date.setMinutes(d[8]);\n  }\n  if (d[10]) {\n    date.setSeconds(d[10]);\n  }\n  if (d[12]) {\n    date.setMilliseconds(Number(\"0.\" + d[12]) * 1000);\n  }\n  if (d[14]) {\n    offset = (Number(d[16]) * 60) + Number(d[17]);\n    offset *= (_ref = d[15] === '-') != null ? _ref : {\n      1: -1\n    };\n  }\n  offset -= date.getTimezoneOffset();\n  time = Number(date) + (offset * 60 * 1000);\n  date.setTime(Number(time));\n  return date;\n};\nvar Util = typeof Util != 'undefined' ? Util : {};\nUtil.mousePosition = function(e, offsetEl) {\n  var offset, _ref1;\n  if ((_ref1 = $(offsetEl).css('position')) !== 'absolute' && _ref1 !== 'fixed' && _ref1 !== 'relative') {\n    offsetEl = $(offsetEl).offsetParent()[0];\n  }\n  offset = $(offsetEl).offset();\n  return {\n    top: e.pageY - offset.top,\n    left: e.pageX - offset.left\n  };\n};\n\n\n\n\n// ----------------Load videojs-Annotation Plugin---------------- //\n(function () {\n    // -- Load Annotation plugin in videojs\n    function vjsAnnotation_(options){\n        var player = this;\n    \n        // variables to know if it is ready\n    \n        player.annotations = new vjsAnnotation(player, options);\n    \n        // When the DOM, Range Slider and the video media is loaded\n        function initialVideoFinished(event) {\n            // -- wait for plugins -- //\n            var wrapper = $('.annotator-wrapper').parent()[0];\n            var annotator = $.data(wrapper, 'annotator');\n            \n            // wait for Annotator and the Share plugin\n            if (typeof Annotator.Plugin[\"Share\"] === 'function') {\n                if (typeof annotator.isShareLoaded != 'undefined' && annotator.isShareLoaded) {\n                    annotator.unsubscribe('shareloaded', initialVideoFinished);\n                } else {\n                    annotator.subscribe('shareloaded', initialVideoFinished);\n                    return false;\n                }\n            }\n        \n            var plugin = player.annotations;\n        \n            // All components will be initialize after they have been loaded by videojs\n            for (var index in plugin.components) {\n                plugin.components[index].init_();\n            }\n\n            player.annotations.AnConBut.show();\n            //player.annotations.BigNewAn.show();\n        \n            // set the position of the big buttom\n            plugin.setposBigNew(plugin.options.posBigNew);\n        \n            if(!options.showDisplay) \n                plugin.hideDisplay();\n            if(!options.showStatistics) \n                plugin.hideStatistics();\n        \n        \n            // Get current instance of annotator \n            player.annotator = annotator;\n            plugin.annotator = annotator;\n        \n            // get annotations\n            var allannotations = annotator.plugins['LocalStore'].annotations;\n            plugin.refreshDisplay();\n        \n            // -- Listener to Range Slider Plugin\n            player.rangeslider.rstb.on('mousedown', function(){plugin._onMouseDownRS(event)});\n            // Open the autoPlay from the API\n            if (player.autoPlayAPI) {\n                var OnePlay = function () {\n                    player.annotations.showAnnotation(player.autoPlayAPI);\n                    $('html, body').animate({\n                        scrollTop: $(\"#\" + player.id_).offset().top},\n                        'slow');\n                };\n                if (player.techName == 'Youtube')\n                    setTimeout(OnePlay, 100); // fix the delay playing youtube\n                else\n                    OnePlay();\n            }\n        \n            // set the number of Annotations to display\n            plugin.refreshDesignPanel();\n        \n            // check full-screen change\n            player.on('fullscreenchange', function() {\n                if (player.isFullScreen) {\n                    $(player.annotator.wrapper[0]).addClass('vjs-fullscreen');\n                } else {\n                    $(player.annotator.wrapper[0]).removeClass('vjs-fullscreen');\n                }\n                plugin.refreshDesignPanel();\n            });\n        \n            // loaded plugin\n            plugin.loaded = true;\n        }\n        player.one('loadedRangeSlider', initialVideoFinished); // Loaded RangeSlider\n    \n        //console.log(\"Loaded Annotation Plugin\");\n    }\n    videojs.plugin('annotations', vjsAnnotation_);\n\n\n    // -- Plugin\n    function vjsAnnotation(player, options) {\n        var player = player || this;\n    \n        this.player = player;\n        \n        this.components = {}; // holds any custom components we add to the player\n\n        options = options || {}; // plugin options\n        \n        if(!options.hasOwnProperty('posBigNew')) \n            options.posBigNew = 'none'; // ul = up left || ur = up right || bl = below left || br = below right || c = center\n        if(!options.hasOwnProperty('showDisplay')) \n            options.showDisplay = false; \n        if(!options.hasOwnProperty('showStatistics')) \n            options.showStatistics = false; \n        \n        this.options = options;\n    \n        this.init();\n    }\n\n    // -- Methods\n    vjsAnnotation.prototype = {\n        /* Constructor */\n        init: function() {\n            var player = this.player || {};\n            var controlBar = player.controlBar;\n            var seekBar = player.controlBar.progressControl.seekBar;\n                \n            this.updatePrecision = 3;\n            \n            // Components and Quick Aliases\n            //this.BigNewAn = this.components.BigNewAnnotation = player.BigNewAnnotation;\n            this.AnConBut = this.components.AnContainerButtons = player.AnContainerButtons;\n            this.ShowSt = this.components.ShowStatistics = this.AnConBut.ShowStatistics;\n            this.NewAn = this.components.NewAnnotation = this.AnConBut.NewAnnotation;\n            this.ShowAn =this.components.ShowAnnotations = this.AnConBut.ShowAnnotations;\n            this.BackAnDisplay = this.components.BackAnDisplay = controlBar.BackAnDisplay; // Background of the panel\n            this.AnDisplay = this.components.AnDisplay = controlBar.BackAnDisplay.AnDisplay; // Panel with all the annotations\n            this.AnStat = this.components.AnStat = controlBar.BackAnDisplay.AnStat; // Panel with statistics of the number of annotations\n            this.BackAnDisplayScroll = this.components.BackAnDisplayScroll = controlBar.BackAnDisplayScroll; // Back Panel with all the annotations\n            this.backDSBar = this.components.BackAnDisplayScrollBar = this.BackAnDisplayScroll.BackAnDisplayScrollBar; // Scroll Bar\n            this.backDSBarSel = this.components.ScrollBarSelector = this.backDSBar.ScrollBarSelector; // Scroll Bar Selector\n            this.backDSTime = this.components.BackAnDisplayScrollTime = this.BackAnDisplayScroll.BackAnDisplayScrollTime; // Back Panel with time of the annotations in the scroll\n            this.rsd = this.components.RangeSelectorDisplay = controlBar.BackAnDisplay.RangeSelectorDisplay; // Selection the time to display the annotations\n            this.rsdl = this.components.RangeSelectorLeft = this.rsd.RangeSelectorLeft;\n            this.rsdr = this.components.RangeSelectorRight = this.rsd.RangeSelectorRight;\n            this.rsdb = this.components.RangeSelectorBar = this.rsd.RangeSelectorBar;\n            this.rsdbl = this.components.RangeSelectorBarL = this.rsdb.RangeSelectorBarL;\n            this.rsdbr = this.components.RangeSelectorBarR = this.rsdb.RangeSelectorBarR;\n            this.rs = player.rangeslider;\n            \n            // local variables\n            this.editing = false;\n            \n            var wrapper = $('.annotator-wrapper').parent()[0];\n            var annotator = $.data(wrapper, 'annotator');\n            var self = this;\n            // Subscribe to Annotator changes\n            annotator.subscribe(\"annotationsLoaded\", function (annotations) {\n                if(self.loaded)\n                    self.refreshDisplay();\n            });\n            annotator.subscribe(\"annotationUpdated\", function (annotation) {\n               if(self.loaded)\n                    self.refreshDisplay();\n            });\n            annotator.subscribe(\"annotationDeleted\", function (annotation) {\n                var annotations = annotator.plugins['LocalStore'].annotations;\n                var tot = typeof annotations !== 'undefined' ? annotations.length : 0;\n                var attempts = 0; // max 100\n                // This is to watch the annotations object, to see when is deleted the annotation\n                var ischanged = function() {\n                    var new_tot = annotator.plugins['LocalStore'].annotations.length;\n                    if (attempts < 100)\n                        setTimeout(function(){\n                            if (new_tot !== tot) {\n                                if(self.loaded)\n                                    self.refreshDisplay();\n                            } else {\n                                attempts++;\n                                ischanged();\n                            }\n                        }, 100); // wait for the change in the annotations\n                };\n                ischanged();\n            });\n            this.AnConBut.hide();\n           // this.BigNewAn.hide(); // Hide until the video is load\n        },\n        newan: function(start, end) {\n            var player = this.player;\n            var annotator = this.annotator;\n            var sumPercent = 10; // percentage for the last mark\n            var currentTime = player.currentTime();\n            var lastTime = this._sumPercent(currentTime, sumPercent); \n            \n            var start = typeof start !== 'undefined' ? start : currentTime;\n            var end = typeof end !== 'undefined' ? end : lastTime;\n                \n            this._reset();\n            \n            // set position RS and pause the player\n            player.showSlider();\n            player.pause();\n            \n            player.setValueSlider(start, end);\n            \n            // This variable is to say the editor that we want create a VideoJS annotation\n            annotator.editor.VideoJS = this.player.id_;\n            \n            annotator.adder.show();\n            \n            this._setOverRS(annotator.adder);\n\n            // Open a new annotator dialog\n            annotator.onAdderClick();\n        },\n        showDisplay: function() {\n            this._reset();\n            // show\n            this.BackAnDisplay.removeClass('disable'); // show the Container\n            this.BackAnDisplayScroll.removeClass('disable'); // show the scroll\n            // active button\n            this.ShowAn.addClass('active');\n            this.options.showDisplay =true;\n            console.log(this);\n            jQuery(this.player).trigger('annotationsDisplayed');\n        },\n        hideDisplay: function() {\n            // hide\n            this.BackAnDisplay.addClass('disable'); // hide the Container\n            this.BackAnDisplayScroll.addClass('disable'); // hide the scroll\n            // no active button\n            videojs.removeClass(this.ShowAn.el_, 'active');\n            this.options.showDisplay =false;\n        },\n        showStatistics: function() {\n            this._reset();\n            // show\n            this.BackAnDisplay.removeClass('disable'); // show the Container\n            this.AnStat.removeClass('disable'); // show Statistics\n            // mode (this mode will hide the annotations to show the statistics in the container)\n            this.BackAnDisplay.addClass('statistics'); // mode statistics \n            // paint\n            this.AnStat.paintCanvas(); // refresh canvas\n            // active button\n            this.ShowSt.addClass('active');\n            this.options.showStatistics =true;\n        },\n        hideStatistics: function() {\n            // hide\n            this.BackAnDisplay.addClass('disable'); // hide the Container\n            this.AnStat.addClass('disable'); // hide Statistics\n            // remove mode statistics\n            this.BackAnDisplay.removeClass('statistics');\n            // no active button\n            this.ShowSt.removeClass('active');\n            this.options.showStatistics = false;\n        },\n        showAnnotation: function(annotation) {\n            var isVideo = this._isVideoJS(annotation);\n            if (isVideo) {\n                var start = annotation.rangeTime.start;\n                var end = annotation.rangeTime.end;\n                var duration = this.player.duration();\n                var isPoint = videojs.round(start, 3) == videojs.round(end, 3);\n                \n                this._reset();\n            \n                // show the range slider\n                this.rs.show();\n            \n                // set the slider position\n                this.rs.setValues(start, end);\n            \n                // lock the player        \n                this.rs.lock();\n                \n                // play\n                if (!isPoint)\n                    this.rs.playBetween(start, end);\n                    \n                // fix small bar\n                var width = Math.min(1, Math.max(0.005, (this.rs._percent(end - start)))) * 100;\n                this.rs.bar.el_.style.width = width + '%';\n                    \n                // Add the annotation object to the bar \n                var bar = isPoint ? this.rs[((duration - start) / duration < 0.1) ? 'left' : 'right'].el_ : this.rs.bar.el_;\n                var holder = $(this.rs.left.el_).parent()[0];\n                $(holder).append('<span class=\"annotator-hl\"></div>');\n                $(bar).appendTo( $(holder).find('.annotator-hl'));\n            \n                var span = $(bar).parent()[0];\n                $.data(span, 'annotation', annotation); // Set the object in the span\n            \n                // set the editor over the range slider\n                this._setOverRS(this.annotator.editor.element);\n                this.annotator.editor.checkOrientation();\n            \n                // hide the panel\n                this.rs.hidePanel();\n            }\n        },\n        hideAnnotation: function() {\n            this.rs.hide();\n            this.rs.showPanel();\n            \n            // remove the last single showed annotation\n            var holder = $(this.rs.left.el_).parent()[0];\n            var holderRight = $(this.rs.right.el_).parent()[0];\n            if ($(holder).find('.annotator-hl').length > 0) {\n                $($(holder).find('.annotator-hl')[0].children[0]).appendTo(holder);\n                $(holder).find('.annotator-hl').remove();\n            } else if ($(holderRight).find('.annotator-hl').length > 0) {\n                $($(holderRight).find('.annotator-hl')[0].children[0]).appendTo(holderRight);\n                $(holderRight).find('.annotator-hl').remove();\n            }\n        },\n        editAnnotation: function(annotation, editor) {\n            // This will be usefull when we are going to edit an annotation.\n            if (this._isVideoJS(annotation)) {\n                this.hideDisplay();\n                var player = this.player;\n                var editor = editor || this.annotator.editor;\n                \n                // show the slider and set in the position\n                player.showSlider();\n                player.unlockSlider();\n                player.setValueSlider(annotation.rangeTime.start, annotation.rangeTime.end);\n                \n                // show the time panel\n                player.showSliderPanel();\n                \n                // set the editor over the range slider\n                this._setOverRS(editor.element);\n                editor.checkOrientation();\n                \n                // set the VideoJS variable\n                editor.VideoJS = player.id_;\n            }\n        },\n        refreshDisplay: function() {\n            var count = 0;\n            var allannotations = this.annotator.plugins['LocalStore'].annotations;\n            \n            // Sort by date the Array\n            this._sortByDate(allannotations);\n            \n            // reset the panel\n            $(this.AnDisplay.el_).find('span').remove(); // remove the last html items\n            $(this.player.el_).find('.vjs-anpanel-annotation .annotation').remove(); // remove a deleted annotation without span wrapper\n            \n            for (var item in allannotations) {\n                var an = allannotations[item];\n                \n                // check if the annotation is a video annotation\n                if (this._isVideoJS(an)){\n                    var div = document.createElement('div');\n                    var span = document.createElement('span');\n                    var start = this.rs._percent(an.rangeTime.start) * 100;\n                    var end = this.rs._percent(an.rangeTime.end) * 100;\n                    var width;\n                    span.appendChild(div);\n                    span.className = \"annotator-hl\";\n                    width = Math.min(100, Math.max(0.2, end - start));\n                    div.className = \"annotation\";\n                    div.id = count;\n                    div.style.top = count + \"em\";\n                    div.style.left = start + '%';\n                    div.style.width = width + '%';\n                    div.start = an.rangeTime.start;\n                    div.end = an.rangeTime.end;\n                    this.AnDisplay.el_.appendChild(span);\n                    \n                    // detect point annotations\n                    if (videojs.round(start, 0) == videojs.round(end, 0)) {\n                        $(div).css('width', '');\n                        $(div).addClass(\"point\");\n                    }\n                    \n                    // Set the object in the div\n                    $.data(span, 'annotation', an);\n                    // Add the highlights to the annotation\n                    an.highlights = $(span);\n                    \n                    count++;\n                }\n            };\n            var start = this.rs._seconds(parseFloat(this.rsdl.el_.style.left) / 100);\n            var end = this.rs._seconds(parseFloat(this.rsdr.el_.style.left) / 100);\n                \n            this.showBetween(start, end, this.rsdl.include, this.rsdr.include);\n        },\n        showBetween: function (start, end, includeLeft, includeRight) {\n            var duration = this.player.duration();\n            var start = start || 0;\n            var end = end || duration;\n            var annotationsHTML = $.makeArray($(this.player.el_).find('.vjs-anpanel-annotation .annotator-hl'));\n            var count = 0;\n            var wrapper = $('.annotator-wrapper').parent()[0];\n            var annotator = $.data(wrapper, 'annotator');\n            for (var index in annotationsHTML) {\n                var an = $.data(annotationsHTML[index], 'annotation');\n                var expressionLeft = includeLeft ? (an.rangeTime.end >= start) : (an.rangeTime.start >= start);\n                var expressionRight = includeRight ? (an.rangeTime.start <= end) : (an.rangeTime.end <= end);\n                if (this._isVideoJS(an) && expressionLeft && expressionRight && typeof an.highlights[0] !== 'undefined') {\n                    var annotationHTML = an.highlights[0].children[0];\n                    annotationHTML.style.marginTop = (-1 * parseFloat(annotationHTML.style.top) + count) + 'em';\n                    $(an.highlights[0]).show();\n                    annotator.publish('annotationShown', an.id);\n                    count++;\n                } else if (this._isVideoJS(an) && typeof an.highlights[0] !== 'undefined') {\n                    $(an.highlights[0]).hide();\n                    an.highlights[0].children[0].style.marginTop = '';\n                    annotator.publish('annotationHidden', an.id);\n                }\n            }\n            // Set the times in the scroll time panel\n            this.backDSTime.setTimes();\n        },\n        setposBigNew: function(pos) {\n            /*var pos = pos || 'ul';\n            var el = this.player.BigNewAnnotation.el_;\n            videojs.removeClass(el, 'ul');\n            videojs.removeClass(el, 'ur');\n            videojs.removeClass(el, 'c');\n            videojs.removeClass(el, 'bl');\n            videojs.removeClass(el, 'br');\n            videojs.addClass(el, pos);*/\n        },\n        pressedKey: function (key) {\n            var player = this.player;\n            var rs = this.player.rs;\n            if (typeof key !== 'undefined' && key == 73) { // -- i key\n                this._reset();\n                \n                // show slider\n                this.rs.show();\n                // hide other elements\n                this.rs._reset();\n                this.rs.setValue(0, player.currentTime());\n                this.rs.right.el_.style.visibility = 'hidden';\n                this.rs.tpr.el_.style.visibility = 'hidden';\n                this.rs.ctpr.el_.style.visibility = 'hidden';\n                this.rs.bar.el_.style.visibility = 'hidden';\n                this.lastStartbyKey = player.currentTime();\n            } else if (typeof key!='undefined' && key==79) { // -- o key\n                if (this.rs.bar.el_.style.visibility == 'hidden') { // the last action was to type the i key\n                    var start = this.lastStartbyKey != 'undefined' ? this.lastStartbyKey:0;\n                    this.newan(start, player.currentTime());\n                } else {\n                    this.newan(player.currentTime(), player.currentTime());\n                }\n            }\n        },\n        refreshDesignPanel: function() {\n            var player = this.player;\n            var emtoPx = parseFloat($(this.backDSBar.el_).css('width'));\n            var playerHeight = parseFloat($(player.el_).css('height'));\n            var controlBarHeight = parseFloat($(player.controlBar.el_).css('height'));\n            var newHeight = (playerHeight - controlBarHeight - 80) / emtoPx - 5;\n            this.BackAnDisplay.el_.style.height = this.backDSBar.el_.style.height = (newHeight + 'em');\n            this.BackAnDisplay.el_.style.top = this.backDSBar.el_.style.top = \"-\" + (newHeight + 3 + 'em');\n            this.BackAnDisplayScroll.el_.children[0].style.top = \"-\" + (newHeight + 5 + 'em');\n            this.backDSTime.el_.children[0].style.top = \"-\" + (newHeight + 5 + 'em');\n        },\n        _reset: function() {\n            // Hide all the components\n            this.hideDisplay();\n            this.hideAnnotation();\n            this.hideStatistics();\n            this.player.annotator.adder.hide(); \n            this.player.annotator.editor.hide();\n            this.player.annotator.viewer.hide();\n            \n            // make visible all the range slider element that maybe were hidden in pressedKey event\n            this.rs.right.el_.style.visibility = '';\n            this.rs.tpr.el_.style.visibility = '';\n            this.rs.ctpr.el_.style.visibility = '';\n            this.rs.bar.el_.style.visibility = '';\n            \n            // by default the range slider must be unlocked\n            this.rs.unlock();\n            \n            // whether there is a playing selection\n            this.rs.bar.suspendPlay(); \n            \n            // refresh the design\n            this.refreshDesignPanel();\n        },\n        _setOverRS: function(elem) {\n            var annotator = this.player.annotator;\n            var wrapper = $('.annotator-wrapper')[0];\n            var positionLeft = videojs.findPosition(this.rs.left.el_);\n            var positionRight = videojs.findPosition(this.rs.right.el_);\n            var positionAnnotator = videojs.findPosition(wrapper);\n            var positionAdder = {};\n                \n            elem[0].style.display = 'block'; // Show the adder\n            \n            if (this.player.isFullScreen) {\n                positionAdder.top = positionLeft.top;\n                positionAdder.left = positionLeft.left + (positionRight.left - positionLeft.left) / 2;\n            } else {\n                positionAdder.left = positionLeft.left + (positionRight.left - positionLeft.left) / 2 - positionAnnotator.left;\n                positionAdder.top = positionLeft.top - positionAnnotator.top;\n            }\n            \n            elem.css(positionAdder);\n        },\n        _onMouseDownRS: function(event) {\n            event.preventDefault();\n        \n            if (!this.rs.options.locked) {\n                videojs.on(document, \"mousemove\", videojs.bind(this, this._onMouseMoveRS));\n                videojs.on(document, \"mouseup\", videojs.bind(this, this._onMouseUpRS));\n            }\n        },\n        _onMouseMoveRS: function(event) {\n            var player = this.player;\n            var annotator = player.annotator;\n            var rs = player.rangeslider;\n            annotator.editor.element[0].style.display = 'none';\n            rs.show();\n            this._setOverRS(annotator.adder);\n        },\n        _onMouseUpRS: function(event) {\n            videojs.off(document, \"mousemove\", this._onMouseMoveRS, false);\n            videojs.off(document, \"mouseup\", this._onMouseUpRS, false);\n            \n            var player = this.player;\n            var annotator = player.annotator;\n            var rs = player.rangeslider;\n            annotator.editor.element[0].style.display = 'block';\n            \n            this._setOverRS(annotator.editor.element);\n        },\n        _sumPercent: function(seconds, percent) {\n            // the percentage is in %\n            var duration = this.player.duration();\n            var seconds = seconds || 0;\n            var percent = percent || 10;\n            percent = Math.min(100, Math.max(0, percent));\n            \n            if (isNaN(duration)) {\n                return 0;\n            }\n            return Math.min(duration, Math.max(0, seconds + duration * percent / 100));\n        },\n        // Detect if we are creating or editing a video-js annotation\n        _EditVideoAn: function () {\n            var annotator = this.annotator;\n            var isOpenVideojs = (typeof this.player != 'undefined');\n            var VideoJS = annotator.editor.VideoJS;\n            return (isOpenVideojs && typeof VideoJS!='undefined' && VideoJS!==-1);\n        },\n        // Detect if the annotation is a video-js annotation\n        _isVideoJS: function (an) {\n            var player = this.player;\n            var rt = an.rangeTime;\n            var isOpenVideojs = (typeof this.player !== 'undefined');\n            var isVideo = (typeof an.media !== 'undefined' && (an.media === 'video' || an.media === 'audio'));\n            var isContainer = (typeof an.target !== 'undefined' && an.target.container == player.id_ );\n            var isNumber = (typeof rt !== 'undefined' && !isNaN(parseFloat(rt.start)) && isFinite(rt.start) && !isNaN(parseFloat(rt.end)) && isFinite(rt.end));\n            var isSource = false;\n            if (isContainer) {\n                // Compare without extension\n                var isYoutube = (isOpenVideojs && typeof this.player.techName !== 'undefined') ? (this.player.techName === 'Youtube') : false;\n                var targetSrc = isYoutube ? an.target.src : an.target.src.substring(0, an.target.src.lastIndexOf(\".\"));\n                var playerSrc = isYoutube ? player.options_.sources[0].src : player.options_.sources[0].src.substring(0, player.options_.sources[0].src.lastIndexOf(\".\"));\n                isSource = (targetSrc === playerSrc);\n            }\n            return (isOpenVideojs && isVideo && isContainer && isSource && isNumber);\n        },\n        _sortByDate: function (annotations, type) {\n            var type = type || 'asc'; // asc => The value [0] will be the most recent date\n            annotations.sort(function(a, b) {\n                a = new Date(typeof a.updated !== 'undefined' ? createDateFromISO8601(a.updated) : '');\n                b = new Date(typeof b.updated !== 'undefined' ? createDateFromISO8601(b.updated) : '');\n                if (type == 'asc')\n                    return (b < a) ? -1 : ((b > a) ? 1 : 0);\n                else\n                    return (a < b) ? -1 : ((a > b) ? 1 : 0);\n            });\n        }\n    };\n\n    // ----------------CREATE new Components for video-js---------------- //\n\n    // --Charge the new Component into videojs\n    videojs.Player.prototype.options_.children.AnContainerButtons = {}; // Container with the css for the buttons\n    videojs.ControlBar.prototype.options_.children.BackAnDisplay = {}; // Range Slider Time Bar\n    videojs.ControlBar.prototype.options_.children.BackAnDisplayScroll = {}; // Range Slider Time Bar\n   // videojs.options.children.BigNewAnnotation = {}; // Big Button New Annotation\n\n\n\n    // -- Player--> BigNewAnnotation\n\n    /**\n     * Create a New Annotation with big Button\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n    // videojs.BigNewAnnotation = videojs.Button.extend({\n    //     /** @constructor */\n    //     init: function(player, options) {\n    //         videojs.Button.call(this, player, options);\n    //     }\n    // });\n\n    // videojs.BigNewAnnotation.prototype.init_ = function() {\n    //     this.an = this.player_.annotations;\n    //     // Hide Button if the user has selected readOnly in the Annotator options\n    //     var opts = this.an.options.optionsAnnotator;\n    //     if (typeof opts !== 'undefined' && typeof opts.readOnly !== 'undefined' && opts.readOnly)\n    //         this.hide();\n    // };\n\n    // videojs.BigNewAnnotation.prototype.createEl = function() {\n    //     return videojs.Button.prototype.createEl.call(this, 'div', {\n    //         className: 'vjs-big-new-annotation vjs-menu-button vjs-control',\n    //         innerHTML: '<div class=\"vjs-big-menu-button vjs-control\">A</div>',\n    //         title: 'New Annotation',\n    //     });\n    // };\n\n    // videojs.BigNewAnnotation.prototype.onClick = function() {\n    //     this.an.newan();\n    // };\n\n    // -- Player--> ControlBar--> AnContainerButtons\n\n    /**\n     * Container for the button CSS\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n\n    videojs.AnContainerButtons = videojs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n        }\n    });\n\n    videojs.AnContainerButtons.prototype.init_ = function() {};\n\n\n    videojs.AnContainerButtons.prototype.options_ = {\n        children: {\n            'ShowAnnotations': {},\n            'NewAnnotation': {},\n            'ShowStatistics': {},\n        }\n    };\n\n    videojs.AnContainerButtons.prototype.createEl = function() {\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-container-button-annotation',\n        });\n    };\n\n    // -- Player--> ControlBar--> AnContainerButtons--> ShowStatistics\n\n    /**\n     * Button for show/hide the chart with statistics of the annotation's number\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n\n    videojs.ShowStatistics = videojs.Button.extend({\n        /** @constructor */\n        init: function(player, options) {\n            videojs.Button.call(this, player, options);\n        }\n    });\n\n    videojs.ShowStatistics.prototype.init_ = function() {\n        this.an = this.player_.annotations;\n    };\n\n    videojs.ShowStatistics.prototype.createEl = function() {\n        return videojs.Button.prototype.createEl.call(this, 'div', {\n            className: 'vjs-statistics-annotation allow_clicking vjs-control',\n            title: 'Show the Statistics',\n            tabindex: '0',\n        });\n    };\n\n    videojs.ShowStatistics.prototype.onClick = function() {\n        if (!this.an.options.showStatistics) this.an.showStatistics();\n        else this.an.hideStatistics();\n    };\n\n\n\n    // -- Player--> ControlBar--> AnContainerButtons--> ShowAnnotations\n\n    /**\n     * Button for show/hide the annotation panel\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n\n    videojs.ShowAnnotations = videojs.Button.extend({\n      /** @constructor */\n      init: function(player, options) {\n        videojs.Button.call(this, player, options);\n      }\n    });\n\n    videojs.ShowAnnotations.prototype.init_ = function() {\n        this.an = this.player_.annotations;\n    };\n\n    videojs.ShowAnnotations.prototype.createEl = function() {\n        return videojs.Button.prototype.createEl.call(this, 'div', {\n            className: 'vjs-showannotations-annotation allow_clicking vjs-control',\n            title: 'Show Annotations',\n            tabindex: '0',\n        });\n    };\n\n    videojs.ShowAnnotations.prototype.onClick = function() {\n        if (!this.an.options.showDisplay) this.an.showDisplay();\n        else this.an.hideDisplay();\n    };\n\n\n\n    // -- Player--> ControlBar--> AnContainerButtons--> NewAnnotation\n\n    /**\n     * Create a New Annotation\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n    videojs.NewAnnotation = videojs.Button.extend({\n        /** @constructor */\n        init: function(player, options) {\n            videojs.Button.call(this, player, options);\n        }\n    });\n\n    videojs.NewAnnotation.prototype.init_ = function() {\n        this.an = this.player_.annotations;\n        // Hide Button if the user has selected readOnly in the Annotator options\n        var opts = this.an.options.optionsAnnotator;\n        if (typeof opts !== 'undefined' && typeof opts.readOnly !== 'undefined' && opts.readOnly)\n            this.hide();\n    };\n\n    videojs.NewAnnotation.prototype.createEl = function() {\n        return videojs.Button.prototype.createEl.call(this, 'div', {\n            className: 'vjs-new-annotation allow_clicking vjs-control',\n            title: 'New Annotation',\n            tabindex: '0'\n        });\n    };\n\n    videojs.NewAnnotation.prototype.onClick = function() {\n        this.an.newan();\n    };\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplay\n\n    /**\n     * The background annotations panel\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n    videojs.BackAnDisplay = videojs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n        }\n    });\n\n    videojs.BackAnDisplay.prototype.init_ = function() {\n        this.an = this.player_.annotations\n            self = this;\n        // Fix error resizing the display panel. The scroll always went up.\n        $(this.el_).watch('font-size', function() {\n            self.an.backDSBarSel.setPosition(self.an.BackAnDisplayScroll.currentValue, false);\n        });\n\n    };\n\n    videojs.BackAnDisplay.prototype.options_ = {\n        children: {\n            'RangeSelectorDisplay': {},\n            'AnDisplay': {},\n            'AnStat': {},\n        }\n    };\n\n    videojs.BackAnDisplay.prototype.createEl = function() {\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-back-anpanel-annotation',\n        });\n    };\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplay--> RangeSelectorDisplay\n\n    /**\n     * The selector to show the annotations in a time selection\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n     \n    videojs.RangeSelectorDisplay = videojs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n        videojs.Component.call(this, player, options);\n            this.on('mousedown', this.onMouseDown);\n        }\n    });\n\n    videojs.RangeSelectorDisplay.prototype.init_ = function() {\n        this.rs = this.player_.rangeslider;\n        this.an = this.player_.annotations;\n        var duration = this.an.player.duration();\n        this.start = 0;\n        this.end = duration;\n        \n        // set the selection area in the extreme position\n        this.setPosition(0, 0, false);\n        this.setPosition(1, this.rs._percent(duration), false);\n    };\n\n    videojs.RangeSelectorDisplay.prototype.options_ = {\n        children: {\n            'RangeSelectorLeft': {},\n            'RangeSelectorRight': {},\n            'RangeSelectorBar': {},\n        }\n    };\n\n    videojs.RangeSelectorDisplay.prototype.createEl = function(){\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-rangeselector-anpanel-annotation',\n        });\n    };\n\n    videojs.RangeSelectorDisplay.prototype.onMouseDown = function(event) {\n        event.preventDefault();\n        // videojs.blockTextSelection();\n        \n        videojs.on(document, \"mousemove\", videojs.bind(this, this.onMouseMove));\n        videojs.on(document, \"mouseup\", videojs.bind(this, this.onMouseUp));\n        \n        videojs.removeClass(this.an.rsdb.el_, 'disable');\n    };\n\n    videojs.RangeSelectorDisplay.prototype.onMouseUp = function(event) {\n        videojs.off(document, \"mousemove\", this.onMouseMove, false);\n        videojs.off(document, \"mouseup\", this.onMouseUp, false);\n        \n        videojs.addClass(this.an.rsdb.el_, 'disable');\n    };\n\n    videojs.RangeSelectorDisplay.prototype.onMouseMove = function(event) {\n        var left = this.calculateDistance(event);\n        if (this.an.rsdl.pressed)\n            this.setPosition(0, left);\n        else if (this.an.rsdr.pressed)\n            this.setPosition(1, left);\n        \n        // move the frame to the position of the arrow\n        this.an.player.currentTime(this.rs._seconds(left));\n    };\n\n    videojs.RangeSelectorDisplay.prototype.calculateDistance = function(event) {\n        var rstbX = this.getRSTBX();\n        var rstbW = this.getRSTBWidth();\n        var handleW = this.getWidth();\n\n        // Adjusted X and Width, so handle doesn't go outside the bar\n        rstbX = rstbX + (handleW / 2);\n        rstbW = rstbW - handleW;\n\n        // Percent that the click is through the adjusted area\n        return Math.max(0, Math.min(1, (event.pageX - rstbX) / rstbW));\n    };\n\n    videojs.RangeSelectorDisplay.prototype.getRSTBWidth = function() {\n        return this.el_.offsetWidth;\n    };\n    videojs.RangeSelectorDisplay.prototype.getRSTBX = function() {\n        return videojs.findPosition(this.el_).left;\n    };\n    videojs.RangeSelectorDisplay.prototype.getWidth = function() {\n        var arrow = $(this.an.rsdl.el_).find('.vjs-selector-arrow')[0];\n        return arrow.offsetWidth; // does not matter left or right\n    };\n\n    videojs.RangeSelectorDisplay.prototype.setPosition = function(index, left, changeTime) {\n        // index = 0 for left side, index = 1 for right side\n        var index = index || 0;\n        var changeTime = typeof changeTime !== 'undefined' ? changeTime : true;\n\n        // Check for invalid position\n        if(isNaN(left)) \n            return false;\n        \n        // Check index between 0 and 1\n        if (!(index === 0 || index === 1))\n            return false;\n        // Alias\n        var ObjLeft = this.an.rsdl.el_;\n        var ObjRight = this.an.rsdr.el_;\n        var Obj = this.an[index === 0 ? 'rsdl' : 'rsdr'].el_;\n        \n        // Check if left arrow is over the right arrow\n        if ((index === 0 ? this.updateLeft(left) : this.updateRight(left))) {\n            if (index === 1) { // right\n                Obj.style.left = (left * 100) + '%';\n                Obj.style.width = ((1 - left) * 100) + '%';\n            } else { // left\n                Obj.style.left = (left * 100) + '%';\n                Obj.style.width = ((left) * 100) + '%';\n            }\n            \n            this[index === 0 ? 'start' : 'end'] = this.rs._seconds(left);\n        \n            // Fix the problem  when you press the button and the two arrow are underhand\n            // left.zIndex = 10 and right.zIndex=20. This is always less in this case:\n            if (index === 0 && (left * 100) >= 90)\n                $(ObjLeft).find('.vjs-selector-arrow')[0].style.zIndex = 25;\n            else\n                $(ObjLeft).find('.vjs-selector-arrow')[0].style.zIndex = 10;\n            \n            \n            // -- Panel\n            var rsdbl = this.an.rsdbl.el_,\n                rsdbr = this.an.rsdbr.el_,\n                distance = parseFloat(ObjRight.style.left) - parseFloat(ObjLeft.style.left);\n            if (index === 0)\n                rsdbl.children[0].innerHTML = videojs.formatTime(this.rs._seconds(left));\n            else\n                rsdbr.children[0].innerHTML = videojs.formatTime(this.rs._seconds(left));\n            if (typeof distance !== 'undefined' && distance <= 12.5) {\n                if (parseFloat(ObjLeft.style.left) < 7) {\n                    rsdbl.style.top = (-1.5) + 'em';\n                    rsdbl.style.left = 1 + 'em';\n                } else {\n                    rsdbl.style.left = (-2.5) + 'em';\n                    rsdbl.style.top = '';\n                }\n                    \n                if (parseFloat(ObjRight.style.left) > 93) {\n                    rsdbr.style.top = (-1.5) + 'em';\n                    rsdbr.style.right = 1 + 'em';\n                } else {\n                    rsdbr.style.right = (-2.5) + 'em';\n                    rsdbr.style.top = '';\n                }\n            } else {\n                rsdbl.style.left = 1 + 'em';\n                rsdbr.style.right = 1 + 'em';\n                rsdbl.style.top = '';\n                rsdbr.style.top = '';\n            }\n            \n            \n            var start = this.rs._seconds(parseFloat(ObjLeft.style.left) / 100);\n            var end = this.rs._seconds(parseFloat(ObjRight.style.left) / 100);\n                \n            if (changeTime)\n                this.an.showBetween(start, end, this.an.rsdl.include, this.an.rsdr.include);\n        }\n        return true;\n    };\n\n    videojs.RangeSelectorDisplay.prototype.updateLeft = function(left) {\n        var rightVal = this.an.rsdr.el_.style.left !== '' ? this.an.rsdr.el_.style.left : 100;\n        var right = parseFloat(rightVal) / 100;\n        var bar = this.an.rsdb.el_;\n        \n        var width = videojs.round((right - left), this.an.updatePrecision); // round necessary for not get 0.6e-7 for example that it's not able for the html css width\n        if(left <= (right+0.00001)) {\n                bar.style.left = (left * 100) + '%';\n                bar.style.width = (width * 100) + '%';\n                return true;\n        }\n        return false;\n    };\n            \n    videojs.RangeSelectorDisplay.prototype.updateRight = function(right) {\n        var leftVal = this.an.rsdl.el_.style.left !== '' ? this.an.rsdl.el_.style.left : 0;\n        var left = parseFloat(leftVal) / 100;\n        var bar = this.an.rsdb.el_;\n            \n        var width = videojs.round((right - left), this.an.updatePrecision); // round necessary for not get 0.6e-7 for example that it's not able for the html css width\n        \n        if((right+0.00001) >= left) {\n            bar.style.width = (width * 100) + '%';\n            bar.style.left = ((right  - width) * 100) + '%';\n            return true;\n        }\n        return false;\n    };        \n\n\n\n    // -- Player--> ControlBar--> BackAnDisplay--> RangeSelectorDisplay--> RangeSelectorLeft\n\n    /**\n     * Left Time selector\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n    videojs.RangeSelectorLeft = videojs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n            this.on('mousedown', this.onMouseDown);\n            this.on('dblclick', this.ondblclick);\n            this.pressed = false; // to know when is mousedown\n            this.include = true; // to know when we want to include the boundary time in the selection or not\n        }\n    });\n\n    videojs.RangeSelectorLeft.prototype.init_ = function() {\n        this.rs = this.player_.rangeslider;\n        this.an = this.player_.annotations;\n        videojs.addClass(this.el_, 'include');\n    };\n\n    videojs.RangeSelectorLeft.prototype.createEl = function() {\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-leftselector-anpanel-annotation',\n            innerHTML: '<div class=\"vjs-selector-arrow\" title=\"Left Annotation Selector\"></div><div class=\"vjs-leftselector-back\"></div>'\n        });\n    };\n\n\n    videojs.RangeSelectorLeft.prototype.onMouseDown = function(event) {\n        event.preventDefault();\n        \n        this.pressed = true;\n        videojs.on(document, \"mouseup\", videojs.bind(this, this.onMouseUp));\n        videojs.addClass(this.el_, 'active');\n        videojs.addClass(this.el_.parentNode, 'active');\n    };\n\n    videojs.RangeSelectorLeft.prototype.onMouseUp = function(event) {\n        videojs.off(document, \"mouseup\", this.onMouseUp, false);\n        videojs.removeClass(this.el_, 'active');\n        videojs.removeClass(this.el_.parentNode, 'active');\n        this.pressed = false;\n    };\n\n    videojs.RangeSelectorLeft.prototype.ondblclick = function(event) {\n        if (this.include) {\n            this.include = false;\n            videojs.removeClass(this.el_, 'include');\n        } else {\n            this.include = true;\n            videojs.addClass(this.el_, 'include');\n        }\n        var left = this.an.rsd.calculateDistance(event);\n        this.an.rsd.setPosition(0, left);\n    };\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplay--> RangeSelectorDisplay--> RangeSelectorRight\n\n    /**\n     * Right Time selector\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n    videojs.RangeSelectorRight = videojs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n            this.on('mousedown', this.onMouseDown);\n            this.on('dblclick', this.ondblclick);\n            this.pressed = false; // to know when is mousedown\n            this.include = true; // to know when we want to include the boundary time in the selection or not\n        }\n    });\n\n    videojs.RangeSelectorRight.prototype.init_ = function() {\n        this.rs = this.player_.rangeslider;\n        this.an = this.player_.annotations;\n        videojs.addClass(this.el_, 'include');\n    };\n\n    videojs.RangeSelectorRight.prototype.createEl = function() {\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-rightselector-anpanel-annotation',\n            innerHTML: '<div class=\"vjs-selector-arrow\" title=\"Right Annotation Selector\"></div><div class=\"vjs-rightselector-back\"></div>'\n        });\n    };\n\n    videojs.RangeSelectorRight.prototype.onMouseDown = function(event) {\n        event.preventDefault();\n        \n        this.pressed = true;\n        videojs.on(document, \"mouseup\", videojs.bind(this, this.onMouseUp));\n        videojs.addClass(this.el_, 'active');\n        videojs.addClass(this.el_.parentNode, 'active');\n    };\n\n    videojs.RangeSelectorRight.prototype.onMouseUp = function(event) {\n        videojs.off(document, \"mouseup\", this.onMouseUp, false);\n        videojs.removeClass(this.el_, 'active');\n        videojs.removeClass(this.el_.parentNode, 'active');\n        this.pressed = false;\n    };\n\n    videojs.RangeSelectorRight.prototype.ondblclick = function(event) {\n        if (this.include){\n            this.include = false;\n            videojs.removeClass(this.el_, 'include');\n        }else{\n            this.include = true;\n            videojs.addClass(this.el_, 'include');\n        }\n        var left = this.an.rsd.calculateDistance(event);\n        this.an.rsd.setPosition(1, left);\n    };\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplay--> RangeSelectorDisplay--> RangeSelectorBar\n\n    /**\n     * Bar to display the selected Time\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n     \n    videojs.RangeSelectorBar = videojs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n        }\n    });\n\n    videojs.RangeSelectorBar.prototype.init_ = function() {\n        videojs.addClass(this.el_, 'disable');\n    };\n\n    videojs.RangeSelectorBar.prototype.options_ = {\n        children: {\n            'RangeSelectorBarL': {},\n            'RangeSelectorBarR': {},\n        }\n    };\n\n    videojs.RangeSelectorBar.prototype.createEl = function() {\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-barselector-anpanel-annotation',\n        });\n    };\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplay--> RangeSelectorDisplay--> RangeSelectorBar--> RangeSelectorBarL\n\n    /**\n     * This is the left time panel for RangeSelectorBar\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n    videojs.RangeSelectorBarL = videojs.Component.extend({\n      /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n        }\n    });\n\n    videojs.RangeSelectorBarL.prototype.init_ = function() {};\n\n    videojs.RangeSelectorBarL.prototype.createEl = function() {\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-barselector-left',\n            innerHTML: '<span class=\"vjs-time-text\">00:00</span>',\n        });\n    };\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplay--> RangeSelectorDisplay--> RangeSelectorBar--> RangeSelectorBarR\n    /**\n     * This is the right time panel for RangeSelectorBar\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n    videojs.RangeSelectorBarR = videojs.Component.extend({\n      /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n        }\n    });\n\n    videojs.RangeSelectorBarR.prototype.init_ = function() {};\n\n    videojs.RangeSelectorBarR.prototype.createEl = function() {\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-barselector-right',\n            innerHTML: '<span class=\"vjs-time-text\">00:00</span>'\n        });\n    };\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplay--> AnDisplay\n\n    /**\n     * Show the annotations in a panel\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n     \n    videojs.AnDisplay = videojs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n            this.on('mousedown', this.onMouseDown);\n            this.on('mouseover', this.onMouseOver);\n        }\n    });\n\n    videojs.AnDisplay.prototype.init_ = function() {\n        this.rs = this.player_.rangeslider;\n        this.an = this.player_.annotations;\n        this.transition = false;\n    };\n\n    videojs.AnDisplay.prototype.createEl = function() {\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-anpanel-annotation',\n        });\n    };\n\n    videojs.AnDisplay.prototype.onMouseDown = function(event) {\n        var elem = $(event.target).parents('.annotator-hl').addBack();\n        var _self = this;\n        if (elem.hasClass(\"annotator-hl\")) {\n            videojs.on(document, \"mouseup\", videojs.bind(this, this.onMouseUp));\n            // Clone the bar box to make the animation\n            var boxup = document.createElement('div');\n            var ElemTop = parseFloat(elem[1].style.top);\n            var ElemMargin = parseFloat(elem[1].style.marginTop);\n            var emtoPx = parseFloat($(elem[1]).css('height'));\n            var isPoint = $(elem[1]).hasClass(\"point\");\n                \n            boxup.className = isPoint ? \"boxup-dashed-line point\" : \"boxup-dashed-line\";\n            boxup.style.left = elem[1].style.left;\n            boxup.style.width = elem[1].style.width;\n        \n            boxup.style.top = (ElemTop + ElemMargin - this.el_.scrollTop / emtoPx) + 'em';\n            elem[0].parentNode.parentNode.appendChild(boxup);\n        }\n    }\n\n    videojs.AnDisplay.prototype.onMouseUp = function(event) {\n        if (typeof this.lastelem === 'undefined')\n            return false;\n        var elem = this.lastelem;\n        var _self = this;\n        if (elem.hasClass(\"annotator-hl\")) {\n            var annotation = elem.map(function() {\n                return $(this).data(\"annotation\");\n            })[0];\n            var displayHeight = (-1) * parseFloat($(this.el_).parent()[0].style.top);\n            var emtoPx = parseFloat($(elem[1]).css('height'));\n            if (typeof $(elem).parent().parent().find('.boxup-dashed-line')[0] !== 'undefined') {\n                $(elem).parent().parent().find('.boxup-dashed-line')[0].style.top = (displayHeight - 2) + 'em';\n            }\n            \n            this.an.player.pause();\n            this.transition = true;\n            window.setTimeout(function () {\n                _self.an.showAnnotation(annotation);\n                _self.transition = false;\n                _self.onCloseViewer();\n            }, 900);\n        }\n        videojs.off(document, \"mouseup\", this.onMouseUp, false);\n    };\n\n    videojs.AnDisplay.prototype.onMouseOver = function(event) {\n        if (!this.transition && !this.an.rsdl.pressed && !this.an.rsdr.pressed) {\n            var annotator = this.an.annotator;\n            var elem = $(event.target).parents('.annotator-hl').addBack();\n        \n            // if there is a opened annotation then show the new annotation mouse over\n            if (typeof annotator !== 'undefined' && annotator.viewer.isShown() && elem.hasClass(\"annotator-hl\")) {\n                // hide the last open viewer\n                annotator.viewer.hide();\n                // get the annotation over the mouse\n                var annotations = elem.map(function() {\n                    return $(this).data(\"annotation\");\n                });\n                // show the annotation in the viewer\n                annotator.showViewer($.makeArray(annotations), Util.mousePosition(event, annotator.wrapper[0]));\n            }\n        \n            // create dashed line\n            elem.addClass('active');\n            if (typeof elem !== 'undefined' && $(elem[1]).hasClass('annotation')) {\n                // create dashed line under the bar\n                var dashed = document.createElement('div');\n                var boxdown = document.createElement('div');\n                var DisplayHeight = parseFloat(this.an.BackAnDisplay.el_.style.height);\n                var ElemMarginTop = elem[1].style.marginTop !== '' ? parseFloat(elem[1].style.marginTop) : 0;\n                var ElemTop = parseFloat(elem[1].style.top) + ElemMarginTop;\n                var emtoPx = parseFloat($(elem[1]).css('height'));\n                var isPoint = $(elem[1]).hasClass(\"point\");\n\n                dashed.className = isPoint ? 'dashed-line point' : 'dashed-line';\n                boxdown.className = \"box-dashed-line\";\n                dashed.style.left = boxdown.style.left = elem[1].style.left;\n                dashed.style.width = boxdown.style.width = isPoint ? '0' : elem[1].style.width;\n                dashed.style.top = ((ElemTop + 1) - this.el_.scrollTop / emtoPx) + 'em';\n                dashed.style.height = ((DisplayHeight - ElemTop + 2) + this.el_.scrollTop / emtoPx) + 'em'; // get the absolute value of the top to put in the height\n                boxdown.style.top = (DisplayHeight + 2) + 'em';\n                elem[0].parentNode.parentNode.appendChild(dashed);\n                elem[0].parentNode.parentNode.appendChild(boxdown);\n                \n                $(this.player).find('.vjs-play-progress').css('z-index', 2);\n                $(this.player).find('.vjs-seek-handle').css('z-index', 2);\n            }\n        \n            // store the last selected item\n            if (elem.hasClass(\"annotator-hl\"))\n                this.lastelem = elem;\n        }\n    };\n\n    videojs.AnDisplay.prototype.onCloseViewer = function() {\n        if (!this.transition) {\n            if (typeof this.lastelem !== 'undefined')\n                this.lastelem.removeClass('active');\n            // remove dashed line\n            if (typeof this.lastelem !== 'undefined' && this.lastelem.hasClass(\"annotator-hl\")) {\n                $(this.lastelem).parent().parent().find('.dashed-line').remove();\n                $(this.lastelem).parent().parent().find('.box-dashed-line').remove();\n                $(this.lastelem).parent().parent().find('.boxup-dashed-line').remove();\n                $(this.player).find('.vjs-play-progress').css('z-index', \"\");\n                $(this.player).find('.vjs-seek-handle').css('z-index', \"\");\n            }\n        }\n    };\n\n\n    videojs.AnDisplay.prototype.countVisibles = function() {\n        var AnArray = $.makeArray(this.el_.children);\n        // Count visible annotations in Panel\n        var count = 0;\n        for (var index in AnArray) {\n            var an = AnArray[index];\n            if (an.style.display !== 'none') {\n                count++;\n            }\n        }\n        return count;\n    };\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplay--> AnStat\n\n    /**\n     * Display with a chart with the statistics of the number of Annotations\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n     \n    videojs.AnStat = videojs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n            this.marginTop = 20;\n            this.marginBottom = 0;\n        }\n    });\n\n    videojs.AnStat.prototype.init_ = function() {\n        this.rs = this.player_.rangeslider;\n        this.an = this.player_.annotations;\n        this.canvas = this.el_.children[0];\n    };\n\n    videojs.AnStat.prototype.createEl = function() {\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-anstat-annotation',\n            innerHTML: '<canvas class=\"vjs-char-anstat-annotation\">Your browser does not support the HTML5 canvas tag.</canvas>',\n        });\n    };\n\n    videojs.AnStat.prototype.paintCanvas = function() {\n        var ctx = this.canvas.getContext(\"2d\");\n        var points = this._getPoints();\n        var w = this._getWeights(points);\n        var maxEn = this._getMaxArray(points, 'entries');\n        var TotAn = this.an.AnDisplay.el_.children.length;\n        var duration = this.an.player.duration();\n\n        // set the position of the canvas\n        this.canvas.style.marginTop = Math.round(this.marginTop) + 'px';\n        \n        // Add the Max Concentration and Number of annotations\n        if($(this.canvas).parent().find('.vjs-totan-anstat-annotation').length === 0) {\n            $(this.canvas).parent().append('<div class=\"vjs-totan-anstat-annotation\">');\n            $(this.canvas).parent().append('<div class=\"vjs-maxcon-anstat-annotation\">');\n        }\n        var textCanvas = $(this.canvas).parent().find('.vjs-totan-anstat-annotation')[0];\n        textCanvas.innerHTML = TotAn + ' total annotations';\n        var textCanvas = $(this.canvas).parent().find('.vjs-maxcon-anstat-annotation')[0];\n        textCanvas.innerHTML = 'Max Annotations = ' + maxEn;\n        \n        // Added dashed line function to paint\n        if (window.CanvasRenderingContext2D && CanvasRenderingContext2D.prototype.lineTo) {\n            CanvasRenderingContext2D.prototype.dashedLine = function(x1, y1, x2, y2, dashLen) {\n                if (dashLen === undefined) dashLen = 2;\n\n                this.beginPath();\n                this.moveTo(x1, y1);\n\n                var dX = x2 - x1;\n                var dY = y2 - y1;\n                var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n                var dashX = dX / dashes;\n                var dashY = dY / dashes;\n\n                var q = 0;\n                while (q++ < dashes) {\n                 x1 += dashX;\n                 y1 += dashY;\n                 this[q % 2 == 0 ? 'moveTo' : 'lineTo'](x1, y1);\n                }\n                this[q % 2 == 0 ? 'moveTo' : 'lineTo'](x2, y2);\n\n                this.stroke();\n                this.closePath();\n            };\n        };    \n            \n        \n        // set the canvas size\n        this.canvas.height = this.an.AnDisplay.el_.offsetHeight - (this.marginTop + this.marginBottom);\n        this.canvas.width  = this.an.AnDisplay.el_.offsetWidth;\n        \n        ctx.beginPath();\n        ctx.strokeStyle = \"rgb(255, 163, 0)\";\n        var lastSe = 0;\n        var lastEn = 0;\n        ctx.moveTo(0, maxEn * w.Y); // Move pointer to 0, 0\n        for (var index in points) {\n            var p = points[index];\n            var x1 = lastSe * w.X, y1 = (maxEn - lastEn) * w.Y; // Old Point\n            var x2 = p.second * w.X, y2 = (maxEn - p.entries) * w.Y; // New Point\n            // new line\n            ctx.lineTo(x2, y1); // move horizontally to the new point\n            ctx.moveTo(x2, y1); // Move pointer\n            ctx.lineTo(x2, y2); // move vertically to the new point height\n            ctx.moveTo(x2, y2); // Prepare pointer for a new instance\n            // new rectangle under the curve\n            ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n            ctx.fillRect(x1, y1, (x2 - x1), (maxEn * w.Y - y1));\n            \n            // store the last point\n            lastSe = p.second;\n            lastEn = p.entries;\n        }\n        // set the graphic to the end of the video\n        ctx.lineTo(lastSe * w.X, maxEn * w.Y); \n        ctx.moveTo(lastSe * w.X, maxEn * w.Y); \n        ctx.lineTo(duration * w.X, maxEn * w.Y);\n        ctx.stroke();\n        \n        // dashed line down\n        ctx.beginPath();\n        ctx.dashedLine(0, maxEn * w.Y, duration * w.X, maxEn * w.Y, 8);\n        ctx.stroke();\n        // dashed line top\n        ctx.beginPath();\n        ctx.dashedLine(0, 0, duration * w.X, 0, 8);\n        ctx.stroke();\n    };\n\n    videojs.AnStat.prototype._getWeights = function(points){\n        var weight = {};\n        var panel = $(this.an.AnDisplay.el_);\n        var maxSe = this.an.player.duration();\n        var maxEn = this._getMaxArray(points, 'entries');\n        var panelW = parseFloat(panel.css('width'));\n        var panelH = parseFloat(panel.css('height')) - (this.marginTop + this.marginBottom);\n        weight.X = maxSe != 0 ? (panelW / maxSe) : 0;\n        weight.Y = maxEn != 0 ? (panelH / maxEn) : 0;\n        return weight;\n    };\n\n    videojs.AnStat.prototype._getMaxArray = function(points, variable) {\n        var highest = 0;\n        var tmp;\n        for (var index in points) {\n            tmp = points[index][variable];\n            if (tmp > highest) highest = tmp;\n        }\n        return highest;\n    };\n\n    videojs.AnStat.prototype._getPoints = function() {\n        var points = [];\n        var allannotations = this.an.annotator.plugins.LocalStore.annotations;\n        for (var index in allannotations) {\n            var an = allannotations[index];\n            var start, end;\n            if (this.an._isVideoJS(an)) {\n                start = an.rangeTime.start;\n                end = an.rangeTime.end;\n                // start\n                if (!this._isFound(points, start)) {\n                    points.push({\n                        second:an.rangeTime.start,\n                        entries:this._getNumberAnnotations(start)\n                    });\n                    if (an.rangeTime.start == an.rangeTime.end){ // is a point\n                        points.push({\n                            second:an.rangeTime.end,\n                            entries:this._getNumberAnnotations(end, true)\n                        });\n                    }\n                }\n                // end\n                if (!this._isFound(points, end)) {\n                    points.push({\n                        second:an.rangeTime.end,\n                        entries:this._getNumberAnnotations(end, true)\n                    });\n                }\n                    \n                found = false;\n            }\n        }\n        points.sort(function(a, b) {\n            return parseFloat(a.second) - parseFloat(b.second)\n        });\n        return points;\n    };\n\n    videojs.AnStat.prototype._isFound = function(array, elem) {\n        var found = false;\n        for (var indexA in array) {\n            if(typeof array[indexA].second !== 'undefined' && array[indexA].second == elem)\n                found = true;\n        }\n        return found;\n    };\n\n    videojs.AnStat.prototype._getNumberAnnotations = function(time, end) {\n        var num = (typeof end !== 'undefined' && end) ? -1 : 0;\n        var allannotations = this.an.annotator.plugins['LocalStore'].annotations;\n        for (var index in allannotations) {\n            var an = allannotations[index];\n            if (this.an._isVideoJS(an)) {\n                if(an.rangeTime.start <= time && an.rangeTime.end >= time)\n                    num++;\n            }\n        }\n        return num;\n    };\n\n    // -- Player--> ControlBar--> BackAnDisplayScroll\n\n    /**\n     * The background annotations panel\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n     \n    videojs.BackAnDisplayScroll = videojs.Component.extend({\n          /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n            this.on('mousedown', this.onMouseDown);\n            this.UpValue = 0.1;\n            this.currentValue = 0;\n        }\n    });\n\n    videojs.BackAnDisplayScroll.prototype.init_ = function() {\n        this.rs = this.player_.rangeslider;\n        this.an = this.player_.annotations;\n        this.mousedownID = -1;\n        var self = this;\n        var direction;\n            \n        // Firefox\n        $(this.an.AnDisplay.el_).bind('DOMMouseScroll', function(e) {\n            if (e.originalEvent.detail > 0)\n                direction = self.UpValue;\n            else \n                direction = -self.UpValue;\n            self.an.backDSBarSel.setPosition(self.getPercentScroll() + direction);\n            return false;\n        });\n\n        // IE, Opera, Safari\n        $(this.an.AnDisplay.el_).bind('mousewheel', function(e) {\n            if (e.originalEvent.wheelDelta < 0) \n                direction = self.UpValue;\n            else \n                direction = -self.UpValue;\n            self.an.backDSBarSel.setPosition(self.getPercentScroll() + direction);\n            return false;\n        });\n    };\n\n    videojs.BackAnDisplayScroll.prototype.options_ = {\n        children: {\n            'BackAnDisplayScrollBar': {},\n            'BackAnDisplayScrollTime': {},\n        }\n    };\n\n    videojs.BackAnDisplayScroll.prototype.createEl = function() {\n      return videojs.Component.prototype.createEl.call(this, 'div', {\n        className: 'vjs-scroll-anpanel-annotation',\n        innerHTML: '<div class=\"vjs-up-scroll-annotation\"></div><div class=\"vjs-down-scroll-annotation\"></div>',\n      });\n    };\n\n    videojs.BackAnDisplayScroll.prototype.onMouseDown = function(event) {\n        var self = this;\n        if (event.target.className === 'vjs-scrollbar-anpanel-annotation') {\n            // change position with a click in the scrollbar\n            this.an.backDSBarSel.onMouseMove(event);\n            return false;\n        } else if (event.target.className === 'vjs-scrollbar-selector') {\n            // change position with scrollbar\n            // this event is controlled by this.an.backDSBarSel\n            return false;\n        } else {\n            // change position with arrows\n            var direction = event.target.className=='vjs-down-scroll-annotation' ? this.UpValue : -this.UpValue;\n            videojs.on(document, \"mouseup\", videojs.bind(this, this.onMouseUp));\n            if(parseInt(this.mousedownID, 10) === -1) {  // Prevent multimple loops!\n                this.mousedownID = setInterval(function () {\n                    var pos = Math.max(0, Math.min(1, self.getPercentScroll() + direction));\n                    self.an.backDSBarSel.setPosition(pos);\n                }, 100);\n            }\n        }\n    };\n\n    videojs.BackAnDisplayScroll.prototype.onMouseUp = function(event) {\n        videojs.off(document, \"mouseup\", this.onMouseUp, false);\n        var self = this;\n        if(parseInt(this.mousedownID, 10) != -1) { // Only stop if exists\n            clearInterval(this.mousedownID);\n            self.mousedownID = -1;\n        }\n    };\n\n    videojs.BackAnDisplayScroll.prototype.getPercentScroll = function() {\n        var scroll = this.an.AnDisplay.el_;\n        var maxscroll = scroll.scrollHeight - scroll.offsetHeight;\n        var currentValue = scroll.scrollTop;\n        return Math.max(0, Math.min(1, maxscroll !== 0 ? (currentValue / maxscroll) : 0));\n    };\n\n    videojs.BackAnDisplayScroll.prototype.setPercentScroll = function(percent) {\n        var scroll = this.an.AnDisplay.el_;\n        var maxscroll = scroll.scrollHeight-scroll.offsetHeight;\n        percent = Math.max(0, Math.min(1, percent ? percent : 0));\n        scroll.scrollTop = Math.round(maxscroll * percent);\n    };\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplayScroll--> BackAnDisplayScrollBar\n\n    /**\n     * The Scroll bar for the display\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n     \n    videojs.BackAnDisplayScrollBar = videojs.Component.extend({\n          /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n        }\n    });\n\n    videojs.BackAnDisplayScrollBar.prototype.init_ = function() {};\n\n    videojs.BackAnDisplayScrollBar.prototype.options_ = {\n        children: {\n            'ScrollBarSelector': {},\n        }\n    };\n\n    videojs.BackAnDisplayScrollBar.prototype.createEl = function() {\n      return videojs.Component.prototype.createEl.call(this, 'div', {\n        className: 'vjs-scrollbar-anpanel-annotation',\n      });\n    };\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplayScroll--> BackAnDisplayScrollBar--> ScrollBarSelector\n\n    /**\n     * The Scroll bar for the display\n     * @param {videojs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n     \n    videojs.ScrollBarSelector = videojs.Component.extend({\n          /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n            this.on('mousedown', this.onMouseDown);\n        }\n    });\n\n    videojs.ScrollBarSelector.prototype.init_ = function() {\n        this.rs = this.player_.rangeslider;\n        this.an = this.player_.annotations;\n        videojs.addClass(this.an.backDSBar.el_, 'disable');\n    };\n\n\n    videojs.ScrollBarSelector.prototype.createEl = function() {\n        return videojs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-scrollbar-selector',\n        });\n    };\n\n    videojs.ScrollBarSelector.prototype.onMouseDown = function(event) {\n        event.preventDefault();\n        videojs.on(document, \"mousemove\", videojs.bind(this, this.onMouseMove));\n        videojs.on(document, \"mouseup\", videojs.bind(this, this.onMouseUp));\n    }\n\n    videojs.ScrollBarSelector.prototype.onMouseUp = function(event) {\n        videojs.off(document, \"mousemove\", this.onMouseMove, false);\n        videojs.off(document, \"mouseup\", this.onMouseUp, false);\n    };\n\n    videojs.ScrollBarSelector.prototype.onMouseMove = function(event) {\n        var top = this.calculateDistance(event);\n        top = this.parseMaxPercent(top); // set the max value fixing the height of the handle\n        this.setPosition(top);\n    }\n\n    videojs.ScrollBarSelector.prototype.calculateDistance = function(event) {\n        var scrollY = this.getscrollY();\n        var scrollH = this.getscrollHeight();\n        var handleH = this.getHeight();\n        \n        // Adjusted X and Width, so handle doesn't go outside the bar\n        scrollY = scrollY + (handleH);\n        scrollH = scrollH - (handleH);\n        // Adjusted X and Width, so handle doesn't go outside the bar\n        // Percent that the click is through the adjusted area\n        return Math.max(0, Math.min(1, (event.pageY - scrollY) / scrollH));\n    };\n\n    videojs.ScrollBarSelector.prototype.getscrollHeight = function() {\n        return this.el_.parentNode.offsetHeight;\n    };\n    videojs.ScrollBarSelector.prototype.getscrollY = function() {\n        return videojs.findPosition(this.el_.parentNode).top;\n    };\n    videojs.ScrollBarSelector.prototype.getHeight = function() {\n        return this.el_.offsetHeight;\n    };\n    videojs.ScrollBarSelector.prototype.parseMaxHeight = function(top) {\n        var scrollH = this.getscrollHeight();\n        var handleH = this.getHeight();\n        var percent = handleH / scrollH;\n        return Math.max(0, Math.min(1 - percent, top));\n    };\n\n    videojs.ScrollBarSelector.prototype.parseMaxPercent = function(top) {\n        var scrollH = this.getscrollHeight();\n        var handleH = this.getHeight();\n        var percent = handleH / scrollH;\n        var newTop = top;\n        if (top >= (1 - percent))\n            newTop = 1;\n        return newTop;\n    };\n\n    videojs.ScrollBarSelector.prototype.setPosition = function(top, showBar) {\n        var showBar = typeof showBar !== 'undefined' ? showBar : true;\n        \n        // Check for invalid position\n        if (isNaN(top)) \n            return false;\n        \n        // Check if there is enough annotations to scroll\n        if (!this.isScrollable())\n            return false;\n            \n        // Show the Scrollbar\n        if (showBar) {\n            videojs.removeClass(this.an.backDSBar.el_, 'disable')\n        }\n        \n        // Alias\n        var Obj = this.el_;\n        var scroll = this.an.BackAnDisplayScroll;\n        var scrollTime = this.an.backDSTime;\n        \n        Obj.style.top = (this.parseMaxHeight(top) * 100) + '%';\n        scroll.setPercentScroll(top);\n        \n        // Set the times in the scroll time panel\n        scrollTime.setTimes();\n        \n        // Hide the Scrollbar in 1 sec\n        if(showBar) {\n            var _self = this;\n            if (typeof this.Timeout !== 'undefined')\n                clearTimeout(this.Timeout);\n            this.Timeout = window.setTimeout(function () {\n                videojs.addClass(_self.an.backDSBar.el_, 'disable');\n            }, 1000);\n        }\n        \n        // set current position\n        this.an.BackAnDisplayScroll.currentValue = top;\n        return true;\n    }\n\n    videojs.ScrollBarSelector.prototype.isScrollable = function() {\n        var scroll = this.an.AnDisplay.el_;\n        var emtoPx = parseFloat($(scroll).find('.annotation').css('height'));\n        var minTop = parseInt(scroll.offsetHeight/emtoPx);\n        \n        // Count visible annotations in Panel\n        var count = this.an.AnDisplay.countVisibles();\n        return (count > minTop);\n    }\n\n\n\n    // -- Player--> ControlBar--> BackAnDisplayScroll--> BackAnDisplayScrollTime\n\n    videojs.BackAnDisplayScrollTime = videojs.Component.extend({\n          /** @constructor */\n        init: function(player, options) {\n            videojs.Component.call(this, player, options);\n        }\n    });\n\n    videojs.BackAnDisplayScrollTime.prototype.init_ = function() {\n        this.rs = this.player_.rangeslider;\n        this.an = this.player_.annotations;\n    };\n\n    videojs.BackAnDisplayScrollTime.prototype.createEl = function() {\n      return videojs.Component.prototype.createEl.call(this, 'div', {\n        className: 'vjs-scrolltime-anpanel-annotation',\n        innerHTML: '<div class=\"vjs-up-scrolltime-annotation\"><span class=\"vjs-time-text\"></span></div><div class=\"vjs-down-scrolltime-annotation\"><span class=\"vjs-time-text\"></span></div>',\n      });\n    };\n\n    videojs.BackAnDisplayScrollTime.prototype.setTimes = function() {\n        var AnPos = this.getAnnotationPosition();\n        var AnEl = this.getElements(AnPos);\n        var AnTimes = this.getTimes(AnEl);\n        if (AnTimes.top != 'Invalid Date') {\n            $(this.el_).find('.vjs-up-scrolltime-annotation')[0].style.visibility = '';\n            $(this.el_).find('.vjs-up-scrolltime-annotation span')[0].innerHTML = AnTimes.top;\n        } else {\n            $(this.el_).find('.vjs-up-scrolltime-annotation')[0].style.visibility = 'hidden';\n        }\n        if (AnTimes.bottom != 'Invalid Date') {\n            $(this.el_).find('.vjs-down-scrolltime-annotation')[0].style.visibility = '';\n            $(this.el_).find('.vjs-down-scrolltime-annotation span')[0].innerHTML = AnTimes.bottom;\n        } else {\n            $(this.el_).find('.vjs-down-scrolltime-annotation')[0].style.visibility = 'hidden';\n        }\n    };\n\n    videojs.BackAnDisplayScrollTime.prototype.getAnnotationPosition = function() {\n        var backDSBarSel = this.an.backDSBarSel;\n        var percent = backDSBarSel.parseMaxPercent(parseFloat(backDSBarSel.el_.style.top) / 100);\n        var scroll = this.an.AnDisplay.el_;\n        var maxTop = scroll.scrollHeight;\n        var minTop = scroll.offsetHeight;\n        var maxBottom = maxTop - minTop;\n        var minBottom = 0;\n        var pos = {};\n        \n        percent = percent || 0;\n        pos.top = Math.max(minTop, Math.min(maxTop, maxBottom * percent + scroll.offsetHeight));\n        pos.bottom = Math.max(minBottom, Math.min(maxBottom, maxBottom * percent));\n        return pos;\n    };\n\n    videojs.BackAnDisplayScrollTime.prototype.getElements = function(AnPos) {\n        var AnPos = AnPos || {};\n        var scroll = this.an.AnDisplay.el_;\n        var emtoPx = parseFloat($(scroll).find('.annotation').css('height'));\n        var maxTop = parseInt(scroll.scrollHeight / emtoPx);\n        var minTop = parseInt(scroll.offsetHeight / emtoPx);\n        var maxBottom = (maxTop - minTop);\n        var minBottom = 0;\n        var AnEl = {};\n        AnEl.top = Math.max(minTop, Math.min(maxTop, parseInt(AnPos.top / emtoPx)));\n        AnEl.bottom = Math.max(minBottom, Math.min(maxBottom, parseInt(AnPos.bottom / emtoPx)));\n        return AnEl;\n    };\n\n    videojs.BackAnDisplayScrollTime.prototype.getTimes = function(AnEl) {\n        var AnEl = AnEl || {};\n        var AnTimes = {};\n        var TopEl, BottomEl, AnTop, AnBottom;\n        var AnArray = $.makeArray(this.an.AnDisplay.el_.children);\n        AnEl.top = AnEl.top || 0;\n        AnEl.bottom = AnEl.bottom || 0;\n        \n        // Get HTML Elements\n        var count = 0;\n        var lastEl;\n        for (var index in AnArray) {\n            var an = AnArray[index];\n            if (an.style.display !== 'none') {\n                if (count == AnEl.bottom) {\n                    TopEl = an;\n                } else if (count == AnEl.top) {\n                    BottomEl = an;\n                }\n                lastEl = an;\n                count++;\n            }\n        }\n        if (typeof BottomEl === 'undefined')\n            BottomEl = lastEl;\n            \n        // Annotation Element\n        AnTop = typeof TopEl !== 'undefined' ? $.data(TopEl, 'annotation') : undefined;\n        AnBottom = typeof BottomEl !== 'undefined' ? $.data(BottomEl, 'annotation') : undefined;\n        // Update of the element\n        AnTimes.top = (typeof AnTop !== 'undefined' && typeof AnTop.updated !== 'undefined') ? AnTop.updated : '';\n        AnTimes.bottom = (typeof AnBottom !=='undefined' && typeof AnBottom.updated !== 'undefined') ? AnBottom.updated : '';\n        // Format\n        AnTimes.top = new Date(AnTimes.top !== '' ? createDateFromISO8601(AnTimes.top) : '');\n        AnTimes.bottom = new Date(AnTimes.bottom != '' ? createDateFromISO8601(AnTimes.bottom) : '');\n        return AnTimes;\n    };\n}) ();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/static/vendors/development/video.dev.js */ \"./src/static/vendors/development/video.dev.js\")))\n\n//# sourceURL=webpack:///./src/static/vendors/development/videojs-annotator-plugin.js?");

/***/ }),

/***/ "./src/static/vendors/development/videojs-transcript.js":
/*!**************************************************************!*\
  !*** ./src/static/vendors/development/videojs-transcript.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*! videojs-transcript - v0.7.1 - 2014-10-10\n* Copyright (c) 2014 Matthew Walsh; Licensed MIT */\n(function (window, videojs) {\n  'use strict';\n\n\n// requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel\n// MIT license\n// https://gist.github.com/paulirish/1579671\n(function() {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']\n    || window[vendors[x]+'CancelRequestAnimationFrame'];\n  }\n  if (!window.requestAnimationFrame)\n    window.requestAnimationFrame = function(callback, element) {\n      var currTime = new Date().getTime();\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n      timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  if (!window.cancelAnimationFrame)\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n}());\n\n// Object.create() polyfill\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\nif (typeof Object.create != 'function') {\n  Object.create = (function() {\n    var Object = function() {};\n    return function (prototype) {\n      if (arguments.length > 1) {\n        throw Error('Second argument not supported');\n      }\n      if (typeof prototype != 'object') {\n        throw TypeError('Argument must be an object');\n      }\n      Object.prototype = prototype;\n      var result = new Object();\n      Object.prototype = null;\n      return result;\n    };\n  })();\n}\n\n// forEach polyfill\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Polyfill\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function(callback, thisArg) {\n    var T, k;\n    if (this == null) {\n      throw new TypeError(' this is null or not defined');\n    }\n    var O = Object(this);\n    var len = O.length >>> 0;\n    if (typeof callback != \"function\") {\n      throw new TypeError(callback + ' is not a function');\n    }\n    if (arguments.length > 1) {\n      T = thisArg;\n    }\n    k = 0;\n    while (k < len) {\n      var kValue;\n      if (k in O) {\n        kValue = O[k];\n        callback.call(T, kValue, k, O);\n      }\n      k++;\n    }\n  };\n}\n\n// classList polyfill\n/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/\n;if(\"document\" in self&&!(\"classList\" in document.createElement(\"_\"))){(function(j){\"use strict\";if(!(\"Element\" in j)){return}var a=\"classList\",f=\"prototype\",m=j.Element[f],b=Object,k=String[f].trim||function(){return this.replace(/^\\s+|\\s+$/g,\"\")},c=Array[f].indexOf||function(q){var p=0,o=this.length;for(;p<o;p++){if(p in this&&this[p]===q){return p}}return -1},n=function(o,p){this.name=o;this.code=DOMException[o];this.message=p},g=function(p,o){if(o===\"\"){throw new n(\"SYNTAX_ERR\",\"An invalid or illegal string was specified\")}if(/\\s/.test(o)){throw new n(\"INVALID_CHARACTER_ERR\",\"String contains an invalid character\")}return c.call(p,o)},d=function(s){var r=k.call(s.getAttribute(\"class\")||\"\"),q=r?r.split(/\\s+/):[],p=0,o=q.length;for(;p<o;p++){this.push(q[p])}this._updateClassName=function(){s.setAttribute(\"class\",this.toString())}},e=d[f]=[],i=function(){return new d(this)};n[f]=Error[f];e.item=function(o){return this[o]||null};e.contains=function(o){o+=\"\";return g(this,o)!==-1};e.add=function(){var s=arguments,r=0,p=s.length,q,o=false;do{q=s[r]+\"\";if(g(this,q)===-1){this.push(q);o=true}}while(++r<p);if(o){this._updateClassName()}};e.remove=function(){var t=arguments,s=0,p=t.length,r,o=false;do{r=t[s]+\"\";var q=g(this,r);if(q!==-1){this.splice(q,1);o=true}}while(++s<p);if(o){this._updateClassName()}};e.toggle=function(p,q){p+=\"\";var o=this.contains(p),r=o?q!==true&&\"remove\":q!==false&&\"add\";if(r){this[r](p)}return !o};e.toString=function(){return this.join(\" \")};if(b.defineProperty){var l={get:i,enumerable:true,configurable:true};try{b.defineProperty(m,a,l)}catch(h){if(h.number===-2146823252){l.enumerable=false;b.defineProperty(m,a,l)}}}else{if(b[f].__defineGetter__){m.__defineGetter__(a,i)}}}(self))};\n\n\n\n// Global settings\nvar my = {};\nmy.settings = {};\nmy.prefix = 'transcript';\nmy.player = this;\n\n// Defaults\nvar defaults = {\n  autoscroll: true,\n  clickArea: 'text',\n  showTitle: true,\n  showTrackSelector: true,\n  followPlayerTrack: true,\n  stopScrollWhenInUse: true,\n};\n\n/*global my*/\nvar utils = (function (plugin) {\n  return {\n    secondsToTime: function (timeInSeconds) {\n      var hour = Math.floor(timeInSeconds / 3600);\n      var min = Math.floor(timeInSeconds % 3600 / 60);\n      var sec = Math.floor(timeInSeconds % 60);\n      sec = (sec < 10) ? '0' + sec : sec;\n      min = (hour > 0 && min < 10) ? '0' + min : min;\n      if (hour > 0) {\n        return hour + ':' + min + ':' + sec;\n      }\n      return min + ':' + sec;\n    },\n    localize: function (string) {\n      return string; // TODO: do something here;\n    },\n    createEl: function (elementName, classSuffix) {\n      classSuffix = classSuffix || '';\n      var el = document.createElement(elementName);\n      el.className = plugin.prefix + classSuffix;\n      return el;\n    },\n    extend: function(obj) {\n      var type = typeof obj;\n      if (!(type === 'function' || type === 'object' && !!obj)) {\n        return obj;\n      }\n      var source, prop;\n      for (var i = 1, length = arguments.length; i < length; i++) {\n        source = arguments[i];\n        for (prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n      return obj;\n    }\n  };\n}(my));\n\nvar eventEmitter = {\n  handlers_: [],\n  on: function on (object, eventtype, callback) {\n    if (typeof callback === 'function') {\n      this.handlers_.push([object, eventtype, callback]);\n    } else {\n      throw new TypeError('Callback is not a function.');\n    }\n  },\n  trigger: function trigger (object, eventtype) {\n    this.handlers_.forEach( function(h) {\n      if (h[0] === object &&\n          h[1] === eventtype) {\n            h[2].apply();\n      }\n    });\n  }\n};\n\nvar scrollerProto = function(plugin) {\n\n  var initHandlers = function (el) {\n    var self = this;\n    // The scroll event. We want to keep track of when the user is scrolling the transcript.\n    el.addEventListener('scroll', function () {\n      if (self.isAutoScrolling) {\n\n        // If isAutoScrolling was set to true, we can set it to false and then ignore this event.\n        // It wasn't the user.\n        self.isAutoScrolling = false; // event handled\n      } else {\n\n        // We only care about when the user scrolls. Set userIsScrolling to true and add a nice class.\n        self.userIsScrolling = true;\n        el.classList.add('is-inuse');\n      }\n    });\n\n    // The mouseover event.\n    el.addEventListener('mouseenter', function () {\n      self.mouseIsOverTranscript = true;\n    });\n    el.addEventListener('mouseleave', function () {\n      self.mouseIsOverTranscript = false;\n\n      // Have a small delay before deciding user as done interacting.\n      setTimeout(function () {\n\n        // Make sure the user didn't move the pointer back in.\n        if (!self.mouseIsOverTranscript) {\n          self.userIsScrolling = false;\n          el.classList.remove('is-inuse');\n        }\n      }, 1000);\n    });\n  };\n\n  // Init instance variables\n  var init = function (element, plugin) {\n    this.element = element;\n    this.userIsScrolling = false;\n\n    //default to true in case user isn't using a mouse;\n    this.mouseIsOverTranscript = true;\n    this.isAutoScrolling = true;\n    initHandlers.call(this, this.element);\n    return this;\n  };\n\n  // Easing function for smoothness.\n  var easeOut = function (time, start, change, duration) {\n    return start + change * Math.sin(Math.min(1, time / duration) * (Math.PI / 2));\n  };\n\n  // Animate the scrolling.\n  var scrollTo = function (element, newPos, duration) {\n    var startTime = Date.now();\n    var startPos = element.scrollTop;\n    var self = this;\n\n    // Don't try to scroll beyond the limits. You won't get there and this will loop forever.\n    newPos = Math.max(0, newPos);\n    newPos = Math.min(element.scrollHeight - element.clientHeight, newPos);\n    var change = newPos - startPos;\n\n    // This inner function is called until the elements scrollTop reaches newPos.\n    var updateScroll = function () {\n      var now = Date.now();\n      var time = now - startTime;\n      self.isAutoScrolling = true;\n      element.scrollTop = easeOut(time, startPos, change, duration);\n      if (element.scrollTop !== newPos) {\n        requestAnimationFrame(updateScroll, element);\n      }\n    };\n    requestAnimationFrame(updateScroll, element);\n  };\n\n  // Scroll an element's parent so the element is brought into view.\n  var scrollToElement = function (element) {\n    if (this.canScroll(element)) {\n      var parent = element.parentElement.parentElement.parentElement;\n      var parentOffsetBottom = parent.offsetTop + parent.clientHeight;\n      var elementOffsetBottom = element.offsetTop + element.clientHeight;\n      var relTop = element.offsetTop - parent.offsetTop;\n      var relBottom = (element.offsetTop + element.clientHeight) - parent.offsetTop;\n      var newPos;\n\n      // If the top of the line is above the top of the parent view, were scrolling up,\n      // so we want to move the top of the element downwards to match the top of the parent.\n      if (relTop < parent.scrollTop) {\n        newPos = element.offsetTop - parent.offsetTop;\n\n      // If the bottom of the line is below the parent view, we're scrolling down, so we want the\n      // bottom edge of the line to move up to meet the bottom edge of the parent.\n      } else if (relBottom > (parent.scrollTop + parent.clientHeight)) {\n        newPos = elementOffsetBottom - parentOffsetBottom;\n      }\n\n      // Don't try to scroll if we haven't set a new position.  If we didn't\n      // set a new position the line is already in view (i.e. It's not above\n      // or below the view)\n      // And don't try to scroll when the element is already in position.\n      if (newPos !== undefined && parent.scrollTop !== newPos) {\n        scrollTo.call(this, parent, newPos, 400);\n      }\n    }\n  };\n\n  // Return whether the element is scrollable.\n  var canScroll = function (element) {\n    var el = this.element;\n    var scrollable = el.scrollHeight+el.offsetTop;\n    var offsettop = element.offsetTop + element.clientHeight;\n    return scrollable > offsettop;\n  };\n\n  // Return whether the user is interacting with the transcript.\n  var inUse = function () {\n    return this.userIsScrolling;\n  };\n\n  return {\n    init: init,\n    to : scrollToElement,\n    canScroll : canScroll,\n    inUse : inUse\n  }\n}(my);\n\nvar scroller = function(element) {\n  return Object.create(scrollerProto).init(element);\n};\n\n\n/*global my*/\nvar trackList = function (plugin) {\n  var activeTrack;\n  return {\n    get: function () {\n      var validTracks = [];\n      my.tracks = my.player.textTracks();\n      my.tracks.forEach(function (track) {\n        if (track.kind() === 'captions' || track.kind() === 'subtitles') {\n          validTracks.push(track);\n        }\n      });\n      return validTracks;\n    },\n    active: function (tracks) {\n      tracks.forEach(function (track) {\n        if (track.mode() === 2) {\n          activeTrack = track;\n          return track;\n        }\n      });\n      // fallback to first track\n      return activeTrack || tracks[0];\n    },\n  };\n}(my);\n\n/*globals utils, eventEmitter, my, scrollable*/\n\nvar widget = function (plugin) {\n  var my = {};\n  my.element = {};\n  my.body = {};\n  var on = function (event, callback) {\n    eventEmitter.on(this, event, callback);\n  };\n  var trigger = function (event) {\n    eventEmitter.trigger(this, event);\n  };\n  var createTitle = function () {\n    var header = utils.createEl('header', '-header');\n    header.textContent = utils.localize('Transcript');\n    return header;\n  };\n  var createSelector = function (){\n    var selector = utils.createEl('select', '-selector');\n      plugin.validTracks.forEach(function (track, i) {\n      var option = document.createElement('option');\n      option.value = i;\n      option.textContent = track.label() + ' (' + track.language() + ')';\n      selector.appendChild(option);\n    });\n    selector.addEventListener('change', function (e) {\n      setTrack(document.querySelector('#' + plugin.prefix + '-' + plugin.player.id() + ' option:checked').value);\n      trigger('trackchanged');\n    });\n    return selector;\n  };\n  var clickToSeekHandler = function (event) {\n    var clickedClasses = event.target.classList;\n    var clickedTime = event.target.getAttribute('data-begin') || event.target.parentElement.getAttribute('data-begin');\n    if (clickedTime !== undefined && clickedTime !== null) { // can be zero\n      if ((plugin.settings.clickArea === 'line') || // clickArea: 'line' activates on all elements\n        (plugin.settings.clickArea === 'timestamp' && clickedClasses.contains(plugin.prefix + '-timestamp')) ||\n        (plugin.settings.clickArea === 'text' && clickedClasses.contains(plugin.prefix + '-text'))) {\n        plugin.player.currentTime(clickedTime);\n      }\n    }\n  };\n  var createLine = function (cue) {\n    var line = utils.createEl('div', '-line');\n    var timestamp = utils.createEl('span', '-timestamp');\n    var text = utils.createEl('span', '-text');\n    line.setAttribute('data-begin', cue.startTime);\n    timestamp.textContent = utils.secondsToTime(cue.startTime);\n    text.innerHTML = cue.text;\n    line.appendChild(timestamp);\n    line.appendChild(text);\n    return line;\n  };\n  var createTranscriptBody = function (track) {\n    if (typeof track !== 'object') {\n      track = plugin.player.textTracks()[track];\n    }\n    var body = utils.createEl('div', '-body');\n    var line, i;\n    var fragment = document.createDocumentFragment();\n    var createTranscript = function () {\n      var cues = track.cues();\n      for (i = 0; i < cues.length; i++) {\n        line = createLine(cues[i]);\n        fragment.appendChild(line);\n      }\n      body.innerHTML = '';\n      body.appendChild(fragment);\n      body.setAttribute('lang', track.language());\n    };\n    if (track.readyState() !==2) {\n      track.load();\n      track.on('loaded', createTranscript);\n    } else {\n      createTranscript();\n    }\n    body.scroll = scroller(body);\n    body.addEventListener('click', clickToSeekHandler);\n    return body;\n  };\n  var create = function () {\n    var el = document.createElement('div');\n    my.element = el;\n    el.setAttribute('id', plugin.prefix + '-' + plugin.player.id());\n    if (plugin.settings.showTitle) {\n      var title = createTitle();\n      el.appendChild(title);\n    }\n    if (plugin.settings.showTrackSelector) {\n      var selector = createSelector();\n      el.appendChild(selector);\n    }\n    my.body = utils.createEl('div', '-body');\n    el.appendChild(my.body);\n    setTrack(plugin.currentTrack);\n    return this;\n  };\n  var setTrack = function (track) {\n    var newBody = createTranscriptBody(track);\n    my.element.replaceChild(newBody, my.body);\n    my.body = newBody;\n  };\n  var setCue = function (time) {\n    var active, i, line, begin, end;\n    var lines = my.body.children;\n    for (i = 0; i < lines.length; i++) {\n      line = lines[i];\n      begin = line.getAttribute('data-begin');\n      if (i < lines.length - 1) {\n        end = lines[i + 1].getAttribute('data-begin');\n      } else {\n        end = plugin.player.duration() || Infinity;\n      }\n      if (time > begin && time < end) {\n        if (!line.classList.contains('is-active')) { // don't update if it hasn't changed\n          line.classList.add('is-active');\n          if (plugin.settings.autoscroll && !(plugin.settings.stopScrollWhenInUse && my.body.scroll.inUse())) {\n              my.body.scroll.to(line);\n          }\n        }\n      } else {\n        line.classList.remove('is-active');\n      }\n    }\n  };\n  var el = function () {\n    return my.element;\n  };\n  return {\n    create: create,\n    setTrack: setTrack,\n    setCue: setCue,\n    el : el,\n    on: on,\n    trigger: trigger,\n  };\n\n}(my);\n\nvar transcript = function (options) {\n  my.player = this;\n  my.validTracks = trackList.get();\n  my.currentTrack = trackList.active(my.validTracks);\n  my.settings = jQuery.extend({}, defaults, options);\n  my.widget = widget.create();\n  var timeUpdate = function () {\n    my.widget.setCue(my.player.currentTime());\n  };\n  var updateTrack = function () {\n    my.currentTrack = trackList.active(my.validTracks);\n    my.widget.setTrack(my.currentTrack);\n  };\n  if (my.validTracks.length > 0) {\n    updateTrack();\n    my.player.on('timeupdate', timeUpdate);\n    if (my.settings.followPlayerTrack) {\n      my.player.on('captionstrackchange', updateTrack);\n      my.player.on('subtitlestrackchange', updateTrack);\n    }\n  } else {\n    throw new Error('videojs-transcript: No tracks found!');\n  }\n  return {\n    el: function () {\n      return my.widget.el();\n    },\n    setTrack: my.widget.setTrack\n  };\n};\nvideojs.plugin('transcript', transcript);\n\n}(window,  true ? __webpack_require__(/*! videojs */ \"./src/static/vendors/development/video.dev.js\") : undefined));\n\n\n//# sourceURL=webpack:///./src/static/vendors/development/videojs-transcript.js?");

/***/ }),

/***/ "./src/static/vendors/development/vjs.youtube.js":
/*!*******************************************************!*\
  !*** ./src/static/vendors/development/vjs.youtube.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @fileoverview YouTube Media Controller - Wrapper for YouTube Media API\n */\n\n/**\n * YouTube Media Controller - Wrapper for YouTube Media API\n * @param {vjs.Player|Object} player\n * @param {Object=} options\n * @param {Function=} ready\n * @constructor\n */\nvjs.Youtube = vjs.MediaTechController.extend({\n  /** @constructor */\n  init: function(player, options, ready){\n    vjs.MediaTechController.call(this, player, options, ready);\n    \n    // No event is triggering this for YouTube\n    this.features['progressEvents'] = false;\n    this.features['timeupdateEvents'] = false;\n\n    // Copy the JavaScript options if they exists\n    if (typeof options['source'] != 'undefined') {\n      for (var key in options['source']) {\n        player.options()[key] = options['source'][key];\n      }\n    }\n\n    this.userQuality = vjs.Youtube.convertQualityName(player.options()['quality']);\n\n    // Save those for internal usage\n    this.player_ = player;\n    this.player_el_ = document.getElementById(player.id());\n    this.player_el_.className += ' vjs-youtube';\n\n    // Mobile devices are using their own native players\n    if (!!navigator.userAgent.match(/iPhone/i) || !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPod/i) || !!navigator.userAgent.match(/Android.*AppleWebKit/i)) {\n      player.options()['ytcontrols'] = true;\n    }\n\n    // Create the Quality button\n    this.qualityButton = document.createElement('div');\n    this.qualityButton.setAttribute('class', 'vjs-quality-button vjs-menu-button vjs-control');\n    this.qualityButton.setAttribute('tabindex', 0);\n    \n    var qualityContent = document.createElement('div');\n    this.qualityButton.appendChild(qualityContent);\n    \n    this.qualityTitle = document.createElement('span');\n    qualityContent.appendChild(this.qualityTitle);\n    \n    var qualityMenu = document.createElement('div');\n    qualityMenu.setAttribute('class', 'vjs-menu');\n    this.qualityButton.appendChild(qualityMenu);\n    \n    this.qualityMenuContent = document.createElement('ul');\n    this.qualityMenuContent.setAttribute('class', 'vjs-menu-content');\n    qualityMenu.appendChild(this.qualityMenuContent);\n\n    this.id_ = this.player_.id() + '_youtube_api';\n\n    this.el_ = vjs.Component.prototype.createEl('iframe', {\n      id: this.id_,\n      className: 'vjs-tech',\n      scrolling: 'no',\n      marginWidth: 0,\n      marginHeight: 0,\n      frameBorder: 0,\n      title:'Youtube Video',\n      webkitAllowFullScreen: 'true',\n      mozallowfullscreen: 'true',\n      allowFullScreen: 'true'\n    });\n\n    // This makes sure the mousemove is not lost within the iframe\n    // Only way to make sure the control bar shows when we come back in the video player\n    this.iframeblocker = vjs.Component.prototype.createEl('div', {\n      className: 'iframeblocker'\n    });\n\n    // Make sure to not block the play or pause\n    var self = this;\n    var toggleThis = function() {\n      if (self.paused()) {\n        self.play();\n      } else {\n        self.pause();\n      }\n    };\n\n    this.iframeblocker.addEventListener('click', toggleThis);\n    this.iframeblocker.addEventListener('mousemove', function(e) {\n      if (!self.player_.userActive()) {\n        self.player_.userActive(true);\n      }\n      \n      e.stopPropagation();\n      e.preventDefault();\n    });\n\n    if (!this.player_.options()['ytcontrols']) {\n      // Before the tech is ready, we have to take care of the play action\n      this.iframeblocker.style.display = 'block';\n    }\n\n    this.player_el_.insertBefore(this.iframeblocker, this.player_el_.firstChild);\n    this.player_el_.insertBefore(this.el_, this.iframeblocker);\n\n    this.parseSrc(player.options()['src']);\n\n    this.playOnReady = this.player_.options()['autoplay'] || false;\n\n    var params = {\n      enablejsapi: 1,\n      iv_load_policy: 3,\n      playerapiid: this.id(),\n      disablekb: 1,\n      wmode: 'transparent',\n      controls: (this.player_.options()['ytcontrols'])?1:0,\n      showinfo: 0,\n      modestbranding: 1,\n      rel: 0,\n      autoplay: (this.playOnReady)?1:0,\n      loop: (this.player_.options()['loop'])?1:0,\n      list: this.playlistId,\n      vq: this.userQuality\n    };\n\n    if (typeof params.list == 'undefined') {\n      delete params.list;\n    }\n\n    // If we are not on a server, don't specify the origin (it will crash)\n    if (window.location.protocol != 'file:'){\n      params.origin = window.location.protocol + '//' + window.location.host;\n      this.el_.src = window.location.protocol + '//www.youtube.com/embed/' + this.videoId + '?' + vjs.Youtube.makeQueryString(params);\n    } else {\n      this.el_.src = 'https://www.youtube.com/embed/' + this.videoId + '?' + vjs.Youtube.makeQueryString(params);\n    }\n\n    var self = this;\n    player.ready(function(){\n      var controlBar = self.player_el_.getElementsByClassName('vjs-control-bar')[0];\n      controlBar.appendChild(self.qualityButton);\n\n      if (self.playOnReady && !self.player_.options()['ytcontrols']) {\n        self.player_.loadingSpinner.show();\n        self.player_.bigPlayButton.hide();\n      }\n    });\n\n    if (this.player_.options()['ytcontrols']){\n      // Disable the video.js controls if we use the YouTube controls\n      this.player_.controls(false);\n    } else {\n      // Show the YouTube poster if their is no custom poster\n      if (!this.player_.poster()) {\n        if (this.videoId == null) {\n          // Set the black background if their is no video initially\n          this.iframeblocker.style.backgroundColor = 'black';\n        } else {\n          this.player_.poster('https://img.youtube.com/vi/' + this.videoId + '/maxresdefault.jpg');\n        }\n      }\n    }\n\n    if (vjs.Youtube.apiReady){\n      this.loadYoutube();\n    } else {\n      // Add to the queue because the YouTube API is not ready\n      vjs.Youtube.loadingQueue.push(this);\n\n      // Load the YouTube API if it is the first YouTube video\n      if(!vjs.Youtube.apiLoading){\n        var tag = document.createElement('script');\n        tag.src = '//www.youtube.com/iframe_api';\n        var firstScriptTag = document.getElementsByTagName('script')[0];\n        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n        vjs.Youtube.apiLoading = true;\n      }\n    }\n    \n    this.on('dispose', function() {\n      // Get rid of the created DOM elements\n      this.el_.parentNode.removeChild(this.el_);\n      this.iframeblocker.parentNode.removeChild(this.iframeblocker);\n      this.qualityButton.parentNode.removeChild(this.qualityButton);\n      \n      this.player_.loadingSpinner.hide();\n      this.player_.bigPlayButton.hide();\n    });\n  }\n});\n\nvjs.Youtube.prototype.parseSrc = function(src){\n  this.srcVal = src;\n  \n  if (src) {\n    // Regex to parse the video ID\n    var regId = /^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|\\&v=)([^#\\&\\?]*).*/;\n    var match = src.match(regId);\n    \n    if (match && match[2].length == 11){\n      this.videoId = match[2];\n    } else {\n      this.videoId = null;\n    }\n    \n    // Regex to parse the playlist ID\n    var regPlaylist = /[?&]list=([^#\\&\\?]+)/;\n    match = src.match(regPlaylist);\n    \n    if (match != null && match.length > 1) {\n      this.playlistId = match[1];\n    } else {\n      // Make sure their is no playlist\n      if (this.playlistId) {\n        delete this.playlistId;\n      }\n    }\n\n    // Parse video quality option\n    var regVideoQuality = /[?&]vq=([^#\\&\\?]+)/;\n    match = src.match(regVideoQuality);\n\n    if (match != null && match.length > 1) {\n      this.userQuality = match[1];\n    }\n  }\n};\n\nvjs.Youtube.prototype.src = function(src){\n  if (src) {\n    this.parseSrc(src);\n\n    if (this.videoId == null) {\n      // Set the black background if the URL isn't valid\n      this.iframeblocker.style.backgroundColor = 'black';\n      this.iframeblocker.style.display = 'block';\n    } else {\n      this.ytplayer.loadVideoById({\n        videoId: this.videoId,\n        suggestedQuality: this.userQuality\n      });\n\n      // Update the poster\n      this.player_el_.getElementsByClassName('vjs-poster')[0].style.backgroundImage = 'url(https://img.youtube.com/vi/' + this.videoId + '/maxresdefault.jpg)';\n      this.iframeblocker.style.backgroundColor = '';\n      this.iframeblocker.style.display = '';\n      this.player_.poster('https://img.youtube.com/vi/' + this.videoId + '/maxresdefault.jpg');\n    }\n  }\n\n  return this.srcVal;\n};\n\nvjs.Youtube.prototype.load = function(){};\n\nvjs.Youtube.prototype.play = function(){\n  if (this.videoId != null) {\n    // Make sure to not display the spinner for mobile\n    if (!this.player_.options()['ytcontrols']) {\n      // Display the spinner until the video is playing by YouTube\n      this.player_.trigger('waiting');\n    }\n    \n    if (this.isReady_){\n      this.ytplayer.playVideo();\n    } else {\n      this.playOnReady = true;\n    }\n  }\n};\n\nvjs.Youtube.prototype.pause = function(){ this.ytplayer.pauseVideo(); };\nvjs.Youtube.prototype.paused = function(){ return (this.ytplayer)?(this.lastState !== YT.PlayerState.PLAYING && this.lastState !== YT.PlayerState.BUFFERING):true; };\nvjs.Youtube.prototype.currentTime = function(){ return (this.ytplayer && this.ytplayer.getCurrentTime)?this.ytplayer.getCurrentTime():0; };\nvjs.Youtube.prototype.setCurrentTime = function(seconds){ this.ytplayer.seekTo(seconds, true); this.player_.trigger('timeupdate'); };\nvjs.Youtube.prototype.playbackRate = function(){ return this.ytplayer.getPlaybackRate();};\nvjs.Youtube.prototype.setPlaybackRate = function(rate) {this.ytplayer.setPlaybackRate(rate);};\nvjs.Youtube.prototype.duration = function(){ return (this.ytplayer && this.ytplayer.getDuration)?this.ytplayer.getDuration():0; };\n\nvjs.Youtube.prototype.volume = function() {\n  if (this.ytplayer && isNaN(this.volumeVal)) {\n    this.volumeVal = this.ytplayer.getVolume() / 100.0;\n  }\n\n  return this.volumeVal;\n};\n\nvjs.Youtube.prototype.setVolume = function(percentAsDecimal){\n  if (percentAsDecimal && percentAsDecimal != this.volumeVal) {\n    this.ytplayer.setVolume(percentAsDecimal * 100.0);\n    this.volumeVal = percentAsDecimal;\n    this.player_.trigger('volumechange');\n  }\n};\n\nvjs.Youtube.prototype.muted = function() { return this.mutedVal; };\nvjs.Youtube.prototype.setMuted = function(muted) {\n  if (muted) {\n    this.ytplayer.mute();\n  } else {\n    this.ytplayer.unMute();\n  }\n\n  this.mutedVal = muted;\n  this.player_.trigger('volumechange');\n};\n\nvjs.Youtube.prototype.buffered = function(){\n  if (this.ytplayer && this.ytplayer.getVideoBytesLoaded) {\n    var loadedBytes = this.ytplayer.getVideoBytesLoaded();\n    var totalBytes = this.ytplayer.getVideoBytesTotal();\n    if (!loadedBytes || !totalBytes) return 0;\n\n    var duration = this.ytplayer.getDuration();\n    var secondsBuffered = (loadedBytes / totalBytes) * duration;\n    var secondsOffset = (this.ytplayer.getVideoStartBytes() / totalBytes) * duration;\n\n    return vjs.createTimeRange(secondsOffset, secondsOffset + secondsBuffered);\n  } else {\n    return vjs.createTimeRange(0, 0);\n  }\n};\n\nvjs.Youtube.prototype.supportsFullScreen = function(){ return true; };\n\n// YouTube is supported on all platforms\nvjs.Youtube.isSupported = function(){ return true; };\n\n// You can use video/youtube as a media in your HTML5 video to specify the source\nvjs.Youtube.canPlaySource = function(srcObj){\n  return (srcObj.type == 'video/youtube');\n};\n\n// Always can control the volume\nvjs.Youtube.canControlVolume = function(){ return true; };\n\n////////////////////////////// YouTube specific functions //////////////////////////////\n\n// All videos created before YouTube API is loaded\nvjs.Youtube.loadingQueue = [];\n\n// Create the YouTube player\nvjs.Youtube.prototype.loadYoutube = function(){\n  this.ytplayer = new YT.Player(this.id_, {\n    events: {\n      onReady: function(e) { e.target.vjsTech.onReady(); },\n      onStateChange: function(e) { e.target.vjsTech.onStateChange(e.data); },\n      onPlaybackQualityChange: function(e){ e.target.vjsTech.onPlaybackQualityChange(e.data); },\n      onError: function(e){ e.target.vjsTech.onError(e.data); }\n    }\n  });\n\n  this.ytplayer.vjsTech = this;\n};\n\n// Transform a JavaScript object into URL params\nvjs.Youtube.makeQueryString = function(args){\n  var array = [];\n  for (var key in args){\n    if (args.hasOwnProperty(key)){\n      array.push(encodeURIComponent(key) + '=' + encodeURIComponent(args[key]));\n    }\n  }\n\n  return array.join('&');\n};\n\n// Called when YouTube API is ready to be used\nwindow.onYouTubeIframeAPIReady = function(){\n  var yt;\n  while ((yt = vjs.Youtube.loadingQueue.shift())){\n    yt.loadYoutube();\n  }\n  vjs.Youtube.loadingQueue = [];\n  vjs.Youtube.apiReady = true;\n};\n\nvjs.Youtube.prototype.onReady = function(){\n  this.isReady_ = true;\n  this.triggerReady();\n\n  // Let the player take care of itself as soon as the YouTube is ready\n  // The loading spinner while waiting for the tech would be impossible otherwise\n  this.iframeblocker.style.display = '';\n  this.player_.loadingSpinner.hide();\n\n  if (this.player_.options()['muted']) {\n    this.setMuted(true);\n  }\n\n  // Play ASAP if they clicked play before it's ready\n  if (this.playOnReady) {\n    this.playOnReady = false;\n    this.play();\n  }\n};\n\nvjs.Youtube.prototype.updateQualities = function(){\n  var qualities = this.ytplayer.getAvailableQualityLevels();\n  \n  if (qualities.length == 0) {\n    this.qualityButton.style.display = 'none';\n  } else {\n    this.qualityButton.style.display = '';\n    \n    while (this.qualityMenuContent.hasChildNodes()) {\n      this.qualityMenuContent.removeChild(this.qualityMenuContent.lastChild);\n    }\n\n    for (var i = 0; i < qualities.length; ++i) {\n      var el = document.createElement('li');\n      el.setAttribute('class', 'vjs-menu-item');\n\n      setInnerText(el, vjs.Youtube.parseQualityName(qualities[i]));\n\n      el.setAttribute('data-val', qualities[i]);\n      if (qualities[i] == this.quality) el.classList.add('vjs-selected');\n      \n      var self = this;\n      \n      el.addEventListener('click', function() {\n        var quality = this.getAttribute('data-val');\n        self.ytplayer.setPlaybackQuality(quality);\n        \n        setInnerText(self.qualityTitle, vjs.Youtube.parseQualityName(quality));\n        \n        var selected = self.qualityMenuContent.querySelector('.vjs-selected');\n        if (selected) selected.classList.remove('vjs-selected');\n        \n        this.classList.add('vjs-selected');\n      });\n      \n      this.qualityMenuContent.appendChild(el);\n    }\n  }\n};\n\nvjs.Youtube.prototype.onStateChange = function(state){\n  if (state != this.lastState){\n    switch(state){\n      case -1:\n        this.player_.trigger('durationchange');\n        break;\n\n      case YT.PlayerState.ENDED:\n        // Replace YouTube play button by our own\n        if (!this.player_.options()['ytcontrols']) {\n          // commented out because adding the first line pushes the live transcript down\n          // and the second line has a button appear over the youtube play button and looks weird.\n          //this.player_el_.getElementsByClassName('vjs-poster')[0].style.display = 'block';\n          //this.player_.bigPlayButton.show();\n        }\n\n        this.player_.trigger('ended');\n        break;\n\n      case YT.PlayerState.PLAYING:\n        // Make sure the big play is not there\n        this.player_.bigPlayButton.hide();\n\n        this.updateQualities();\n\n        this.player_.trigger('timeupdate');\n        this.player_.trigger('durationchange');\n        this.player_.trigger('playing');\n        this.player_.trigger('play');\n        break;\n\n      case YT.PlayerState.PAUSED:\n        this.player_.trigger('pause');\n        break;\n\n      case YT.PlayerState.BUFFERING:\n        this.player_.trigger('timeupdate');\n        \n        // Make sure to not display the spinner for mobile\n        if (!this.player_.options()['ytcontrols']) {\n          this.player_.trigger('waiting');\n        }\n        break;\n\n      case YT.PlayerState.CUED:\n        break;\n    }\n\n    this.lastState = state;\n  }\n};\n\nvjs.Youtube.convertQualityName = function(name) {\n  switch (name) {\n    case '144p':\n      return 'tiny';\n\n    case '240p':\n      return 'small';\n\n    case '360p':\n      return 'medium';\n\n    case '480p':\n      return 'large';\n\n    case '720p':\n      return 'hd720';\n\n    case '1080p':\n      return 'hd1080';\n  }\n\n  return name;\n};\n\nvjs.Youtube.parseQualityName = function(name) {\n  switch (name) {\n    case 'tiny':\n      return '144p';\n\n    case 'small':\n      return '240p';\n\n    case 'medium':\n      return '360p';\n\n    case 'large':\n      return '480p';\n\n    case 'hd720':\n      return '720p';\n\n    case 'hd1080':\n      return '1080p';\n  }\n  \n  return name;\n};\n\nvjs.Youtube.prototype.onPlaybackQualityChange = function(quality){\n  this.quality = quality;\n  setInnerText(this.qualityTitle, vjs.Youtube.parseQualityName(quality));\n  \n  switch(quality){\n    case 'medium':\n      this.player_.videoWidth = 480;\n      this.player_.videoHeight = 360;\n      break;\n\n    case 'large':\n      this.player_.videoWidth = 640;\n      this.player_.videoHeight = 480;\n      break;\n\n    case 'hd720':\n      this.player_.videoWidth = 960;\n      this.player_.videoHeight = 720;\n      break;\n\n    case 'hd1080':\n      this.player_.videoWidth = 1440;\n      this.player_.videoHeight = 1080;\n      break;\n\n    case 'highres':\n      this.player_.videoWidth = 1920;\n      this.player_.videoHeight = 1080;\n      break;\n\n    case 'small':\n      this.player_.videoWidth = 320;\n      this.player_.videoHeight = 240;\n      break;\n      \n    case 'tiny':\n      this.player_.videoWidth = 144;\n      this.player_.videoHeight = 108;\n      break;\n\n    default:\n      this.player_.videoWidth = 0;\n      this.player_.videoHeight = 0;\n      break;\n  }\n\n  this.player_.trigger('ratechange');\n};\n\nvjs.Youtube.prototype.onError = function(error){\n  this.player_.error = error;\n  this.player_.trigger('error');\n};\n\n//Cross browser solution to add text content to an element\nfunction setInnerText(element, text) {\n  var textProperty = ('innerText' in element)? 'innerText' : 'textContent';\n  element[textProperty] = text;\n}\n\n// Stretch the YouTube poster\n// Keep the iframeblocker in front of the player when the user is inactive\n// (ONLY way because the iframe is so selfish with events)\n(function() {\n  var style = document.createElement(\"style\");\n  style.type = 'text/css';\n  var css = \" .vjs-youtube .vjs-poster { background-size: cover; }.iframeblocker { display:none;position:absolute;top:0;left:0;width:100%;height:100%;cursor:pointer;z-index:2; }.vjs-youtube.vjs-user-inactive .iframeblocker { display:block; } .vjs-quality-button > div:first-child > span:first-child { position:relative;top:7px }\";\n  setInnerText(style, css);\n  document.getElementsByTagName(\"head\")[0].appendChild(style);\n})();\n\n\n\n//# sourceURL=webpack:///./src/static/vendors/development/vjs.youtube.js?");

/***/ }),

/***/ "./src/video_annotation_core.js":
/*!**************************************!*\
  !*** ./src/video_annotation_core.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return initAnnotations; });\n__webpack_require__(/*! annotator */ \"./src/static/vendors/Annotator/annotator-full.js\");\n__webpack_require__(/*! HighlightTags */ \"./src/static/vendors/Annotator/plugins/highlightTags-annotator.js\");\n__webpack_require__(/*! LocalStore */ \"./src/static/vendors/Annotator/plugins/localstore-annotator.js\");\n__webpack_require__(/*! SummernoteRichText */ \"./src/static/vendors/Annotator/plugins/summernote-richtext-annotator.js\");\n__webpack_require__(/*! TimeRangeEditor */ \"./src/static/vendors/Annotator/plugins/timeRangeEditor-annotator.js\");\n__webpack_require__(/*! VideoJSPlugin */ \"./src/static/vendors/Annotator/plugins/videojs-annotator.js\");\n__webpack_require__(/*! tokeninput */ \"./src/static/vendors/development/jquery.tokeninput.js\");\n__webpack_require__(/*! rangeslider */ \"./src/static/vendors/development/rangeslider.js\");\n__webpack_require__(/*! videojs-annotator */ \"./src/static/vendors/development/videojs-annotator-plugin.js\");\n__webpack_require__(/*! watch */ \"./src/static/vendors/development/jQuery-Watch.js\");\n__webpack_require__(/*! LocalStore */ \"./src/static/vendors/Annotator/plugins/localstore-annotator.js\");\nfunction initAnnotations() {\n    var annotationListURL = jQuery('#annotations-url').html();\n\n    window.annotation_tool = jQuery('#viewer').annotator({\n        showViewPermissionsCheckbox: false,\n        readOnly: annotationListURL.length !== 0,\n    }).data('annotator');\n    \n\n    /**\n     * In order for the following addPlugin lines to work, make sure that the plugins call require on annotator.\n     * Look at the attached versions to standardize the usage throught the plugins\n     */\n     window.annotation_tool.addPlugin('LocalStore', {});\n    window.annotation_tool.addPlugin('VideoJS', {});\n    window.annotation_tool.addPlugin('HighlightTags', {\n        'tag': jQuery('#tags').html()\n    });\n    window.annotation_tool.addPlugin('TimeRangeEditor', {});\n    window.annotation_tool.addPlugin('SummernoteRichText', {});\n\n    window.annotations_saved = [];\n\n    window.vid.rangeslider(jQuery.extend(true, {}, {}));\n    window.vid.annotations(jQuery.extend(true, {}, {postBigNew: \"none\"}));\n\n    // sets up the rangesliders to their appropriate start and end locations\n    jQuery(window.vid.annotations.rsdl.el()).watch('left', function(data, i){\n        jQuery('#startTimeFilter').val(window.vid.annotations.rsdbl.el_.firstChild.innerHTML);\n    });\n    jQuery(window.vid.annotations.rsdr.el()).watch('left', function(data, i){\n        jQuery('#endTimeFilter').val(window.vid.annotations.rsdbr.el_.firstChild.innerHTML);\n    });\n\n    if (typeof(window.annotation_tool) !== \"undefined\") {\n\n        window.annotation_tool.subscribe(\"annotationsLoaded\", function(annotations) {\n            if (annotations.length > 0) {\n                window.updateDashboard(annotations);\n            };\n        });\n        \n        window.annotation_tool.subscribe('annotationHidden', function(annotationId) {\n            jQuery('.annotationItem.item-' + annotationId).hide();\n        });\n        window.annotation_tool.subscribe('annotationShown', function(annotationId) {\n            jQuery('.annotationItem.item-' + annotationId).show();\n        });\n    } else {\n        // Mirador doesn't use annotator events so this is triggered by the buttons pushed.\n    }\n\n    if (annotationListURL.length == 0) {\n        jQuery('#container').after('<a id=\"print-annotations\">Download Annotations JSON</button>');\n        jQuery('body').on('click', '#print-annotations', function() {\n            var annotationList = {\n                rows: window.annotation_tool.plugins.LocalStore.dumpAnnotations()\n            }\n            var new_page = 'data:application/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(annotationList, null, 4));\n            var downloadAnchorNode = document.createElement('a');\n            downloadAnchorNode.setAttribute(\"href\",     new_page);\n            downloadAnchorNode.setAttribute(\"download\", \"annotations.json\");\n            document.body.appendChild(downloadAnchorNode); // required for firefox\n            downloadAnchorNode.click();\n            downloadAnchorNode.remove();\n        });\n        jQuery('.sidebar').hide();\n        jQuery('#container').after('<input type=\"file\" id=\"import-json\" multiple size=\"50\">');\n        jQuery('body').on('change', '#import-json', function() {\n            var fr = new FileReader();\n\n              fr.onload = function(e) { \n                var result = JSON.parse(e.target.result);\n                jQuery.each(result['rows'], function(_, ann) {\n                    console.log(ann);\n                    window.annotation_tool.setupAnnotation(ann);\n                    window.annotation_tool.plugins.LocalStore.annotationCreated(ann);\n                    window.annotation_tool.loadAnnotations();\n                });\n              }\n\n              fr.readAsText(this.files.item(0));\n        });\n    } else {\n        if(annotationListURL.indexOf('http') == -1){\n            annotationListURL = 'https://' + annotationListURL;\n        }\n        jQuery.ajax({\n            url: annotationListURL,\n            method: 'GET',\n            success: function(data) {\n                delete window.annotation_tool.plugins.LocalStore;\n                window.annotation_tool.addPlugin('LocalStore', {\n                    annotations: data.rows\n                });\n\n                jQuery(document).trigger('annotation_core_init');\n            }\n        });\n    }\n\n    window.updateDashboard = function(annotations) {\n      jQuery('.annotationsHolder').html(\"\");\n      jQuery.each(annotations, function(index, value){\n            var html = '';\n            if (value.media === \"video\") {\n                html = \"<div class='annotationItem item-\"+value.id+\"' role='listitem' aria-label='Annotation #\"+index+\"'><div class='playMediaButton'><span class='fa fa-youtube-play'></span> Play Clip</div><div class='body field' aria-label='Comment within group'>\"+value.text+\"</div><div class='tagList field side'>\";\n            } else if (value.media === \"text\") {\n                html = \"<div class='annotationItem item-\"+value.id+\"' role='listitem' aria-label='Annotation #\"+index+\"'><div class='quote'>\"+value.quote+\"</div><div class='body field' aria-label='Comment within group'>\"+value.text+\"</div><div class='tagList field side'>\";\n            } else if (value.media === \"image\") {\n                html = \"<div class='annotationItem item-\"+value.id+\"' role='listitem' aria-label='Annotation #\"+index+\"'><div class='zoomToImageBounds'><img src='\"+value.thumb+\"'></div><div class='body field' aria-label='Comment within group'>\"+value.text+\"</div><div class='tagList field side'>\";\n\n            }\n            \n            jQuery.each(value.tags, function(ind, tag){\n                if (tag !== undefined && tag !== '') {\n                    html+= \"<div class='tag side'>\" + tag.replace(/_/g, ' ') + \"</div>\";\n                }\n            });\n            html += \"</div></div>\";\n            jQuery('.annotationsHolder').append(html);\n            if (value.media === \"video\") {\n                jQuery('.annotationItem.item-'+value.id+' .playMediaButton ').click ( function(e) {\n                    var player = window.vid;\n                    player.annotator = window.annotation_tool;\n                    //player.annotations.showAnnotation(annotation);\n                    var playFunction = function() {\n                        // Fix problem with youtube videos in the first play. The plugin don't have this trigger\n                        if (player.techName === 'Youtube') {\n                            var startAPI = function() {\n                                player.annotations.showAnnotation(value);\n                            }\n                            if (player.annotations.loaded)\n                                startAPI();\n                            else\n                                player.one('loadedRangeSlider', startAPI); // show Annotations once the RangeSlider is loaded\n                        } else {\n                            player.annotations.showAnnotation(value);\n                        }\n                    };\n                    if (player.paused()) {\n                        player.play();\n                        player.one('playing', playFunction);\n                    } else {\n                        playFunction();\n                    }\n                });\n            } else if (value.media == 'text') {\n                jQuery('.annotationItem.item-'+index+' .quote ').click(function() {\n                    jQuery('html, body').animate({\n                        scrollTop: jQuery('.annotator-hl[@data-annotation-id=\"' + value.id + '\"').offset().top\n                    }, 500);\n                });\n            } else if (value.media == 'image') {\n                jQuery('.annotationItem.item-'+value.id+' .zoomToImageBounds').click(function(){\n                    var ranges = value.rangePosition;\n                    jQuery.publish('fitBounds.'+Mirador.viewer.workspace.slots[0].window.id, {'x':ranges.x, 'y': ranges.y, 'width':ranges.width, 'height':ranges.height});\n                });\n            }\n            jQuery('.annotationItem.item-'+value.id+' .tagList .tag').click ( function(e) {\n                if (!window.isFiltered) {\n                    var tag = jQuery(this).html();\n                    jQuery.each(window.annotation_tool.plugins.LocalStore.annotations, function(index, annotation) {\n                        if (annotation.tags.indexOf(tag.replace(/ /g,'_')) == -1) {\n                            jQuery('.item-'+annotation.id).hide();\n                        } else {\n                            //jQuery('.item-'+annotation.id).show();\n                        }\n                    });\n                    jQuery('.annotationsHolder').prepend('<div class=\"filter-message\">Showing only annotations with tag \"'+tag+'\". Click here to show all annotations.</div>');\n                    jQuery('.filter-message').click(function(e) {\n                        jQuery.each(window.annotation_tool.plugins.LocalStore.annotations, function(index, annotation) {\n                            jQuery('.item-'+annotation.id).show();\n                        });\n                        window.isFiltered = false;\n                        jQuery('.filter-message').remove();\n                    });\n                    jQuery('.annotationSection').animate({scrollTop:0});\n                    window.isFiltered = true;\n                }\n            });\n        });\n    };\n    if (annotationListURL.length == 0) {\n        setTimeout(function() {\n            console.log(JSON.stringify(jQuery('.vjs-new-annotation')));\n            jQuery('.vjs-new-annotation').show();\n        }, 2000);\n    }\n\n}\n\n//# sourceURL=webpack:///./src/video_annotation_core.js?");

/***/ }),

/***/ "./src/video_setup.css":
/*!*****************************!*\
  !*** ./src/video_setup.css ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n//# sourceURL=webpack:///./src/video_setup.css?");

/***/ }),

/***/ "./src/video_setup.js":
/*!****************************!*\
  !*** ./src/video_setup.js ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap/dist/css/bootstrap.min.css */ \"./node_modules/bootstrap/dist/css/bootstrap.min.css\");\n/* harmony import */ var bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _video_target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./video_target.js */ \"./src/video_target.js\");\n\n\n__webpack_require__(/*! ./static/vendors/development/css/video-js.min.css */ \"./src/static/vendors/development/css/video-js.min.css\");\n__webpack_require__(/*! ./static/vendors/development/css/ova.css */ \"./src/static/vendors/development/css/ova.css\");\n__webpack_require__(/*! ./static/vendors/development/css/rangeslider.css */ \"./src/static/vendors/development/css/rangeslider.css\");\n__webpack_require__(/*! ./static/vendors/Annotator/annotator.css */ \"./src/static/vendors/Annotator/annotator.css\");\n__webpack_require__(/*! ./static/vendors/development/css/font-awesome.css */ \"./src/static/vendors/development/css/font-awesome.css\");\n__webpack_require__(/*! ./static/vendors/development/css/summernote.css */ \"./src/static/vendors/development/css/summernote.css\");\n__webpack_require__(/*! ./static/vendors/Annotator/plugins/summernote-richtext-annotator.css */ \"./src/static/vendors/Annotator/plugins/summernote-richtext-annotator.css\");\n__webpack_require__(/*! ./static/vendors/development/css/token-input.css */ \"./src/static/vendors/development/css/token-input.css\");\n__webpack_require__(/*! ./static/vendors/development/css/videojs-transcript.css */ \"./src/static/vendors/development/css/videojs-transcript.css\");\n__webpack_require__(/*! ./static/css/instructions.css */ \"./src/static/css/instructions.css\");\n__webpack_require__(/*! ./static/css/annotation_base.css */ \"./src/static/css/annotation_base.css\");\n__webpack_require__(/*! ./common.css */ \"./src/common.css\");\n__webpack_require__(/*! ./video_setup.css */ \"./src/video_setup.css\");\n\n\n\njQuery(document).ready(function() {\n    var url = jQuery('#video-url').html();\n    if (url.length > 0 && url.indexOf('http') === -1) {\n        url = \"https://\" + url;\n    }\n    Object(_video_target_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(url);\n});\n\n//# sourceURL=webpack:///./src/video_setup.js?");

/***/ }),

/***/ "./src/video_target.js":
/*!*****************************!*\
  !*** ./src/video_target.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(videojs) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return retrieveTargetFromURL; });\n/* harmony import */ var _video_annotation_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./video_annotation_core.js */ \"./src/video_annotation_core.js\");\n\n\nfunction retrieveTargetFromURL(url) {\n    var transcript_url = jQuery('#transcript').html().trim();\n    if (transcript_url.length > 0 && transcript_url.indexOf('http') === -1) {\n        transcript_url = \"https://\" + transcript_url;\n    }\n    \n    function get_url_extension( url ) {\n        return url.split(/\\#|\\?/)[0].split('.').pop().trim();\n    }\n    var url_type = 'video/youtube'\n    if (url.indexOf('youtu') ===-1) {\n        url_type = 'video/' + get_url_extension(url);\n    }\n\n    var video_id = 'video' + (jQuery('video').length + 1);\n    var video_setup_html = \"<div id='viewer'><video id='\" + video_id + \"' class='video-js vjs-default-skin' controls='controls' preload='none' width='auto' height='698'>\"\n    video_setup_html += \"<source src='\" + url + \"' type='\" + url_type + \"' />\"\n    if (transcript_url && transcript_url.length > 0) {\n        video_setup_html += \"<track kind='captions' src='\" + transcript_url + \"' srclang='en' label='English' default />\";\n    }\n    video_setup_html += \"</video></div>\";\n    jQuery('#container').append(video_setup_html);\n    jQuery('#hxat_lite_loading').hide();\n    jQuery('.sidebar').show();\n    jQuery('#container').show();\n    jQuery('.annotationSection').css('height', jQuery('#viewer').outerHeight() + 'px');\n\n    window.extra_options = {}\n    jQuery.each(jQuery('#extra_options').children(), function(index, value) {\n        window.extra_options[value.className] = value.innerHTML;\n    });\n    // start videojs player\n    var vidElement = jQuery('#' + video_id)[0];\n    if (typeof(videojs) !== undefined) {\n        window.vid = videojs(vidElement, {\n            techOrder: ['html5', 'youtube', 'flash'],\n            playbackRates: [0.5, 1, 1.5, 2],\n            downloadItems: [],\n        }, {});\n\n        if (transcript_url && transcript_url.length > 0) {\n            var transcript_options = {\n                showTitle: false,\n                showTrackSelector: false\n            }\n            __webpack_require__(/*! videojs-transcript */ \"./src/static/vendors/development/videojs-transcript.js\");\n\n            window.transcript = window.vid.transcript(transcript_options);\n            jQuery('#transcript').html(window.transcript.el());\n\n             // the transcript should be hidden unless otherwise stated\n            if (window.extra_options.transcript_on_load == \"true\") {\n                jQuery(\"#transcript\").show();\n            }\n\n            jQuery('.vjs-transcript-control.vjs-control').click(function(){\n                setTimeout(function(){\n                    var state = 'open';\n                    if (jQuery('#transcript').is(':visible')) {\n                        jQuery('#container').addClass('transcript');\n                    } else {\n                        jQuery('#container').removeClass('transcript');\n                        state = 'close';\n                    }\n                    var evt;\n                    try {\n                        evt = new Event('resize');\n                    } catch(e) {\n                        evt = window.document.createEvent('UIEvents');\n                        evt.initUIEvent('resize', true, false, window, 0);\n                    }\n                    window.dispatchEvent(evt);\n\n                }, 250);\n            });\n        } else {\n            jQuery('.vjs-transcript-control.vjs-control').hide();\n        }\n    }\n\n    window.hx_tab_list = jQuery('.nav-item.tab').length;\n    window.hx_current_tab_index = jQuery('.nav-item.tab.active').data('element');\n    var valid_pathname = window.location.href.indexOf('child=') > -1 ? window.location.pathname + window.hx_current_tab_index : window.location.pathname;\n    jQuery('body').on('mousedown', '.sequence-nav-button.button-previous',function(event) {\n        if (window.hx_current_tab_index > 1) {\n            valid_pathname = valid_pathname.replace(/\\/([^\\/]*)$/, '/' + (window.hx_current_tab_index - 1));\n            window.location.assign(window.location.protocol + '//' + window.location.host + valid_pathname);\n            // if (window.location.pathname.substr(-2).replace('/','').length == 1) {\n            //     console.log(window.location.href.substr(-2).replace('/','').length)\n            //     window.location.assign((window.location.protocol + '//' + window.location.host + window.location.pathname).replace(/.$/, (window.hx_current_tab_index - 1)));\n            // } else {\n            //     window.location.assign(window.location.protocol + '//' + window.location.host + window.location.pathname + (window.hx_current_tab_index - 1));\n            // }\n        }\n        return false;\n    });\n    jQuery('body').on('mousedown', '.sequence-nav-button.button-next',function(event) {\n        if (window.hx_current_tab_index < window.hx_tab_list) {\n            valid_pathname = valid_pathname.replace(/\\/([^\\/]*)$/, '/' + (window.hx_current_tab_index + 1));\n            window.location.assign(window.location.protocol + '//' + window.location.host + valid_pathname);\n            // if (window.location.pathname.substr(-2).replace('/','').length == 1) {\n            //     window.location.assign((window.location.protocol + '//' + window.location.host + window.location.pathname).replace(/.$/, (window.hx_current_tab_index + 1)));\n            // } else {\n            //     window.location.assign(window.location.protocol + '//' + window.location.host + window.location.pathname + (window.hx_current_tab_index + 1));\n            // }\n        }\n        return false;\n    });\n\n    jQuery('body').on('mousedown', '.nav-item.tab',function(event) {\n\n        var newIndex = jQuery(event.target).data('element');\n        valid_pathname = valid_pathname.replace(/\\/([^\\/]*)$/, '/' + (newIndex));\n        window.location.assign(window.location.protocol + '//' + window.location.host + valid_pathname);\n        // if (window.location.pathname.substr(-2).replace('/','').length == 1) {\n        //     window.location.assign((window.location.protocol + '//' + window.location.host + window.location.pathname).replace(/.$/, newIndex));\n        // } else {\n        //     window.location.assign(window.location.protocol + '//' + window.location.host + window.location.pathname + newIndex);\n        // }\n        return false;\n    });\n\n    Object(_video_annotation_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/static/vendors/development/video.dev.js */ \"./src/static/vendors/development/video.dev.js\")))\n\n//# sourceURL=webpack:///./src/video_target.js?");

/***/ }),

/***/ 1:
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./src/common.js ./src/video_setup.js ./src/static/vendors/development/json2.js videojs ./src/edited/summernote_for_hxatlite.js ./src/static/vendors/development/jquery.tokeninput.js ./src/static/vendors/development/vjs.youtube.js videojs-transcript ./src/static/vendors/development/jQuery-Watch.js ./src/static/vendors/development/rangeslider.js ./src/static/vendors/development/video-speed.js HighlightTags SummernoteRichText LocalStore ./src/static/vendors/development/videojs-annotator-plugin.js ./src/static/vendors/Annotator/plugins/timeRangeEditor-annotator.js ./src/static/vendors/Annotator/plugins/videojs-annotator.js ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/common.js */\"./src/common.js\");\n__webpack_require__(/*! ./src/video_setup.js */\"./src/video_setup.js\");\n__webpack_require__(/*! /Users/lfd776/Desktop/April/Demo 2019/webpack-test/src/static/vendors/development/json2.js */\"./src/static/vendors/development/json2.js\");\n__webpack_require__(/*! videojs */\"./src/static/vendors/development/video.dev.js\");\n__webpack_require__(/*! /Users/lfd776/Desktop/April/Demo 2019/webpack-test/src/edited/summernote_for_hxatlite.js */\"./src/edited/summernote_for_hxatlite.js\");\n__webpack_require__(/*! /Users/lfd776/Desktop/April/Demo 2019/webpack-test/src/static/vendors/development/jquery.tokeninput.js */\"./src/static/vendors/development/jquery.tokeninput.js\");\n__webpack_require__(/*! /Users/lfd776/Desktop/April/Demo 2019/webpack-test/src/static/vendors/development/vjs.youtube.js */\"./src/static/vendors/development/vjs.youtube.js\");\n__webpack_require__(/*! videojs-transcript */\"./src/static/vendors/development/videojs-transcript.js\");\n__webpack_require__(/*! /Users/lfd776/Desktop/April/Demo 2019/webpack-test/src/static/vendors/development/jQuery-Watch.js */\"./src/static/vendors/development/jQuery-Watch.js\");\n__webpack_require__(/*! /Users/lfd776/Desktop/April/Demo 2019/webpack-test/src/static/vendors/development/rangeslider.js */\"./src/static/vendors/development/rangeslider.js\");\n__webpack_require__(/*! /Users/lfd776/Desktop/April/Demo 2019/webpack-test/src/static/vendors/development/video-speed.js */\"./src/static/vendors/development/video-speed.js\");\n__webpack_require__(/*! HighlightTags */\"./src/static/vendors/Annotator/plugins/highlightTags-annotator.js\");\n__webpack_require__(/*! SummernoteRichText */\"./src/static/vendors/Annotator/plugins/summernote-richtext-annotator.js\");\n__webpack_require__(/*! LocalStore */\"./src/static/vendors/Annotator/plugins/localstore-annotator.js\");\n__webpack_require__(/*! /Users/lfd776/Desktop/April/Demo 2019/webpack-test/src/static/vendors/development/videojs-annotator-plugin.js */\"./src/static/vendors/development/videojs-annotator-plugin.js\");\n__webpack_require__(/*! /Users/lfd776/Desktop/April/Demo 2019/webpack-test/src/static/vendors/Annotator/plugins/timeRangeEditor-annotator.js */\"./src/static/vendors/Annotator/plugins/timeRangeEditor-annotator.js\");\nmodule.exports = __webpack_require__(/*! /Users/lfd776/Desktop/April/Demo 2019/webpack-test/src/static/vendors/Annotator/plugins/videojs-annotator.js */\"./src/static/vendors/Annotator/plugins/videojs-annotator.js\");\n\n\n//# sourceURL=webpack:///multi_./src/common.js_./src/video_setup.js_./src/static/vendors/development/json2.js_videojs_./src/edited/summernote_for_hxatlite.js_./src/static/vendors/development/jquery.tokeninput.js_./src/static/vendors/development/vjs.youtube.js_videojs-transcript_./src/static/vendors/development/jQuery-Watch.js_./src/static/vendors/development/rangeslider.js_./src/static/vendors/development/video-speed.js_HighlightTags_SummernoteRichText_LocalStore_./src/static/vendors/development/videojs-annotator-plugin.js_./src/static/vendors/Annotator/plugins/timeRangeEditor-annotator.js_./src/static/vendors/Annotator/plugins/videojs-annotator.js?");

/***/ })

/******/ }); 